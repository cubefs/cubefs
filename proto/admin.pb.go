// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: admin.proto

package proto

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type DataPartitionResponsePb struct {
	PartitionID          uint64       `protobuf:"varint,1,opt,name=PartitionID,proto3" json:"PartitionID,omitempty"`
	Status               int32        `protobuf:"varint,2,opt,name=Status,proto3" json:"Status,omitempty"`
	ReplicaNum           uint32       `protobuf:"varint,3,opt,name=ReplicaNum,proto3" json:"ReplicaNum,omitempty"`
	Hosts                []string     `protobuf:"bytes,4,rep,name=Hosts,proto3" json:"Hosts,omitempty"`
	LeaderAddr           AtomicString `protobuf:"bytes,5,opt,name=LeaderAddr,proto3,customtype=AtomicString" json:"LeaderAddr"`
	Epoch                uint64       `protobuf:"varint,6,opt,name=Epoch,proto3" json:"Epoch,omitempty"`
	IsRecover            bool         `protobuf:"varint,7,opt,name=IsRecover,proto3" json:"IsRecover,omitempty"`
	IsFrozen             bool         `protobuf:"varint,8,opt,name=IsFrozen,proto3" json:"IsFrozen,omitempty"`
	CreateTime           int64        `protobuf:"varint,9,opt,name=CreateTime,proto3" json:"CreateTime,omitempty"`
	MediumType           string       `protobuf:"bytes,10,opt,name=MediumType,proto3" json:"MediumType,omitempty"`
	Total                uint64       `protobuf:"varint,11,opt,name=Total,proto3" json:"Total,omitempty"`
	Used                 uint64       `protobuf:"varint,12,opt,name=Used,proto3" json:"Used,omitempty"`
	EcMigrateStatus      uint32       `protobuf:"varint,13,opt,name=EcMigrateStatus,proto3" json:"EcMigrateStatus,omitempty"`
	EcHosts              []string     `protobuf:"bytes,14,rep,name=EcHosts,proto3" json:"EcHosts,omitempty"`
	EcDataNum            uint32       `protobuf:"varint,15,opt,name=EcDataNum,proto3" json:"EcDataNum,omitempty"`
	EcMaxUnitSize        uint64       `protobuf:"varint,16,opt,name=EcMaxUnitSize,proto3" json:"EcMaxUnitSize,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *DataPartitionResponsePb) Reset()         { *m = DataPartitionResponsePb{} }
func (m *DataPartitionResponsePb) String() string { return proto.CompactTextString(m) }
func (*DataPartitionResponsePb) ProtoMessage()    {}
func (*DataPartitionResponsePb) Descriptor() ([]byte, []int) {
	return fileDescriptor_73a7fc70dcc2027c, []int{0}
}
func (m *DataPartitionResponsePb) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataPartitionResponsePb) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataPartitionResponsePb.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataPartitionResponsePb) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataPartitionResponsePb.Merge(m, src)
}
func (m *DataPartitionResponsePb) XXX_Size() int {
	return m.Size()
}
func (m *DataPartitionResponsePb) XXX_DiscardUnknown() {
	xxx_messageInfo_DataPartitionResponsePb.DiscardUnknown(m)
}

var xxx_messageInfo_DataPartitionResponsePb proto.InternalMessageInfo

type DataPartitionsViewPb struct {
	DataPartitions       []*DataPartitionResponsePb `protobuf:"bytes,1,rep,name=DataPartitions,proto3" json:"DataPartitions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *DataPartitionsViewPb) Reset()         { *m = DataPartitionsViewPb{} }
func (m *DataPartitionsViewPb) String() string { return proto.CompactTextString(m) }
func (*DataPartitionsViewPb) ProtoMessage()    {}
func (*DataPartitionsViewPb) Descriptor() ([]byte, []int) {
	return fileDescriptor_73a7fc70dcc2027c, []int{1}
}
func (m *DataPartitionsViewPb) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataPartitionsViewPb) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataPartitionsViewPb.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataPartitionsViewPb) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataPartitionsViewPb.Merge(m, src)
}
func (m *DataPartitionsViewPb) XXX_Size() int {
	return m.Size()
}
func (m *DataPartitionsViewPb) XXX_DiscardUnknown() {
	xxx_messageInfo_DataPartitionsViewPb.DiscardUnknown(m)
}

var xxx_messageInfo_DataPartitionsViewPb proto.InternalMessageInfo

func (m *DataPartitionsViewPb) GetDataPartitions() []*DataPartitionResponsePb {
	if m != nil {
		return m.DataPartitions
	}
	return nil
}

type MetaPartitionViewPb struct {
	PartitionID          uint64   `protobuf:"varint,1,opt,name=PartitionID,proto3" json:"PartitionID,omitempty"`
	Start                uint64   `protobuf:"varint,2,opt,name=Start,proto3" json:"Start,omitempty"`
	End                  uint64   `protobuf:"varint,3,opt,name=End,proto3" json:"End,omitempty"`
	MaxInodeID           uint64   `protobuf:"varint,4,opt,name=MaxInodeID,proto3" json:"MaxInodeID,omitempty"`
	InodeCount           uint64   `protobuf:"varint,5,opt,name=InodeCount,proto3" json:"InodeCount,omitempty"`
	DentryCount          uint64   `protobuf:"varint,6,opt,name=DentryCount,proto3" json:"DentryCount,omitempty"`
	MaxExistIno          uint64   `protobuf:"varint,7,opt,name=MaxExistIno,proto3" json:"MaxExistIno,omitempty"`
	IsRecover            bool     `protobuf:"varint,8,opt,name=IsRecover,proto3" json:"IsRecover,omitempty"`
	Members              []string `protobuf:"bytes,9,rep,name=Members,proto3" json:"Members,omitempty"`
	Learners             []string `protobuf:"bytes,10,rep,name=Learners,proto3" json:"Learners,omitempty"`
	LeaderAddr           string   `protobuf:"bytes,11,opt,name=LeaderAddr,proto3" json:"LeaderAddr,omitempty"`
	Status               int32    `protobuf:"varint,12,opt,name=Status,proto3" json:"Status,omitempty"`
	StoreMode            uint32   `protobuf:"varint,13,opt,name=StoreMode,proto3" json:"StoreMode,omitempty"`
	MemCount             uint32   `protobuf:"varint,14,opt,name=MemCount,proto3" json:"MemCount,omitempty"`
	RocksCount           uint32   `protobuf:"varint,15,opt,name=RocksCount,proto3" json:"RocksCount,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MetaPartitionViewPb) Reset()         { *m = MetaPartitionViewPb{} }
func (m *MetaPartitionViewPb) String() string { return proto.CompactTextString(m) }
func (*MetaPartitionViewPb) ProtoMessage()    {}
func (*MetaPartitionViewPb) Descriptor() ([]byte, []int) {
	return fileDescriptor_73a7fc70dcc2027c, []int{2}
}
func (m *MetaPartitionViewPb) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetaPartitionViewPb) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetaPartitionViewPb.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetaPartitionViewPb) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetaPartitionViewPb.Merge(m, src)
}
func (m *MetaPartitionViewPb) XXX_Size() int {
	return m.Size()
}
func (m *MetaPartitionViewPb) XXX_DiscardUnknown() {
	xxx_messageInfo_MetaPartitionViewPb.DiscardUnknown(m)
}

var xxx_messageInfo_MetaPartitionViewPb proto.InternalMessageInfo

func (m *MetaPartitionViewPb) GetPartitionID() uint64 {
	if m != nil {
		return m.PartitionID
	}
	return 0
}

func (m *MetaPartitionViewPb) GetStart() uint64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *MetaPartitionViewPb) GetEnd() uint64 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *MetaPartitionViewPb) GetMaxInodeID() uint64 {
	if m != nil {
		return m.MaxInodeID
	}
	return 0
}

func (m *MetaPartitionViewPb) GetInodeCount() uint64 {
	if m != nil {
		return m.InodeCount
	}
	return 0
}

func (m *MetaPartitionViewPb) GetDentryCount() uint64 {
	if m != nil {
		return m.DentryCount
	}
	return 0
}

func (m *MetaPartitionViewPb) GetMaxExistIno() uint64 {
	if m != nil {
		return m.MaxExistIno
	}
	return 0
}

func (m *MetaPartitionViewPb) GetIsRecover() bool {
	if m != nil {
		return m.IsRecover
	}
	return false
}

func (m *MetaPartitionViewPb) GetMembers() []string {
	if m != nil {
		return m.Members
	}
	return nil
}

func (m *MetaPartitionViewPb) GetLearners() []string {
	if m != nil {
		return m.Learners
	}
	return nil
}

func (m *MetaPartitionViewPb) GetLeaderAddr() string {
	if m != nil {
		return m.LeaderAddr
	}
	return ""
}

func (m *MetaPartitionViewPb) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *MetaPartitionViewPb) GetStoreMode() uint32 {
	if m != nil {
		return m.StoreMode
	}
	return 0
}

func (m *MetaPartitionViewPb) GetMemCount() uint32 {
	if m != nil {
		return m.MemCount
	}
	return 0
}

func (m *MetaPartitionViewPb) GetRocksCount() uint32 {
	if m != nil {
		return m.RocksCount
	}
	return 0
}

type MetaPartitionViewsPb struct {
	MetaPartitions       []*MetaPartitionViewPb `protobuf:"bytes,1,rep,name=MetaPartitions,proto3" json:"MetaPartitions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *MetaPartitionViewsPb) Reset()         { *m = MetaPartitionViewsPb{} }
func (m *MetaPartitionViewsPb) String() string { return proto.CompactTextString(m) }
func (*MetaPartitionViewsPb) ProtoMessage()    {}
func (*MetaPartitionViewsPb) Descriptor() ([]byte, []int) {
	return fileDescriptor_73a7fc70dcc2027c, []int{3}
}
func (m *MetaPartitionViewsPb) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetaPartitionViewsPb) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetaPartitionViewsPb.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetaPartitionViewsPb) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetaPartitionViewsPb.Merge(m, src)
}
func (m *MetaPartitionViewsPb) XXX_Size() int {
	return m.Size()
}
func (m *MetaPartitionViewsPb) XXX_DiscardUnknown() {
	xxx_messageInfo_MetaPartitionViewsPb.DiscardUnknown(m)
}

var xxx_messageInfo_MetaPartitionViewsPb proto.InternalMessageInfo

func (m *MetaPartitionViewsPb) GetMetaPartitions() []*MetaPartitionViewPb {
	if m != nil {
		return m.MetaPartitions
	}
	return nil
}

type EcPartitionResponsePb struct {
	PartitionID          uint64   `protobuf:"varint,1,opt,name=PartitionID,proto3" json:"PartitionID,omitempty"`
	Status               int32    `protobuf:"varint,2,opt,name=Status,proto3" json:"Status,omitempty"`
	ReplicaNum           uint32   `protobuf:"varint,3,opt,name=ReplicaNum,proto3" json:"ReplicaNum,omitempty"`
	Hosts                []string `protobuf:"bytes,4,rep,name=Hosts,proto3" json:"Hosts,omitempty"`
	LeaderAddr           string   `protobuf:"bytes,5,opt,name=LeaderAddr,proto3" json:"LeaderAddr,omitempty"`
	DataUnitsNum         uint32   `protobuf:"varint,6,opt,name=DataUnitsNum,proto3" json:"DataUnitsNum,omitempty"`
	ParityUnitsNum       uint32   `protobuf:"varint,7,opt,name=ParityUnitsNum,proto3" json:"ParityUnitsNum,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EcPartitionResponsePb) Reset()         { *m = EcPartitionResponsePb{} }
func (m *EcPartitionResponsePb) String() string { return proto.CompactTextString(m) }
func (*EcPartitionResponsePb) ProtoMessage()    {}
func (*EcPartitionResponsePb) Descriptor() ([]byte, []int) {
	return fileDescriptor_73a7fc70dcc2027c, []int{4}
}
func (m *EcPartitionResponsePb) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EcPartitionResponsePb) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EcPartitionResponsePb.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EcPartitionResponsePb) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EcPartitionResponsePb.Merge(m, src)
}
func (m *EcPartitionResponsePb) XXX_Size() int {
	return m.Size()
}
func (m *EcPartitionResponsePb) XXX_DiscardUnknown() {
	xxx_messageInfo_EcPartitionResponsePb.DiscardUnknown(m)
}

var xxx_messageInfo_EcPartitionResponsePb proto.InternalMessageInfo

func (m *EcPartitionResponsePb) GetPartitionID() uint64 {
	if m != nil {
		return m.PartitionID
	}
	return 0
}

func (m *EcPartitionResponsePb) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *EcPartitionResponsePb) GetReplicaNum() uint32 {
	if m != nil {
		return m.ReplicaNum
	}
	return 0
}

func (m *EcPartitionResponsePb) GetHosts() []string {
	if m != nil {
		return m.Hosts
	}
	return nil
}

func (m *EcPartitionResponsePb) GetLeaderAddr() string {
	if m != nil {
		return m.LeaderAddr
	}
	return ""
}

func (m *EcPartitionResponsePb) GetDataUnitsNum() uint32 {
	if m != nil {
		return m.DataUnitsNum
	}
	return 0
}

func (m *EcPartitionResponsePb) GetParityUnitsNum() uint32 {
	if m != nil {
		return m.ParityUnitsNum
	}
	return 0
}

type EcPartitionsViewPb struct {
	EcPartitions         []*EcPartitionResponsePb `protobuf:"bytes,1,rep,name=EcPartitions,proto3" json:"EcPartitions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *EcPartitionsViewPb) Reset()         { *m = EcPartitionsViewPb{} }
func (m *EcPartitionsViewPb) String() string { return proto.CompactTextString(m) }
func (*EcPartitionsViewPb) ProtoMessage()    {}
func (*EcPartitionsViewPb) Descriptor() ([]byte, []int) {
	return fileDescriptor_73a7fc70dcc2027c, []int{5}
}
func (m *EcPartitionsViewPb) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EcPartitionsViewPb) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EcPartitionsViewPb.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EcPartitionsViewPb) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EcPartitionsViewPb.Merge(m, src)
}
func (m *EcPartitionsViewPb) XXX_Size() int {
	return m.Size()
}
func (m *EcPartitionsViewPb) XXX_DiscardUnknown() {
	xxx_messageInfo_EcPartitionsViewPb.DiscardUnknown(m)
}

var xxx_messageInfo_EcPartitionsViewPb proto.InternalMessageInfo

func (m *EcPartitionsViewPb) GetEcPartitions() []*EcPartitionResponsePb {
	if m != nil {
		return m.EcPartitions
	}
	return nil
}

type OSSSecure struct {
	AccessKey string `protobuf:"bytes,1,opt,name=AccessKey,proto3" json:"AccessKey,omitempty"`
	SecretKey string `protobuf:"bytes,2,opt,name=SecretKey,proto3" json:"SecretKey,omitempty"`
}

func (m *OSSSecure) Reset()         { *m = OSSSecure{} }
func (m *OSSSecure) String() string { return proto.CompactTextString(m) }
func (*OSSSecure) ProtoMessage()    {}
func (*OSSSecure) Descriptor() ([]byte, []int) {
	return fileDescriptor_73a7fc70dcc2027c, []int{6}
}
func (m *OSSSecure) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OSSSecure) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OSSSecure.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OSSSecure) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OSSSecure.Merge(m, src)
}
func (m *OSSSecure) XXX_Size() int {
	return m.Size()
}
func (m *OSSSecure) XXX_DiscardUnknown() {
	xxx_messageInfo_OSSSecure.DiscardUnknown(m)
}

var xxx_messageInfo_OSSSecure proto.InternalMessageInfo

func (m *OSSSecure) GetAccessKey() string {
	if m != nil {
		return m.AccessKey
	}
	return ""
}

func (m *OSSSecure) GetSecretKey() string {
	if m != nil {
		return m.SecretKey
	}
	return ""
}

type ConnConfig struct {
	IdleTimeoutSec   int64 `protobuf:"varint,1,opt,name=IdleTimeoutSec,proto3" json:"IdleTimeoutSec,omitempty"`
	ConnectTimeoutNs int64 `protobuf:"varint,2,opt,name=ConnectTimeoutNs,proto3" json:"ConnectTimeoutNs,omitempty"`
	WriteTimeoutNs   int64 `protobuf:"varint,3,opt,name=WriteTimeoutNs,proto3" json:"WriteTimeoutNs,omitempty"`
	ReadTimeoutNs    int64 `protobuf:"varint,4,opt,name=ReadTimeoutNs,proto3" json:"ReadTimeoutNs,omitempty"`
}

func (m *ConnConfig) Reset()      { *m = ConnConfig{} }
func (*ConnConfig) ProtoMessage() {}
func (*ConnConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_73a7fc70dcc2027c, []int{7}
}
func (m *ConnConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnConfig.Merge(m, src)
}
func (m *ConnConfig) XXX_Size() int {
	return m.Size()
}
func (m *ConnConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ConnConfig proto.InternalMessageInfo

func (m *ConnConfig) GetIdleTimeoutSec() int64 {
	if m != nil {
		return m.IdleTimeoutSec
	}
	return 0
}

func (m *ConnConfig) GetConnectTimeoutNs() int64 {
	if m != nil {
		return m.ConnectTimeoutNs
	}
	return 0
}

func (m *ConnConfig) GetWriteTimeoutNs() int64 {
	if m != nil {
		return m.WriteTimeoutNs
	}
	return 0
}

func (m *ConnConfig) GetReadTimeoutNs() int64 {
	if m != nil {
		return m.ReadTimeoutNs
	}
	return 0
}

type VolViewPb struct {
	Name                 string                     `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	Owner                string                     `protobuf:"bytes,2,opt,name=Owner,proto3" json:"Owner,omitempty"`
	Status               uint32                     `protobuf:"varint,3,opt,name=Status,proto3" json:"Status,omitempty"`
	FollowerRead         bool                       `protobuf:"varint,4,opt,name=FollowerRead,proto3" json:"FollowerRead,omitempty"`
	ForceROW             bool                       `protobuf:"varint,5,opt,name=ForceROW,proto3" json:"ForceROW,omitempty"`
	EnableWriteCache     bool                       `protobuf:"varint,6,opt,name=EnableWriteCache,proto3" json:"EnableWriteCache,omitempty"`
	CrossRegionHAType    uint32                     `protobuf:"varint,7,opt,name=CrossRegionHAType,proto3" json:"CrossRegionHAType,omitempty"`
	MetaPartitions       []*MetaPartitionViewPb     `protobuf:"bytes,8,rep,name=MetaPartitions,proto3" json:"MetaPartitions,omitempty"`
	DataPartitions       []*DataPartitionResponsePb `protobuf:"bytes,9,rep,name=DataPartitions,proto3" json:"DataPartitions,omitempty"`
	EcPartitions         []*EcPartitionResponsePb   `protobuf:"bytes,10,rep,name=EcPartitions,proto3" json:"EcPartitions,omitempty"`
	OSSSecure            *OSSSecure                 `protobuf:"bytes,11,opt,name=OSSSecure,proto3" json:"OSSSecure,omitempty"`
	OSSBucketPolicy      uint32                     `protobuf:"varint,12,opt,name=OSSBucketPolicy,proto3" json:"OSSBucketPolicy,omitempty"`
	CreateTime           int64                      `protobuf:"varint,13,opt,name=CreateTime,proto3" json:"CreateTime,omitempty"`
	ConnConfig           *ConnConfig                `protobuf:"bytes,14,opt,name=ConnConfig,proto3" json:"ConnConfig,omitempty"`
	IsSmart              bool                       `protobuf:"varint,15,opt,name=IsSmart,proto3" json:"IsSmart,omitempty"`
	SmartEnableTime      int64                      `protobuf:"varint,16,opt,name=SmartEnableTime,proto3" json:"SmartEnableTime,omitempty"`
	SmartRules           []string                   `protobuf:"bytes,17,rep,name=SmartRules,proto3" json:"SmartRules,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *VolViewPb) Reset()         { *m = VolViewPb{} }
func (m *VolViewPb) String() string { return proto.CompactTextString(m) }
func (*VolViewPb) ProtoMessage()    {}
func (*VolViewPb) Descriptor() ([]byte, []int) {
	return fileDescriptor_73a7fc70dcc2027c, []int{8}
}
func (m *VolViewPb) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VolViewPb) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VolViewPb.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VolViewPb) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VolViewPb.Merge(m, src)
}
func (m *VolViewPb) XXX_Size() int {
	return m.Size()
}
func (m *VolViewPb) XXX_DiscardUnknown() {
	xxx_messageInfo_VolViewPb.DiscardUnknown(m)
}

var xxx_messageInfo_VolViewPb proto.InternalMessageInfo

func (m *VolViewPb) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *VolViewPb) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *VolViewPb) GetStatus() uint32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *VolViewPb) GetFollowerRead() bool {
	if m != nil {
		return m.FollowerRead
	}
	return false
}

func (m *VolViewPb) GetForceROW() bool {
	if m != nil {
		return m.ForceROW
	}
	return false
}

func (m *VolViewPb) GetEnableWriteCache() bool {
	if m != nil {
		return m.EnableWriteCache
	}
	return false
}

func (m *VolViewPb) GetCrossRegionHAType() uint32 {
	if m != nil {
		return m.CrossRegionHAType
	}
	return 0
}

func (m *VolViewPb) GetMetaPartitions() []*MetaPartitionViewPb {
	if m != nil {
		return m.MetaPartitions
	}
	return nil
}

func (m *VolViewPb) GetDataPartitions() []*DataPartitionResponsePb {
	if m != nil {
		return m.DataPartitions
	}
	return nil
}

func (m *VolViewPb) GetEcPartitions() []*EcPartitionResponsePb {
	if m != nil {
		return m.EcPartitions
	}
	return nil
}

func (m *VolViewPb) GetOSSSecure() *OSSSecure {
	if m != nil {
		return m.OSSSecure
	}
	return nil
}

func (m *VolViewPb) GetOSSBucketPolicy() uint32 {
	if m != nil {
		return m.OSSBucketPolicy
	}
	return 0
}

func (m *VolViewPb) GetCreateTime() int64 {
	if m != nil {
		return m.CreateTime
	}
	return 0
}

func (m *VolViewPb) GetConnConfig() *ConnConfig {
	if m != nil {
		return m.ConnConfig
	}
	return nil
}

func (m *VolViewPb) GetIsSmart() bool {
	if m != nil {
		return m.IsSmart
	}
	return false
}

func (m *VolViewPb) GetSmartEnableTime() int64 {
	if m != nil {
		return m.SmartEnableTime
	}
	return 0
}

func (m *VolViewPb) GetSmartRules() []string {
	if m != nil {
		return m.SmartRules
	}
	return nil
}

type HTTPReplyPb struct {
	Code                 int32    `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Msg                  string   `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Data                 []byte   `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HTTPReplyPb) Reset()         { *m = HTTPReplyPb{} }
func (m *HTTPReplyPb) String() string { return proto.CompactTextString(m) }
func (*HTTPReplyPb) ProtoMessage()    {}
func (*HTTPReplyPb) Descriptor() ([]byte, []int) {
	return fileDescriptor_73a7fc70dcc2027c, []int{9}
}
func (m *HTTPReplyPb) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HTTPReplyPb) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HTTPReplyPb.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HTTPReplyPb) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HTTPReplyPb.Merge(m, src)
}
func (m *HTTPReplyPb) XXX_Size() int {
	return m.Size()
}
func (m *HTTPReplyPb) XXX_DiscardUnknown() {
	xxx_messageInfo_HTTPReplyPb.DiscardUnknown(m)
}

var xxx_messageInfo_HTTPReplyPb proto.InternalMessageInfo

func (m *HTTPReplyPb) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *HTTPReplyPb) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *HTTPReplyPb) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type TokenPb struct {
	TokenType            int32    `protobuf:"varint,1,opt,name=TokenType,proto3" json:"TokenType,omitempty"`
	Value                string   `protobuf:"bytes,2,opt,name=Value,proto3" json:"Value,omitempty"`
	VolName              string   `protobuf:"bytes,3,opt,name=VolName,proto3" json:"VolName,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TokenPb) Reset()         { *m = TokenPb{} }
func (m *TokenPb) String() string { return proto.CompactTextString(m) }
func (*TokenPb) ProtoMessage()    {}
func (*TokenPb) Descriptor() ([]byte, []int) {
	return fileDescriptor_73a7fc70dcc2027c, []int{10}
}
func (m *TokenPb) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TokenPb) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TokenPb.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TokenPb) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TokenPb.Merge(m, src)
}
func (m *TokenPb) XXX_Size() int {
	return m.Size()
}
func (m *TokenPb) XXX_DiscardUnknown() {
	xxx_messageInfo_TokenPb.DiscardUnknown(m)
}

var xxx_messageInfo_TokenPb proto.InternalMessageInfo

func (m *TokenPb) GetTokenType() int32 {
	if m != nil {
		return m.TokenType
	}
	return 0
}

func (m *TokenPb) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *TokenPb) GetVolName() string {
	if m != nil {
		return m.VolName
	}
	return ""
}

type DpMetricsReportConfig struct {
	EnableReport      bool  `protobuf:"varint,1,opt,name=EnableReport,proto3" json:"EnableReport,omitempty"`
	ReportIntervalSec int64 `protobuf:"varint,2,opt,name=ReportIntervalSec,proto3" json:"ReportIntervalSec,omitempty"`
	FetchIntervalSec  int64 `protobuf:"varint,3,opt,name=FetchIntervalSec,proto3" json:"FetchIntervalSec,omitempty"`
}

func (m *DpMetricsReportConfig) Reset()      { *m = DpMetricsReportConfig{} }
func (*DpMetricsReportConfig) ProtoMessage() {}
func (*DpMetricsReportConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_73a7fc70dcc2027c, []int{11}
}
func (m *DpMetricsReportConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DpMetricsReportConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DpMetricsReportConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DpMetricsReportConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DpMetricsReportConfig.Merge(m, src)
}
func (m *DpMetricsReportConfig) XXX_Size() int {
	return m.Size()
}
func (m *DpMetricsReportConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_DpMetricsReportConfig.DiscardUnknown(m)
}

var xxx_messageInfo_DpMetricsReportConfig proto.InternalMessageInfo

func (m *DpMetricsReportConfig) GetEnableReport() bool {
	if m != nil {
		return m.EnableReport
	}
	return false
}

func (m *DpMetricsReportConfig) GetReportIntervalSec() int64 {
	if m != nil {
		return m.ReportIntervalSec
	}
	return 0
}

func (m *DpMetricsReportConfig) GetFetchIntervalSec() int64 {
	if m != nil {
		return m.FetchIntervalSec
	}
	return 0
}

type DpFollowerReadDelayConfig struct {
	EnableCollect        bool  `protobuf:"varint,1,opt,name=EnableCollect,proto3" json:"EnableCollect,omitempty"`
	DelaySummaryInterval int64 `protobuf:"varint,2,opt,name=DelaySummaryInterval,proto3" json:"DelaySummaryInterval,omitempty"`
}

func (m *DpFollowerReadDelayConfig) Reset()         { *m = DpFollowerReadDelayConfig{} }
func (m *DpFollowerReadDelayConfig) String() string { return proto.CompactTextString(m) }
func (*DpFollowerReadDelayConfig) ProtoMessage()    {}
func (*DpFollowerReadDelayConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_73a7fc70dcc2027c, []int{12}
}
func (m *DpFollowerReadDelayConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DpFollowerReadDelayConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DpFollowerReadDelayConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DpFollowerReadDelayConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DpFollowerReadDelayConfig.Merge(m, src)
}
func (m *DpFollowerReadDelayConfig) XXX_Size() int {
	return m.Size()
}
func (m *DpFollowerReadDelayConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_DpFollowerReadDelayConfig.DiscardUnknown(m)
}

var xxx_messageInfo_DpFollowerReadDelayConfig proto.InternalMessageInfo

func (m *DpFollowerReadDelayConfig) GetEnableCollect() bool {
	if m != nil {
		return m.EnableCollect
	}
	return false
}

func (m *DpFollowerReadDelayConfig) GetDelaySummaryInterval() int64 {
	if m != nil {
		return m.DelaySummaryInterval
	}
	return 0
}

type MetaPartitionLayout struct {
	PercentOfMP      uint32 `protobuf:"varint,1,opt,name=PercentOfMP,proto3" json:"percent_of_mp"`
	PercentOfReplica uint32 `protobuf:"varint,2,opt,name=PercentOfReplica,proto3" json:"percent_of_replica"`
}

func (m *MetaPartitionLayout) Reset()         { *m = MetaPartitionLayout{} }
func (m *MetaPartitionLayout) String() string { return proto.CompactTextString(m) }
func (*MetaPartitionLayout) ProtoMessage()    {}
func (*MetaPartitionLayout) Descriptor() ([]byte, []int) {
	return fileDescriptor_73a7fc70dcc2027c, []int{13}
}
func (m *MetaPartitionLayout) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetaPartitionLayout) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetaPartitionLayout.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetaPartitionLayout) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetaPartitionLayout.Merge(m, src)
}
func (m *MetaPartitionLayout) XXX_Size() int {
	return m.Size()
}
func (m *MetaPartitionLayout) XXX_DiscardUnknown() {
	xxx_messageInfo_MetaPartitionLayout.DiscardUnknown(m)
}

var xxx_messageInfo_MetaPartitionLayout proto.InternalMessageInfo

func (m *MetaPartitionLayout) GetPercentOfMP() uint32 {
	if m != nil {
		return m.PercentOfMP
	}
	return 0
}

func (m *MetaPartitionLayout) GetPercentOfReplica() uint32 {
	if m != nil {
		return m.PercentOfReplica
	}
	return 0
}

type SimpleVolViewPb struct {
	ID                     uint64                    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Name                   string                    `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	Owner                  string                    `protobuf:"bytes,3,opt,name=Owner,proto3" json:"Owner,omitempty"`
	ZoneName               string                    `protobuf:"bytes,4,opt,name=ZoneName,proto3" json:"ZoneName,omitempty"`
	DpReplicaNum           uint32                    `protobuf:"varint,5,opt,name=DpReplicaNum,proto3" json:"DpReplicaNum,omitempty"`
	MpReplicaNum           uint32                    `protobuf:"varint,6,opt,name=MpReplicaNum,proto3" json:"MpReplicaNum,omitempty"`
	DpLearnerNum           uint32                    `protobuf:"varint,7,opt,name=DpLearnerNum,proto3" json:"DpLearnerNum,omitempty"`
	MpLearnerNum           uint32                    `protobuf:"varint,8,opt,name=MpLearnerNum,proto3" json:"MpLearnerNum,omitempty"`
	InodeCount             uint64                    `protobuf:"varint,9,opt,name=InodeCount,proto3" json:"InodeCount,omitempty"`
	DentryCount            uint64                    `protobuf:"varint,10,opt,name=DentryCount,proto3" json:"DentryCount,omitempty"`
	MaxMetaPartitionID     uint64                    `protobuf:"varint,11,opt,name=MaxMetaPartitionID,proto3" json:"MaxMetaPartitionID,omitempty"`
	Status                 uint32                    `protobuf:"varint,12,opt,name=Status,proto3" json:"Status,omitempty"`
	Capacity               uint64                    `protobuf:"varint,13,opt,name=Capacity,proto3" json:"Capacity,omitempty"`
	DpWriteableThreshold   float64                   `protobuf:"fixed64,14,opt,name=DpWriteableThreshold,proto3" json:"DpWriteableThreshold,omitempty"`
	RwDpCnt                int64                     `protobuf:"varint,15,opt,name=RwDpCnt,proto3" json:"RwDpCnt,omitempty"`
	MpCnt                  int64                     `protobuf:"varint,16,opt,name=MpCnt,proto3" json:"MpCnt,omitempty"`
	DpCnt                  int64                     `protobuf:"varint,17,opt,name=DpCnt,proto3" json:"DpCnt,omitempty"`
	FollowerRead           bool                      `protobuf:"varint,18,opt,name=FollowerRead,proto3" json:"FollowerRead,omitempty"`
	NearRead               bool                      `protobuf:"varint,19,opt,name=NearRead,proto3" json:"NearRead,omitempty"`
	NeedToLowerReplica     bool                      `protobuf:"varint,20,opt,name=NeedToLowerReplica,proto3" json:"NeedToLowerReplica,omitempty"`
	Authenticate           bool                      `protobuf:"varint,21,opt,name=Authenticate,proto3" json:"Authenticate,omitempty"`
	VolWriteMutexEnable    bool                      `protobuf:"varint,22,opt,name=VolWriteMutexEnable,proto3" json:"VolWriteMutexEnable,omitempty"`
	CrossZone              bool                      `protobuf:"varint,23,opt,name=CrossZone,proto3" json:"CrossZone,omitempty"`
	AutoRepair             bool                      `protobuf:"varint,24,opt,name=AutoRepair,proto3" json:"AutoRepair,omitempty"`
	CreateTime             string                    `protobuf:"bytes,25,opt,name=CreateTime,proto3" json:"CreateTime,omitempty"`
	EnableToken            bool                      `protobuf:"varint,26,opt,name=EnableToken,proto3" json:"EnableToken,omitempty"`
	ForceROW               bool                      `protobuf:"varint,27,opt,name=ForceROW,proto3" json:"ForceROW,omitempty"`
	EnableWriteCache       bool                      `protobuf:"varint,28,opt,name=EnableWriteCache,proto3" json:"EnableWriteCache,omitempty"`
	CrossRegionHAType      uint32                    `protobuf:"varint,29,opt,name=CrossRegionHAType,proto3" json:"CrossRegionHAType,omitempty"`
	Tokens                 map[string]*TokenPb       `protobuf:"bytes,30,rep,name=Tokens,proto3" json:"Tokens,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Description            string                    `protobuf:"bytes,31,opt,name=Description,proto3" json:"Description,omitempty"`
	DpSelectorName         string                    `protobuf:"bytes,32,opt,name=DpSelectorName,proto3" json:"DpSelectorName,omitempty"`
	DpSelectorParm         string                    `protobuf:"bytes,33,opt,name=DpSelectorParm,proto3" json:"DpSelectorParm,omitempty"`
	Quorum                 int64                     `protobuf:"varint,34,opt,name=Quorum,proto3" json:"Quorum,omitempty"`
	OSSBucketPolicy        uint32                    `protobuf:"varint,35,opt,name=OSSBucketPolicy,proto3" json:"OSSBucketPolicy,omitempty"`
	DPConvertMode          uint32                    `protobuf:"varint,36,opt,name=DPConvertMode,proto3" json:"DPConvertMode,omitempty"`
	MPConvertMode          uint32                    `protobuf:"varint,37,opt,name=MPConvertMode,proto3" json:"MPConvertMode,omitempty"`
	MasterRegionZone       string                    `protobuf:"bytes,38,opt,name=MasterRegionZone,proto3" json:"MasterRegionZone,omitempty"`
	SlaveRegionZone        string                    `protobuf:"bytes,39,opt,name=SlaveRegionZone,proto3" json:"SlaveRegionZone,omitempty"`
	ConnConfig             *ConnConfig               `protobuf:"bytes,40,opt,name=ConnConfig,proto3" json:"ConnConfig,omitempty"`
	ExtentCacheExpireSec   int64                     `protobuf:"varint,41,opt,name=ExtentCacheExpireSec,proto3" json:"ExtentCacheExpireSec,omitempty"`
	DpMetricsReportConfig  *DpMetricsReportConfig    `protobuf:"bytes,42,opt,name=DpMetricsReportConfig,proto3" json:"DpMetricsReportConfig,omitempty"`
	DpFolReadDelayConfig   DpFollowerReadDelayConfig `protobuf:"bytes,43,opt,name=DpFolReadDelayConfig,proto3" json:"DpFolReadDelayConfig"`
	FolReadHostWeight      int64                     `protobuf:"varint,44,opt,name=FolReadHostWeight,proto3" json:"FolReadHostWeight,omitempty"`
	RwMpCnt                int64                     `protobuf:"varint,45,opt,name=RwMpCnt,proto3" json:"RwMpCnt,omitempty"`
	MinWritableMPNum       int64                     `protobuf:"varint,46,opt,name=MinWritableMPNum,proto3" json:"MinWritableMPNum,omitempty"`
	MinWritableDPNum       int64                     `protobuf:"varint,47,opt,name=MinWritableDPNum,proto3" json:"MinWritableDPNum,omitempty"`
	TrashRemainingDays     uint32                    `protobuf:"varint,48,opt,name=TrashRemainingDays,proto3" json:"TrashRemainingDays,omitempty"`
	DefaultStoreMode       uint32                    `protobuf:"varint,49,opt,name=DefaultStoreMode,proto3" json:"DefaultStoreMode,omitempty"`
	ConvertState           uint32                    `protobuf:"varint,50,opt,name=ConvertState,proto3" json:"ConvertState,omitempty"`
	MpLayout               MetaPartitionLayout       `protobuf:"bytes,51,opt,name=MpLayout,proto3" json:"MpLayout"`
	TotalSizeGB            string                    `protobuf:"bytes,52,opt,name=TotalSizeGB,proto3" json:"TotalGB"`
	UsedSizeGB             string                    `protobuf:"bytes,53,opt,name=UsedSizeGB,proto3" json:"UsedGB"`
	TotalSize              uint64                    `protobuf:"varint,54,opt,name=TotalSize,proto3" json:"TotalSize,omitempty"`
	UsedSize               uint64                    `protobuf:"varint,55,opt,name=UsedSize,proto3" json:"UsedSize,omitempty"`
	UsedRatio              float64                   `protobuf:"fixed64,56,opt,name=UsedRatio,proto3" json:"UsedRatio,omitempty"`
	FileAvgSize            float64                   `protobuf:"fixed64,57,opt,name=FileAvgSize,proto3" json:"FileAvgSize,omitempty"`
	CreateStatus           uint32                    `protobuf:"varint,58,opt,name=CreateStatus,proto3" json:"CreateStatus,omitempty"`
	IsSmart                bool                      `protobuf:"varint,59,opt,name=IsSmart,proto3" json:"IsSmart,omitempty"`
	SmartEnableTime        string                    `protobuf:"bytes,60,opt,name=SmartEnableTime,proto3" json:"SmartEnableTime,omitempty"`
	SmartRules             []string                  `protobuf:"bytes,61,rep,name=SmartRules,proto3" json:"SmartRules,omitempty"`
	CompactTag             string                    `protobuf:"bytes,62,opt,name=CompactTag,proto3" json:"CompactTag,omitempty"`
	CompactTagModifyTime   int64                     `protobuf:"varint,63,opt,name=CompactTagModifyTime,proto3" json:"CompactTagModifyTime,omitempty"`
	EcEnable               bool                      `protobuf:"varint,64,opt,name=EcEnable,proto3" json:"EcEnable,omitempty"`
	EcDataNum              uint32                    `protobuf:"varint,65,opt,name=EcDataNum,proto3" json:"EcDataNum,omitempty"`
	EcParityNum            uint32                    `protobuf:"varint,66,opt,name=EcParityNum,proto3" json:"EcParityNum,omitempty"`
	EcWaitTime             int64                     `protobuf:"varint,67,opt,name=EcWaitTime,proto3" json:"EcWaitTime,omitempty"`
	EcSaveTime             int64                     `protobuf:"varint,68,opt,name=EcSaveTime,proto3" json:"EcSaveTime,omitempty"`
	EcTimeOut              int64                     `protobuf:"varint,69,opt,name=EcTimeOut,proto3" json:"EcTimeOut,omitempty"`
	EcRetryWait            int64                     `protobuf:"varint,70,opt,name=EcRetryWait,proto3" json:"EcRetryWait,omitempty"`
	EcMaxUnitSize          uint64                    `protobuf:"varint,71,opt,name=EcMaxUnitSize,proto3" json:"EcMaxUnitSize,omitempty"`
	ChildFileMaxCount      uint32                    `protobuf:"varint,72,opt,name=ChildFileMaxCount,proto3" json:"ChildFileMaxCount,omitempty"`
	TrashCleanInterval     uint64                    `protobuf:"varint,73,opt,name=TrashCleanInterval,proto3" json:"TrashCleanInterval,omitempty"`
	BatchDelInodeCnt       uint32                    `protobuf:"varint,74,opt,name=BatchDelInodeCnt,proto3" json:"BatchDelInodeCnt,omitempty"`
	DelInodeInterval       uint32                    `protobuf:"varint,75,opt,name=DelInodeInterval,proto3" json:"DelInodeInterval,omitempty"`
	UmpCollectWay          int64                     `protobuf:"varint,76,opt,name=UmpCollectWay,proto3" json:"UmpCollectWay,omitempty"`
	EnableBitMapAllocator  bool                      `protobuf:"varint,77,opt,name=EnableBitMapAllocator,proto3" json:"EnableBitMapAllocator,omitempty"`
	TrashCleanDuration     int32                     `protobuf:"varint,78,opt,name=TrashCleanDuration,proto3" json:"TrashCleanDuration,omitempty"`
	TrashCleanMaxCount     int32                     `protobuf:"varint,79,opt,name=TrashCleanMaxCount,proto3" json:"TrashCleanMaxCount,omitempty"`
	NewVolName             string                    `protobuf:"bytes,80,opt,name=NewVolName,proto3" json:"NewVolName,omitempty"`
	NewVolID               uint64                    `protobuf:"varint,81,opt,name=NewVolID,proto3" json:"NewVolID,omitempty"`
	OldVolName             string                    `protobuf:"bytes,82,opt,name=OldVolName,proto3" json:"OldVolName,omitempty"`
	FinalVolStatus         uint32                    `protobuf:"varint,83,opt,name=FinalVolStatus,proto3" json:"FinalVolStatus,omitempty"`
	RenameConvertStatus    uint32                    `protobuf:"varint,84,opt,name=RenameConvertStatus,proto3" json:"RenameConvertStatus,omitempty"`
	MarkDeleteTime         int64                     `protobuf:"varint,85,opt,name=MarkDeleteTime,proto3" json:"MarkDeleteTime,omitempty"`
	RemoteCacheBoostEnable bool                      `protobuf:"varint,86,opt,name=RemoteCacheBoostEnable,proto3" json:"RemoteCacheBoostEnable,omitempty"`
	RemoteCacheBoostPath   string                    `protobuf:"bytes,87,opt,name=RemoteCacheBoostPath,proto3" json:"RemoteCacheBoostPath,omitempty"`
	RemoteCacheAutoPrepare bool                      `protobuf:"varint,88,opt,name=RemoteCacheAutoPrepare,proto3" json:"RemoteCacheAutoPrepare,omitempty"`
	RemoteCacheTTL         int64                     `protobuf:"varint,89,opt,name=RemoteCacheTTL,proto3" json:"RemoteCacheTTL,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}                  `json:"-"`
	XXX_unrecognized       []byte                    `json:"-"`
	XXX_sizecache          int32                     `json:"-"`
}

func (m *SimpleVolViewPb) Reset()         { *m = SimpleVolViewPb{} }
func (m *SimpleVolViewPb) String() string { return proto.CompactTextString(m) }
func (*SimpleVolViewPb) ProtoMessage()    {}
func (*SimpleVolViewPb) Descriptor() ([]byte, []int) {
	return fileDescriptor_73a7fc70dcc2027c, []int{14}
}
func (m *SimpleVolViewPb) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SimpleVolViewPb) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SimpleVolViewPb.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SimpleVolViewPb) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SimpleVolViewPb.Merge(m, src)
}
func (m *SimpleVolViewPb) XXX_Size() int {
	return m.Size()
}
func (m *SimpleVolViewPb) XXX_DiscardUnknown() {
	xxx_messageInfo_SimpleVolViewPb.DiscardUnknown(m)
}

var xxx_messageInfo_SimpleVolViewPb proto.InternalMessageInfo

func (m *SimpleVolViewPb) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *SimpleVolViewPb) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SimpleVolViewPb) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *SimpleVolViewPb) GetZoneName() string {
	if m != nil {
		return m.ZoneName
	}
	return ""
}

func (m *SimpleVolViewPb) GetDpReplicaNum() uint32 {
	if m != nil {
		return m.DpReplicaNum
	}
	return 0
}

func (m *SimpleVolViewPb) GetMpReplicaNum() uint32 {
	if m != nil {
		return m.MpReplicaNum
	}
	return 0
}

func (m *SimpleVolViewPb) GetDpLearnerNum() uint32 {
	if m != nil {
		return m.DpLearnerNum
	}
	return 0
}

func (m *SimpleVolViewPb) GetMpLearnerNum() uint32 {
	if m != nil {
		return m.MpLearnerNum
	}
	return 0
}

func (m *SimpleVolViewPb) GetInodeCount() uint64 {
	if m != nil {
		return m.InodeCount
	}
	return 0
}

func (m *SimpleVolViewPb) GetDentryCount() uint64 {
	if m != nil {
		return m.DentryCount
	}
	return 0
}

func (m *SimpleVolViewPb) GetMaxMetaPartitionID() uint64 {
	if m != nil {
		return m.MaxMetaPartitionID
	}
	return 0
}

func (m *SimpleVolViewPb) GetStatus() uint32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *SimpleVolViewPb) GetCapacity() uint64 {
	if m != nil {
		return m.Capacity
	}
	return 0
}

func (m *SimpleVolViewPb) GetDpWriteableThreshold() float64 {
	if m != nil {
		return m.DpWriteableThreshold
	}
	return 0
}

func (m *SimpleVolViewPb) GetRwDpCnt() int64 {
	if m != nil {
		return m.RwDpCnt
	}
	return 0
}

func (m *SimpleVolViewPb) GetMpCnt() int64 {
	if m != nil {
		return m.MpCnt
	}
	return 0
}

func (m *SimpleVolViewPb) GetDpCnt() int64 {
	if m != nil {
		return m.DpCnt
	}
	return 0
}

func (m *SimpleVolViewPb) GetFollowerRead() bool {
	if m != nil {
		return m.FollowerRead
	}
	return false
}

func (m *SimpleVolViewPb) GetNearRead() bool {
	if m != nil {
		return m.NearRead
	}
	return false
}

func (m *SimpleVolViewPb) GetNeedToLowerReplica() bool {
	if m != nil {
		return m.NeedToLowerReplica
	}
	return false
}

func (m *SimpleVolViewPb) GetAuthenticate() bool {
	if m != nil {
		return m.Authenticate
	}
	return false
}

func (m *SimpleVolViewPb) GetVolWriteMutexEnable() bool {
	if m != nil {
		return m.VolWriteMutexEnable
	}
	return false
}

func (m *SimpleVolViewPb) GetCrossZone() bool {
	if m != nil {
		return m.CrossZone
	}
	return false
}

func (m *SimpleVolViewPb) GetAutoRepair() bool {
	if m != nil {
		return m.AutoRepair
	}
	return false
}

func (m *SimpleVolViewPb) GetCreateTime() string {
	if m != nil {
		return m.CreateTime
	}
	return ""
}

func (m *SimpleVolViewPb) GetEnableToken() bool {
	if m != nil {
		return m.EnableToken
	}
	return false
}

func (m *SimpleVolViewPb) GetForceROW() bool {
	if m != nil {
		return m.ForceROW
	}
	return false
}

func (m *SimpleVolViewPb) GetEnableWriteCache() bool {
	if m != nil {
		return m.EnableWriteCache
	}
	return false
}

func (m *SimpleVolViewPb) GetCrossRegionHAType() uint32 {
	if m != nil {
		return m.CrossRegionHAType
	}
	return 0
}

func (m *SimpleVolViewPb) GetTokens() map[string]*TokenPb {
	if m != nil {
		return m.Tokens
	}
	return nil
}

func (m *SimpleVolViewPb) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *SimpleVolViewPb) GetDpSelectorName() string {
	if m != nil {
		return m.DpSelectorName
	}
	return ""
}

func (m *SimpleVolViewPb) GetDpSelectorParm() string {
	if m != nil {
		return m.DpSelectorParm
	}
	return ""
}

func (m *SimpleVolViewPb) GetQuorum() int64 {
	if m != nil {
		return m.Quorum
	}
	return 0
}

func (m *SimpleVolViewPb) GetOSSBucketPolicy() uint32 {
	if m != nil {
		return m.OSSBucketPolicy
	}
	return 0
}

func (m *SimpleVolViewPb) GetDPConvertMode() uint32 {
	if m != nil {
		return m.DPConvertMode
	}
	return 0
}

func (m *SimpleVolViewPb) GetMPConvertMode() uint32 {
	if m != nil {
		return m.MPConvertMode
	}
	return 0
}

func (m *SimpleVolViewPb) GetMasterRegionZone() string {
	if m != nil {
		return m.MasterRegionZone
	}
	return ""
}

func (m *SimpleVolViewPb) GetSlaveRegionZone() string {
	if m != nil {
		return m.SlaveRegionZone
	}
	return ""
}

func (m *SimpleVolViewPb) GetConnConfig() *ConnConfig {
	if m != nil {
		return m.ConnConfig
	}
	return nil
}

func (m *SimpleVolViewPb) GetExtentCacheExpireSec() int64 {
	if m != nil {
		return m.ExtentCacheExpireSec
	}
	return 0
}

func (m *SimpleVolViewPb) GetDpMetricsReportConfig() *DpMetricsReportConfig {
	if m != nil {
		return m.DpMetricsReportConfig
	}
	return nil
}

func (m *SimpleVolViewPb) GetDpFolReadDelayConfig() DpFollowerReadDelayConfig {
	if m != nil {
		return m.DpFolReadDelayConfig
	}
	return DpFollowerReadDelayConfig{}
}

func (m *SimpleVolViewPb) GetFolReadHostWeight() int64 {
	if m != nil {
		return m.FolReadHostWeight
	}
	return 0
}

func (m *SimpleVolViewPb) GetRwMpCnt() int64 {
	if m != nil {
		return m.RwMpCnt
	}
	return 0
}

func (m *SimpleVolViewPb) GetMinWritableMPNum() int64 {
	if m != nil {
		return m.MinWritableMPNum
	}
	return 0
}

func (m *SimpleVolViewPb) GetMinWritableDPNum() int64 {
	if m != nil {
		return m.MinWritableDPNum
	}
	return 0
}

func (m *SimpleVolViewPb) GetTrashRemainingDays() uint32 {
	if m != nil {
		return m.TrashRemainingDays
	}
	return 0
}

func (m *SimpleVolViewPb) GetDefaultStoreMode() uint32 {
	if m != nil {
		return m.DefaultStoreMode
	}
	return 0
}

func (m *SimpleVolViewPb) GetConvertState() uint32 {
	if m != nil {
		return m.ConvertState
	}
	return 0
}

func (m *SimpleVolViewPb) GetMpLayout() MetaPartitionLayout {
	if m != nil {
		return m.MpLayout
	}
	return MetaPartitionLayout{}
}

func (m *SimpleVolViewPb) GetTotalSizeGB() string {
	if m != nil {
		return m.TotalSizeGB
	}
	return ""
}

func (m *SimpleVolViewPb) GetUsedSizeGB() string {
	if m != nil {
		return m.UsedSizeGB
	}
	return ""
}

func (m *SimpleVolViewPb) GetTotalSize() uint64 {
	if m != nil {
		return m.TotalSize
	}
	return 0
}

func (m *SimpleVolViewPb) GetUsedSize() uint64 {
	if m != nil {
		return m.UsedSize
	}
	return 0
}

func (m *SimpleVolViewPb) GetUsedRatio() float64 {
	if m != nil {
		return m.UsedRatio
	}
	return 0
}

func (m *SimpleVolViewPb) GetFileAvgSize() float64 {
	if m != nil {
		return m.FileAvgSize
	}
	return 0
}

func (m *SimpleVolViewPb) GetCreateStatus() uint32 {
	if m != nil {
		return m.CreateStatus
	}
	return 0
}

func (m *SimpleVolViewPb) GetIsSmart() bool {
	if m != nil {
		return m.IsSmart
	}
	return false
}

func (m *SimpleVolViewPb) GetSmartEnableTime() string {
	if m != nil {
		return m.SmartEnableTime
	}
	return ""
}

func (m *SimpleVolViewPb) GetSmartRules() []string {
	if m != nil {
		return m.SmartRules
	}
	return nil
}

func (m *SimpleVolViewPb) GetCompactTag() string {
	if m != nil {
		return m.CompactTag
	}
	return ""
}

func (m *SimpleVolViewPb) GetCompactTagModifyTime() int64 {
	if m != nil {
		return m.CompactTagModifyTime
	}
	return 0
}

func (m *SimpleVolViewPb) GetEcEnable() bool {
	if m != nil {
		return m.EcEnable
	}
	return false
}

func (m *SimpleVolViewPb) GetEcDataNum() uint32 {
	if m != nil {
		return m.EcDataNum
	}
	return 0
}

func (m *SimpleVolViewPb) GetEcParityNum() uint32 {
	if m != nil {
		return m.EcParityNum
	}
	return 0
}

func (m *SimpleVolViewPb) GetEcWaitTime() int64 {
	if m != nil {
		return m.EcWaitTime
	}
	return 0
}

func (m *SimpleVolViewPb) GetEcSaveTime() int64 {
	if m != nil {
		return m.EcSaveTime
	}
	return 0
}

func (m *SimpleVolViewPb) GetEcTimeOut() int64 {
	if m != nil {
		return m.EcTimeOut
	}
	return 0
}

func (m *SimpleVolViewPb) GetEcRetryWait() int64 {
	if m != nil {
		return m.EcRetryWait
	}
	return 0
}

func (m *SimpleVolViewPb) GetEcMaxUnitSize() uint64 {
	if m != nil {
		return m.EcMaxUnitSize
	}
	return 0
}

func (m *SimpleVolViewPb) GetChildFileMaxCount() uint32 {
	if m != nil {
		return m.ChildFileMaxCount
	}
	return 0
}

func (m *SimpleVolViewPb) GetTrashCleanInterval() uint64 {
	if m != nil {
		return m.TrashCleanInterval
	}
	return 0
}

func (m *SimpleVolViewPb) GetBatchDelInodeCnt() uint32 {
	if m != nil {
		return m.BatchDelInodeCnt
	}
	return 0
}

func (m *SimpleVolViewPb) GetDelInodeInterval() uint32 {
	if m != nil {
		return m.DelInodeInterval
	}
	return 0
}

func (m *SimpleVolViewPb) GetUmpCollectWay() int64 {
	if m != nil {
		return m.UmpCollectWay
	}
	return 0
}

func (m *SimpleVolViewPb) GetEnableBitMapAllocator() bool {
	if m != nil {
		return m.EnableBitMapAllocator
	}
	return false
}

func (m *SimpleVolViewPb) GetTrashCleanDuration() int32 {
	if m != nil {
		return m.TrashCleanDuration
	}
	return 0
}

func (m *SimpleVolViewPb) GetTrashCleanMaxCount() int32 {
	if m != nil {
		return m.TrashCleanMaxCount
	}
	return 0
}

func (m *SimpleVolViewPb) GetNewVolName() string {
	if m != nil {
		return m.NewVolName
	}
	return ""
}

func (m *SimpleVolViewPb) GetNewVolID() uint64 {
	if m != nil {
		return m.NewVolID
	}
	return 0
}

func (m *SimpleVolViewPb) GetOldVolName() string {
	if m != nil {
		return m.OldVolName
	}
	return ""
}

func (m *SimpleVolViewPb) GetFinalVolStatus() uint32 {
	if m != nil {
		return m.FinalVolStatus
	}
	return 0
}

func (m *SimpleVolViewPb) GetRenameConvertStatus() uint32 {
	if m != nil {
		return m.RenameConvertStatus
	}
	return 0
}

func (m *SimpleVolViewPb) GetMarkDeleteTime() int64 {
	if m != nil {
		return m.MarkDeleteTime
	}
	return 0
}

func (m *SimpleVolViewPb) GetRemoteCacheBoostEnable() bool {
	if m != nil {
		return m.RemoteCacheBoostEnable
	}
	return false
}

func (m *SimpleVolViewPb) GetRemoteCacheBoostPath() string {
	if m != nil {
		return m.RemoteCacheBoostPath
	}
	return ""
}

func (m *SimpleVolViewPb) GetRemoteCacheAutoPrepare() bool {
	if m != nil {
		return m.RemoteCacheAutoPrepare
	}
	return false
}

func (m *SimpleVolViewPb) GetRemoteCacheTTL() int64 {
	if m != nil {
		return m.RemoteCacheTTL
	}
	return 0
}

type NodeStatInfoPb struct {
	TotalGB              uint64   `protobuf:"varint,1,opt,name=TotalGB,proto3" json:"TotalGB,omitempty"`
	UsedGB               uint64   `protobuf:"varint,2,opt,name=UsedGB,proto3" json:"UsedGB,omitempty"`
	IncreasedGB          int64    `protobuf:"varint,3,opt,name=IncreasedGB,proto3" json:"IncreasedGB,omitempty"`
	UsedRatio            string   `protobuf:"bytes,4,opt,name=UsedRatio,proto3" json:"UsedRatio,omitempty"`
	TotalNodes           int64    `protobuf:"varint,5,opt,name=TotalNodes,proto3" json:"TotalNodes,omitempty"`
	WritableNodes        int64    `protobuf:"varint,6,opt,name=WritableNodes,proto3" json:"WritableNodes,omitempty"`
	HighUsedRatioNodes   int64    `protobuf:"varint,7,opt,name=HighUsedRatioNodes,proto3" json:"HighUsedRatioNodes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodeStatInfoPb) Reset()         { *m = NodeStatInfoPb{} }
func (m *NodeStatInfoPb) String() string { return proto.CompactTextString(m) }
func (*NodeStatInfoPb) ProtoMessage()    {}
func (*NodeStatInfoPb) Descriptor() ([]byte, []int) {
	return fileDescriptor_73a7fc70dcc2027c, []int{15}
}
func (m *NodeStatInfoPb) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeStatInfoPb) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeStatInfoPb.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeStatInfoPb) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeStatInfoPb.Merge(m, src)
}
func (m *NodeStatInfoPb) XXX_Size() int {
	return m.Size()
}
func (m *NodeStatInfoPb) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeStatInfoPb.DiscardUnknown(m)
}

var xxx_messageInfo_NodeStatInfoPb proto.InternalMessageInfo

func (m *NodeStatInfoPb) GetTotalGB() uint64 {
	if m != nil {
		return m.TotalGB
	}
	return 0
}

func (m *NodeStatInfoPb) GetUsedGB() uint64 {
	if m != nil {
		return m.UsedGB
	}
	return 0
}

func (m *NodeStatInfoPb) GetIncreasedGB() int64 {
	if m != nil {
		return m.IncreasedGB
	}
	return 0
}

func (m *NodeStatInfoPb) GetUsedRatio() string {
	if m != nil {
		return m.UsedRatio
	}
	return ""
}

func (m *NodeStatInfoPb) GetTotalNodes() int64 {
	if m != nil {
		return m.TotalNodes
	}
	return 0
}

func (m *NodeStatInfoPb) GetWritableNodes() int64 {
	if m != nil {
		return m.WritableNodes
	}
	return 0
}

func (m *NodeStatInfoPb) GetHighUsedRatioNodes() int64 {
	if m != nil {
		return m.HighUsedRatioNodes
	}
	return 0
}

type BadPartitionView struct {
	Path        string `protobuf:"bytes,1,opt,name=Path,proto3" json:"Path,omitempty"`
	PartitionID uint64 `protobuf:"varint,2,opt,name=PartitionID,proto3" json:"PartitionID,omitempty"`
}

func (m *BadPartitionView) Reset()         { *m = BadPartitionView{} }
func (m *BadPartitionView) String() string { return proto.CompactTextString(m) }
func (*BadPartitionView) ProtoMessage()    {}
func (*BadPartitionView) Descriptor() ([]byte, []int) {
	return fileDescriptor_73a7fc70dcc2027c, []int{16}
}
func (m *BadPartitionView) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BadPartitionView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BadPartitionView.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BadPartitionView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BadPartitionView.Merge(m, src)
}
func (m *BadPartitionView) XXX_Size() int {
	return m.Size()
}
func (m *BadPartitionView) XXX_DiscardUnknown() {
	xxx_messageInfo_BadPartitionView.DiscardUnknown(m)
}

var xxx_messageInfo_BadPartitionView proto.InternalMessageInfo

func (m *BadPartitionView) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *BadPartitionView) GetPartitionID() uint64 {
	if m != nil {
		return m.PartitionID
	}
	return 0
}

// NodeView provides the view of the data or meta node.
type NodeView struct {
	Addr       string `protobuf:"bytes,1,opt,name=Addr,proto3" json:"Addr,omitempty"`
	Status     bool   `protobuf:"varint,2,opt,name=Status,proto3" json:"Status,omitempty"`
	ID         uint64 `protobuf:"varint,3,opt,name=ID,proto3" json:"ID,omitempty"`
	IsWritable bool   `protobuf:"varint,4,opt,name=IsWritable,proto3" json:"IsWritable,omitempty"`
	Version    string `protobuf:"bytes,5,opt,name=Version,proto3" json:"Version,omitempty"`
}

func (m *NodeView) Reset()         { *m = NodeView{} }
func (m *NodeView) String() string { return proto.CompactTextString(m) }
func (*NodeView) ProtoMessage()    {}
func (*NodeView) Descriptor() ([]byte, []int) {
	return fileDescriptor_73a7fc70dcc2027c, []int{17}
}
func (m *NodeView) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeView.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeView.Merge(m, src)
}
func (m *NodeView) XXX_Size() int {
	return m.Size()
}
func (m *NodeView) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeView.DiscardUnknown(m)
}

var xxx_messageInfo_NodeView proto.InternalMessageInfo

func (m *NodeView) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *NodeView) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

func (m *NodeView) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *NodeView) GetIsWritable() bool {
	if m != nil {
		return m.IsWritable
	}
	return false
}

func (m *NodeView) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

type DataNodeBadDisksView struct {
	Addr        string   `protobuf:"bytes,1,opt,name=Addr,proto3" json:"Addr,omitempty"`
	BadDiskPath []string `protobuf:"bytes,2,rep,name=BadDiskPath,proto3" json:"BadDiskPath,omitempty"`
}

func (m *DataNodeBadDisksView) Reset()         { *m = DataNodeBadDisksView{} }
func (m *DataNodeBadDisksView) String() string { return proto.CompactTextString(m) }
func (*DataNodeBadDisksView) ProtoMessage()    {}
func (*DataNodeBadDisksView) Descriptor() ([]byte, []int) {
	return fileDescriptor_73a7fc70dcc2027c, []int{18}
}
func (m *DataNodeBadDisksView) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataNodeBadDisksView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataNodeBadDisksView.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataNodeBadDisksView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataNodeBadDisksView.Merge(m, src)
}
func (m *DataNodeBadDisksView) XXX_Size() int {
	return m.Size()
}
func (m *DataNodeBadDisksView) XXX_DiscardUnknown() {
	xxx_messageInfo_DataNodeBadDisksView.DiscardUnknown(m)
}

var xxx_messageInfo_DataNodeBadDisksView proto.InternalMessageInfo

func (m *DataNodeBadDisksView) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *DataNodeBadDisksView) GetBadDiskPath() []string {
	if m != nil {
		return m.BadDiskPath
	}
	return nil
}

type ClusterViewPb struct {
	Name                                string                 `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	LeaderAddr                          string                 `protobuf:"bytes,2,opt,name=LeaderAddr,proto3" json:"LeaderAddr,omitempty"`
	DisableAutoAlloc                    bool                   `protobuf:"varint,3,opt,name=DisableAutoAlloc,proto3" json:"DisableAutoAlloc,omitempty"`
	AutoMergeNodeSet                    bool                   `protobuf:"varint,4,opt,name=AutoMergeNodeSet,proto3" json:"AutoMergeNodeSet,omitempty"`
	NodeSetCapacity                     int64                  `protobuf:"varint,5,opt,name=NodeSetCapacity,proto3" json:"NodeSetCapacity,omitempty"`
	MetaNodeThreshold                   float32                `protobuf:"fixed32,6,opt,name=MetaNodeThreshold,proto3" json:"MetaNodeThreshold,omitempty"`
	DpRecoverPool                       int32                  `protobuf:"varint,7,opt,name=DpRecoverPool,proto3" json:"DpRecoverPool,omitempty"`
	MpRecoverPool                       int32                  `protobuf:"varint,8,opt,name=MpRecoverPool,proto3" json:"MpRecoverPool,omitempty"`
	DeleteMarkDelVolInterval            int64                  `protobuf:"varint,9,opt,name=DeleteMarkDelVolInterval,proto3" json:"DeleteMarkDelVolInterval,omitempty"`
	Applied                             uint64                 `protobuf:"varint,10,opt,name=Applied,proto3" json:"Applied,omitempty"`
	MaxDataPartitionID                  uint64                 `protobuf:"varint,11,opt,name=MaxDataPartitionID,proto3" json:"MaxDataPartitionID,omitempty"`
	MaxMetaNodeID                       uint64                 `protobuf:"varint,12,opt,name=MaxMetaNodeID,proto3" json:"MaxMetaNodeID,omitempty"`
	MaxMetaPartitionID                  uint64                 `protobuf:"varint,13,opt,name=MaxMetaPartitionID,proto3" json:"MaxMetaPartitionID,omitempty"`
	EcScrubEnable                       bool                   `protobuf:"varint,14,opt,name=EcScrubEnable,proto3" json:"EcScrubEnable,omitempty"`
	EcMaxScrubExtents                   uint32                 `protobuf:"varint,15,opt,name=EcMaxScrubExtents,proto3" json:"EcMaxScrubExtents,omitempty"`
	EcScrubPeriod                       uint32                 `protobuf:"varint,16,opt,name=EcScrubPeriod,proto3" json:"EcScrubPeriod,omitempty"`
	EcScrubStartTime                    int64                  `protobuf:"varint,17,opt,name=EcScrubStartTime,proto3" json:"EcScrubStartTime,omitempty"`
	MaxCodecConcurrent                  int64                  `protobuf:"varint,18,opt,name=MaxCodecConcurrent,proto3" json:"MaxCodecConcurrent,omitempty"`
	VolCount                            int64                  `protobuf:"varint,19,opt,name=VolCount,proto3" json:"VolCount,omitempty"`
	DataNodeStatInfo                    *NodeStatInfoPb        `protobuf:"bytes,20,opt,name=DataNodeStatInfo,proto3" json:"DataNodeStatInfo,omitempty"`
	MetaNodeStatInfo                    *NodeStatInfoPb        `protobuf:"bytes,21,opt,name=MetaNodeStatInfo,proto3" json:"MetaNodeStatInfo,omitempty"`
	EcNodeStatInfo                      *NodeStatInfoPb        `protobuf:"bytes,22,opt,name=EcNodeStatInfo,proto3" json:"EcNodeStatInfo,omitempty"`
	BadPartitionIDs                     []BadPartitionView     `protobuf:"bytes,23,rep,name=BadPartitionIDs,proto3" json:"BadPartitionIDs"`
	BadMetaPartitionIDs                 []BadPartitionView     `protobuf:"bytes,24,rep,name=BadMetaPartitionIDs,proto3" json:"BadMetaPartitionIDs"`
	BadEcPartitionIDs                   []BadPartitionView     `protobuf:"bytes,25,rep,name=BadEcPartitionIDs,proto3" json:"BadEcPartitionIDs"`
	MigratedDataPartitions              []BadPartitionView     `protobuf:"bytes,26,rep,name=MigratedDataPartitions,proto3" json:"MigratedDataPartitions"`
	MigratedMetaPartitions              []BadPartitionView     `protobuf:"bytes,27,rep,name=MigratedMetaPartitions,proto3" json:"MigratedMetaPartitions"`
	MetaNodes                           []NodeView             `protobuf:"bytes,28,rep,name=MetaNodes,proto3" json:"MetaNodes"`
	DataNodes                           []NodeView             `protobuf:"bytes,29,rep,name=DataNodes,proto3" json:"DataNodes"`
	CodEcnodes                          []NodeView             `protobuf:"bytes,30,rep,name=CodEcnodes,proto3" json:"CodEcnodes"`
	EcNodes                             []NodeView             `protobuf:"bytes,31,rep,name=EcNodes,proto3" json:"EcNodes"`
	DataNodeBadDisks                    []DataNodeBadDisksView `protobuf:"bytes,32,rep,name=DataNodeBadDisks,proto3" json:"DataNodeBadDisks"`
	SchedulerDomain                     string                 `protobuf:"bytes,33,opt,name=SchedulerDomain,proto3" json:"SchedulerDomain,omitempty"`
	ClientPkgAddr                       string                 `protobuf:"bytes,34,opt,name=ClientPkgAddr,proto3" json:"ClientPkgAddr,omitempty"`
	UmpJmtpAddr                         string                 `protobuf:"bytes,35,opt,name=UmpJmtpAddr,proto3" json:"UmpJmtpAddr,omitempty"`
	UmpJmtpBatch                        uint64                 `protobuf:"varint,36,opt,name=UmpJmtpBatch,proto3" json:"UmpJmtpBatch,omitempty"`
	MetaNodeRocksdbDiskThreshold        float32                `protobuf:"fixed32,37,opt,name=MetaNodeRocksdbDiskThreshold,proto3" json:"MetaNodeRocksdbDiskThreshold,omitempty"`
	MetaNodeMemModeRocksdbDiskThreshold float32                `protobuf:"fixed32,38,opt,name=MetaNodeMemModeRocksdbDiskThreshold,proto3" json:"MetaNodeMemModeRocksdbDiskThreshold,omitempty"`
	RocksDBDiskReservedSpace            uint64                 `protobuf:"varint,39,opt,name=RocksDBDiskReservedSpace,proto3" json:"RocksDBDiskReservedSpace,omitempty"`
	LogMaxMB                            uint64                 `protobuf:"varint,40,opt,name=LogMaxMB,proto3" json:"LogMaxMB,omitempty"`
	MetaRockDBWalFileSize               uint64                 `protobuf:"varint,41,opt,name=MetaRockDBWalFileSize,proto3" json:"MetaRockDBWalFileSize,omitempty"`
	MetaRocksWalMemSize                 uint64                 `protobuf:"varint,42,opt,name=MetaRocksWalMemSize,proto3" json:"MetaRocksWalMemSize,omitempty"`
	MetaRocksLogSize                    uint64                 `protobuf:"varint,43,opt,name=MetaRocksLogSize,proto3" json:"MetaRocksLogSize,omitempty"`
	MetaRocksLogReservedTime            uint64                 `protobuf:"varint,44,opt,name=MetaRocksLogReservedTime,proto3" json:"MetaRocksLogReservedTime,omitempty"`
	MetaRocksLogReservedCnt             uint64                 `protobuf:"varint,45,opt,name=MetaRocksLogReservedCnt,proto3" json:"MetaRocksLogReservedCnt,omitempty"`
	MetaRocksFlushWalInterval           uint64                 `protobuf:"varint,46,opt,name=MetaRocksFlushWalInterval,proto3" json:"MetaRocksFlushWalInterval,omitempty"`
	MetaRocksDisableFlushFlag           uint64                 `protobuf:"varint,47,opt,name=MetaRocksDisableFlushFlag,proto3" json:"MetaRocksDisableFlushFlag,omitempty"`
	MetaRocksWalTTL                     uint64                 `protobuf:"varint,48,opt,name=MetaRocksWalTTL,proto3" json:"MetaRocksWalTTL,omitempty"`
	MetaDelEKRecordFileMaxMB            uint64                 `protobuf:"varint,49,opt,name=MetaDelEKRecordFileMaxMB,proto3" json:"MetaDelEKRecordFileMaxMB,omitempty"`
	MetaTrashCleanInterval              uint64                 `protobuf:"varint,50,opt,name=MetaTrashCleanInterval,proto3" json:"MetaTrashCleanInterval,omitempty"`
	MetaRaftLogSize                     int64                  `protobuf:"varint,51,opt,name=MetaRaftLogSize,proto3" json:"MetaRaftLogSize,omitempty"`
	MetaRaftLogCap                      int64                  `protobuf:"varint,52,opt,name=MetaRaftLogCap,proto3" json:"MetaRaftLogCap,omitempty"`
	BitMapAllocatorMaxUsedFactor        float64                `protobuf:"fixed64,53,opt,name=BitMapAllocatorMaxUsedFactor,proto3" json:"BitMapAllocatorMaxUsedFactor,omitempty"`
	BitMapAllocatorMinFreeFactor        float64                `protobuf:"fixed64,54,opt,name=BitMapAllocatorMinFreeFactor,proto3" json:"BitMapAllocatorMinFreeFactor,omitempty"`
	DisableStrictVolZone                bool                   `protobuf:"varint,55,opt,name=DisableStrictVolZone,proto3" json:"DisableStrictVolZone,omitempty"`
	AutoUpdatePartitionReplicaNum       bool                   `protobuf:"varint,56,opt,name=AutoUpdatePartitionReplicaNum,proto3" json:"AutoUpdatePartitionReplicaNum,omitempty"`
	FlashNodes                          []NodeView             `protobuf:"bytes,57,rep,name=FlashNodes,proto3" json:"FlashNodes"`
	XXX_NoUnkeyedLiteral                struct{}               `json:"-"`
	XXX_unrecognized                    []byte                 `json:"-"`
	XXX_sizecache                       int32                  `json:"-"`
}

func (m *ClusterViewPb) Reset()         { *m = ClusterViewPb{} }
func (m *ClusterViewPb) String() string { return proto.CompactTextString(m) }
func (*ClusterViewPb) ProtoMessage()    {}
func (*ClusterViewPb) Descriptor() ([]byte, []int) {
	return fileDescriptor_73a7fc70dcc2027c, []int{19}
}
func (m *ClusterViewPb) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterViewPb) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterViewPb.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterViewPb) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterViewPb.Merge(m, src)
}
func (m *ClusterViewPb) XXX_Size() int {
	return m.Size()
}
func (m *ClusterViewPb) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterViewPb.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterViewPb proto.InternalMessageInfo

func (m *ClusterViewPb) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ClusterViewPb) GetLeaderAddr() string {
	if m != nil {
		return m.LeaderAddr
	}
	return ""
}

func (m *ClusterViewPb) GetDisableAutoAlloc() bool {
	if m != nil {
		return m.DisableAutoAlloc
	}
	return false
}

func (m *ClusterViewPb) GetAutoMergeNodeSet() bool {
	if m != nil {
		return m.AutoMergeNodeSet
	}
	return false
}

func (m *ClusterViewPb) GetNodeSetCapacity() int64 {
	if m != nil {
		return m.NodeSetCapacity
	}
	return 0
}

func (m *ClusterViewPb) GetMetaNodeThreshold() float32 {
	if m != nil {
		return m.MetaNodeThreshold
	}
	return 0
}

func (m *ClusterViewPb) GetDpRecoverPool() int32 {
	if m != nil {
		return m.DpRecoverPool
	}
	return 0
}

func (m *ClusterViewPb) GetMpRecoverPool() int32 {
	if m != nil {
		return m.MpRecoverPool
	}
	return 0
}

func (m *ClusterViewPb) GetDeleteMarkDelVolInterval() int64 {
	if m != nil {
		return m.DeleteMarkDelVolInterval
	}
	return 0
}

func (m *ClusterViewPb) GetApplied() uint64 {
	if m != nil {
		return m.Applied
	}
	return 0
}

func (m *ClusterViewPb) GetMaxDataPartitionID() uint64 {
	if m != nil {
		return m.MaxDataPartitionID
	}
	return 0
}

func (m *ClusterViewPb) GetMaxMetaNodeID() uint64 {
	if m != nil {
		return m.MaxMetaNodeID
	}
	return 0
}

func (m *ClusterViewPb) GetMaxMetaPartitionID() uint64 {
	if m != nil {
		return m.MaxMetaPartitionID
	}
	return 0
}

func (m *ClusterViewPb) GetEcScrubEnable() bool {
	if m != nil {
		return m.EcScrubEnable
	}
	return false
}

func (m *ClusterViewPb) GetEcMaxScrubExtents() uint32 {
	if m != nil {
		return m.EcMaxScrubExtents
	}
	return 0
}

func (m *ClusterViewPb) GetEcScrubPeriod() uint32 {
	if m != nil {
		return m.EcScrubPeriod
	}
	return 0
}

func (m *ClusterViewPb) GetEcScrubStartTime() int64 {
	if m != nil {
		return m.EcScrubStartTime
	}
	return 0
}

func (m *ClusterViewPb) GetMaxCodecConcurrent() int64 {
	if m != nil {
		return m.MaxCodecConcurrent
	}
	return 0
}

func (m *ClusterViewPb) GetVolCount() int64 {
	if m != nil {
		return m.VolCount
	}
	return 0
}

func (m *ClusterViewPb) GetDataNodeStatInfo() *NodeStatInfoPb {
	if m != nil {
		return m.DataNodeStatInfo
	}
	return nil
}

func (m *ClusterViewPb) GetMetaNodeStatInfo() *NodeStatInfoPb {
	if m != nil {
		return m.MetaNodeStatInfo
	}
	return nil
}

func (m *ClusterViewPb) GetEcNodeStatInfo() *NodeStatInfoPb {
	if m != nil {
		return m.EcNodeStatInfo
	}
	return nil
}

func (m *ClusterViewPb) GetBadPartitionIDs() []BadPartitionView {
	if m != nil {
		return m.BadPartitionIDs
	}
	return nil
}

func (m *ClusterViewPb) GetBadMetaPartitionIDs() []BadPartitionView {
	if m != nil {
		return m.BadMetaPartitionIDs
	}
	return nil
}

func (m *ClusterViewPb) GetBadEcPartitionIDs() []BadPartitionView {
	if m != nil {
		return m.BadEcPartitionIDs
	}
	return nil
}

func (m *ClusterViewPb) GetMigratedDataPartitions() []BadPartitionView {
	if m != nil {
		return m.MigratedDataPartitions
	}
	return nil
}

func (m *ClusterViewPb) GetMigratedMetaPartitions() []BadPartitionView {
	if m != nil {
		return m.MigratedMetaPartitions
	}
	return nil
}

func (m *ClusterViewPb) GetMetaNodes() []NodeView {
	if m != nil {
		return m.MetaNodes
	}
	return nil
}

func (m *ClusterViewPb) GetDataNodes() []NodeView {
	if m != nil {
		return m.DataNodes
	}
	return nil
}

func (m *ClusterViewPb) GetCodEcnodes() []NodeView {
	if m != nil {
		return m.CodEcnodes
	}
	return nil
}

func (m *ClusterViewPb) GetEcNodes() []NodeView {
	if m != nil {
		return m.EcNodes
	}
	return nil
}

func (m *ClusterViewPb) GetDataNodeBadDisks() []DataNodeBadDisksView {
	if m != nil {
		return m.DataNodeBadDisks
	}
	return nil
}

func (m *ClusterViewPb) GetSchedulerDomain() string {
	if m != nil {
		return m.SchedulerDomain
	}
	return ""
}

func (m *ClusterViewPb) GetClientPkgAddr() string {
	if m != nil {
		return m.ClientPkgAddr
	}
	return ""
}

func (m *ClusterViewPb) GetUmpJmtpAddr() string {
	if m != nil {
		return m.UmpJmtpAddr
	}
	return ""
}

func (m *ClusterViewPb) GetUmpJmtpBatch() uint64 {
	if m != nil {
		return m.UmpJmtpBatch
	}
	return 0
}

func (m *ClusterViewPb) GetMetaNodeRocksdbDiskThreshold() float32 {
	if m != nil {
		return m.MetaNodeRocksdbDiskThreshold
	}
	return 0
}

func (m *ClusterViewPb) GetMetaNodeMemModeRocksdbDiskThreshold() float32 {
	if m != nil {
		return m.MetaNodeMemModeRocksdbDiskThreshold
	}
	return 0
}

func (m *ClusterViewPb) GetRocksDBDiskReservedSpace() uint64 {
	if m != nil {
		return m.RocksDBDiskReservedSpace
	}
	return 0
}

func (m *ClusterViewPb) GetLogMaxMB() uint64 {
	if m != nil {
		return m.LogMaxMB
	}
	return 0
}

func (m *ClusterViewPb) GetMetaRockDBWalFileSize() uint64 {
	if m != nil {
		return m.MetaRockDBWalFileSize
	}
	return 0
}

func (m *ClusterViewPb) GetMetaRocksWalMemSize() uint64 {
	if m != nil {
		return m.MetaRocksWalMemSize
	}
	return 0
}

func (m *ClusterViewPb) GetMetaRocksLogSize() uint64 {
	if m != nil {
		return m.MetaRocksLogSize
	}
	return 0
}

func (m *ClusterViewPb) GetMetaRocksLogReservedTime() uint64 {
	if m != nil {
		return m.MetaRocksLogReservedTime
	}
	return 0
}

func (m *ClusterViewPb) GetMetaRocksLogReservedCnt() uint64 {
	if m != nil {
		return m.MetaRocksLogReservedCnt
	}
	return 0
}

func (m *ClusterViewPb) GetMetaRocksFlushWalInterval() uint64 {
	if m != nil {
		return m.MetaRocksFlushWalInterval
	}
	return 0
}

func (m *ClusterViewPb) GetMetaRocksDisableFlushFlag() uint64 {
	if m != nil {
		return m.MetaRocksDisableFlushFlag
	}
	return 0
}

func (m *ClusterViewPb) GetMetaRocksWalTTL() uint64 {
	if m != nil {
		return m.MetaRocksWalTTL
	}
	return 0
}

func (m *ClusterViewPb) GetMetaDelEKRecordFileMaxMB() uint64 {
	if m != nil {
		return m.MetaDelEKRecordFileMaxMB
	}
	return 0
}

func (m *ClusterViewPb) GetMetaTrashCleanInterval() uint64 {
	if m != nil {
		return m.MetaTrashCleanInterval
	}
	return 0
}

func (m *ClusterViewPb) GetMetaRaftLogSize() int64 {
	if m != nil {
		return m.MetaRaftLogSize
	}
	return 0
}

func (m *ClusterViewPb) GetMetaRaftLogCap() int64 {
	if m != nil {
		return m.MetaRaftLogCap
	}
	return 0
}

func (m *ClusterViewPb) GetBitMapAllocatorMaxUsedFactor() float64 {
	if m != nil {
		return m.BitMapAllocatorMaxUsedFactor
	}
	return 0
}

func (m *ClusterViewPb) GetBitMapAllocatorMinFreeFactor() float64 {
	if m != nil {
		return m.BitMapAllocatorMinFreeFactor
	}
	return 0
}

func (m *ClusterViewPb) GetDisableStrictVolZone() bool {
	if m != nil {
		return m.DisableStrictVolZone
	}
	return false
}

func (m *ClusterViewPb) GetAutoUpdatePartitionReplicaNum() bool {
	if m != nil {
		return m.AutoUpdatePartitionReplicaNum
	}
	return false
}

func (m *ClusterViewPb) GetFlashNodes() []NodeView {
	if m != nil {
		return m.FlashNodes
	}
	return nil
}

func init() {
	proto.RegisterType((*DataPartitionResponsePb)(nil), "proto.DataPartitionResponsePb")
	proto.RegisterType((*DataPartitionsViewPb)(nil), "proto.DataPartitionsViewPb")
	proto.RegisterType((*MetaPartitionViewPb)(nil), "proto.MetaPartitionViewPb")
	proto.RegisterType((*MetaPartitionViewsPb)(nil), "proto.MetaPartitionViewsPb")
	proto.RegisterType((*EcPartitionResponsePb)(nil), "proto.EcPartitionResponsePb")
	proto.RegisterType((*EcPartitionsViewPb)(nil), "proto.EcPartitionsViewPb")
	proto.RegisterType((*OSSSecure)(nil), "proto.OSSSecure")
	proto.RegisterType((*ConnConfig)(nil), "proto.ConnConfig")
	proto.RegisterType((*VolViewPb)(nil), "proto.VolViewPb")
	proto.RegisterType((*HTTPReplyPb)(nil), "proto.HTTPReplyPb")
	proto.RegisterType((*TokenPb)(nil), "proto.TokenPb")
	proto.RegisterType((*DpMetricsReportConfig)(nil), "proto.DpMetricsReportConfig")
	proto.RegisterType((*DpFollowerReadDelayConfig)(nil), "proto.DpFollowerReadDelayConfig")
	proto.RegisterType((*MetaPartitionLayout)(nil), "proto.MetaPartitionLayout")
	proto.RegisterType((*SimpleVolViewPb)(nil), "proto.SimpleVolViewPb")
	proto.RegisterMapType((map[string]*TokenPb)(nil), "proto.SimpleVolViewPb.TokensEntry")
	proto.RegisterType((*NodeStatInfoPb)(nil), "proto.NodeStatInfoPb")
	proto.RegisterType((*BadPartitionView)(nil), "proto.BadPartitionView")
	proto.RegisterType((*NodeView)(nil), "proto.NodeView")
	proto.RegisterType((*DataNodeBadDisksView)(nil), "proto.DataNodeBadDisksView")
	proto.RegisterType((*ClusterViewPb)(nil), "proto.ClusterViewPb")
}

func init() { proto.RegisterFile("admin.proto", fileDescriptor_73a7fc70dcc2027c) }

var fileDescriptor_73a7fc70dcc2027c = []byte{
	// 3510 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x5a, 0xbb, 0x73, 0x1b, 0x47,
	0x9a, 0x27, 0x08, 0x50, 0x04, 0x9b, 0x4f, 0x8d, 0x28, 0x69, 0x44, 0xc9, 0x24, 0x0f, 0x96, 0x7d,
	0xb4, 0x6c, 0x53, 0x36, 0xe5, 0x87, 0xac, 0xb3, 0xef, 0x4c, 0x3c, 0x28, 0xc1, 0x12, 0x48, 0xb8,
	0xc1, 0xc7, 0x9d, 0x82, 0x73, 0x35, 0x67, 0x9a, 0xc0, 0x94, 0x06, 0xd3, 0x53, 0x33, 0x03, 0x8a,
	0x74, 0x7a, 0xc1, 0x5d, 0x74, 0x75, 0xa1, 0x83, 0x0b, 0xbc, 0x4e, 0xf6, 0x8f, 0xd8, 0x64, 0xa3,
	0x2d, 0x6f, 0xe6, 0x78, 0x03, 0xd5, 0x96, 0x37, 0x53, 0xba, 0x1b, 0x6c, 0xb8, 0xf5, 0x7d, 0xdd,
	0x33, 0xe8, 0x19, 0x0c, 0x68, 0x69, 0xa3, 0x8d, 0x88, 0xfe, 0x7d, 0x5f, 0x7f, 0xfd, 0xfa, 0xde,
	0x43, 0x32, 0xcb, 0xec, 0xbe, 0xe3, 0x6d, 0xfa, 0x81, 0x88, 0x84, 0x31, 0x85, 0x7f, 0x56, 0xde,
	0xef, 0x3a, 0x51, 0x6f, 0x70, 0xbc, 0x69, 0x89, 0xfe, 0xdd, 0xae, 0xe8, 0x8a, 0xbb, 0x08, 0x1f,
	0x0f, 0x4e, 0x70, 0x84, 0x03, 0xfc, 0x25, 0x67, 0x55, 0xfe, 0xbb, 0x44, 0xae, 0xd7, 0x59, 0xc4,
	0xda, 0x2c, 0x88, 0x9c, 0xc8, 0x11, 0x1e, 0xe5, 0xa1, 0x2f, 0xbc, 0x90, 0xb7, 0x8f, 0x8d, 0x75,
	0x32, 0x9b, 0xc0, 0xcd, 0xba, 0x59, 0x58, 0x2f, 0x6c, 0x94, 0xa8, 0x0e, 0x19, 0xd7, 0xc8, 0xa5,
	0x4e, 0xc4, 0xa2, 0x41, 0x68, 0x4e, 0xae, 0x17, 0x36, 0xa6, 0xa8, 0x1a, 0x19, 0xab, 0x84, 0x50,
	0xee, 0xbb, 0x8e, 0xc5, 0x76, 0x07, 0x7d, 0xb3, 0xb8, 0x5e, 0xd8, 0x98, 0xa7, 0x1a, 0x62, 0x2c,
	0x93, 0xa9, 0x47, 0x22, 0x8c, 0x42, 0xb3, 0xb4, 0x5e, 0xdc, 0x98, 0xa1, 0x72, 0x60, 0x7c, 0x44,
	0xc8, 0x13, 0xce, 0x6c, 0x1e, 0x6c, 0xdb, 0x76, 0x60, 0x4e, 0xad, 0x17, 0x36, 0xe6, 0xaa, 0xcb,
	0x3f, 0xbe, 0x58, 0x9b, 0xf8, 0xc3, 0x8b, 0xb5, 0xb9, 0xed, 0x48, 0xf4, 0x1d, 0xab, 0x13, 0x05,
	0x8e, 0xd7, 0xa5, 0x1a, 0x1f, 0xc8, 0x6a, 0xf8, 0xc2, 0xea, 0x99, 0x97, 0x70, 0x7f, 0x72, 0x60,
	0xdc, 0x22, 0x33, 0xcd, 0x90, 0x72, 0x4b, 0x9c, 0xf2, 0xc0, 0x9c, 0x5e, 0x2f, 0x6c, 0x94, 0xe9,
	0x10, 0x30, 0x56, 0x48, 0xb9, 0x19, 0xee, 0x04, 0xe2, 0x5b, 0xee, 0x99, 0x65, 0x24, 0x26, 0x63,
	0xd8, 0x7b, 0x2d, 0xe0, 0x2c, 0xe2, 0xfb, 0x4e, 0x9f, 0x9b, 0x33, 0xeb, 0x85, 0x8d, 0x22, 0xd5,
	0x10, 0xa0, 0xb7, 0xb8, 0xed, 0x0c, 0xfa, 0xfb, 0xe7, 0x3e, 0x37, 0xc9, 0x7a, 0x61, 0x63, 0x86,
	0x6a, 0x08, 0xec, 0x67, 0x5f, 0x44, 0xcc, 0x35, 0x67, 0xe5, 0x7e, 0x70, 0x60, 0x18, 0xa4, 0x74,
	0x10, 0x72, 0xdb, 0x9c, 0x43, 0x10, 0x7f, 0x1b, 0x1b, 0x64, 0xb1, 0x61, 0xb5, 0x9c, 0x6e, 0xc0,
	0x22, 0xae, 0xae, 0x71, 0x1e, 0xaf, 0x2a, 0x0b, 0x1b, 0x26, 0x99, 0x6e, 0x58, 0xf2, 0xc6, 0x16,
	0xf0, 0xc6, 0xe2, 0x21, 0x9c, 0xb3, 0x61, 0xc1, 0x03, 0xc2, 0x45, 0x2f, 0xe2, 0xec, 0x21, 0x60,
	0xdc, 0x26, 0xf3, 0x0d, 0xab, 0xc5, 0xce, 0x0e, 0x3c, 0x27, 0xea, 0x38, 0xdf, 0x72, 0x73, 0x09,
	0x97, 0x4f, 0x83, 0x0f, 0x4a, 0xff, 0xf3, 0xfd, 0xda, 0x44, 0xe5, 0x3f, 0xc9, 0x72, 0x4a, 0x11,
	0xc2, 0x43, 0x87, 0x3f, 0x6f, 0x1f, 0x1b, 0x3b, 0x64, 0x21, 0x8d, 0x9b, 0x85, 0xf5, 0xe2, 0xc6,
	0xec, 0xd6, 0xaa, 0xd4, 0xa0, 0xcd, 0x31, 0xda, 0x43, 0x33, 0xb3, 0x2a, 0xbf, 0x2f, 0x92, 0x2b,
	0x2d, 0xae, 0x41, 0x4a, 0xfe, 0x2f, 0x6b, 0xd9, 0x32, 0x99, 0xea, 0x44, 0x2c, 0x88, 0x50, 0xc9,
	0x4a, 0x54, 0x0e, 0x8c, 0x25, 0x52, 0x6c, 0x78, 0x36, 0x2a, 0x57, 0x89, 0xc2, 0x4f, 0x7c, 0x19,
	0x76, 0xd6, 0xf4, 0x84, 0xcd, 0x9b, 0x75, 0xb3, 0x84, 0x04, 0x0d, 0x01, 0x3a, 0xfe, 0xac, 0x89,
	0x81, 0x17, 0xa1, 0x7e, 0x95, 0xa8, 0x86, 0xc0, 0x4e, 0xea, 0xdc, 0x8b, 0x82, 0x73, 0xc9, 0x20,
	0xf5, 0x49, 0x87, 0x80, 0xa3, 0xc5, 0xce, 0x1a, 0x67, 0x4e, 0x18, 0x35, 0x3d, 0x81, 0x7a, 0x55,
	0xa2, 0x3a, 0x94, 0xd6, 0xbb, 0x72, 0x56, 0xef, 0x4c, 0x32, 0xdd, 0xe2, 0xfd, 0x63, 0x1e, 0x84,
	0xe6, 0x8c, 0x7c, 0x47, 0x35, 0x04, 0x8d, 0x7c, 0xc2, 0x59, 0xe0, 0x01, 0x89, 0x20, 0x29, 0x19,
	0xc3, 0xbe, 0x35, 0xbb, 0x98, 0x95, 0x1a, 0xa7, 0x59, 0xc0, 0xd0, 0x0a, 0xe7, 0x52, 0x56, 0x78,
	0x8b, 0xcc, 0x74, 0x22, 0x11, 0xf0, 0x96, 0xb0, 0xb9, 0xd2, 0xac, 0x21, 0x00, 0x2b, 0xb6, 0x78,
	0x5f, 0x1e, 0x75, 0x01, 0x89, 0xc9, 0x18, 0xed, 0x57, 0x58, 0xcf, 0x42, 0x49, 0x5d, 0x54, 0xf6,
	0x9b, 0x20, 0x95, 0xa7, 0x64, 0x79, 0xe4, 0x29, 0xc3, 0xf6, 0xb1, 0x51, 0x25, 0x0b, 0x29, 0x3c,
	0xd6, 0x95, 0x15, 0xa5, 0x2b, 0x39, 0xef, 0x4f, 0x33, 0x33, 0x2a, 0x7f, 0x2e, 0x90, 0xab, 0x0d,
	0xeb, 0x1f, 0xc1, 0x1f, 0xad, 0x8e, 0xf8, 0xa3, 0xf4, 0xbd, 0x57, 0xc8, 0x1c, 0xe8, 0x38, 0xd8,
	0x51, 0x08, 0x72, 0x2f, 0xa1, 0xdc, 0x14, 0x66, 0xbc, 0x4d, 0x16, 0xda, 0x2c, 0x70, 0xa2, 0xf3,
	0x84, 0x6b, 0x1a, 0xb9, 0x32, 0x68, 0xe5, 0x90, 0x18, 0xda, 0xa1, 0x63, 0xdb, 0xfb, 0x92, 0xcc,
	0xe9, 0xa8, 0xba, 0xcd, 0x5b, 0xea, 0x36, 0x73, 0x6f, 0x89, 0xa6, 0x66, 0x54, 0x0e, 0xc8, 0xcc,
	0x5e, 0xa7, 0xd3, 0xe1, 0xd6, 0x20, 0xe0, 0xa0, 0x10, 0xdb, 0x96, 0xc5, 0xc3, 0xf0, 0x31, 0x3f,
	0xc7, 0xeb, 0x9b, 0xa1, 0x43, 0x00, 0xd5, 0x85, 0x5b, 0x01, 0x8f, 0x80, 0x3a, 0x29, 0xa9, 0x09,
	0xf0, 0x60, 0xee, 0xa7, 0x5f, 0xad, 0x4d, 0xfc, 0xdf, 0x0f, 0x6b, 0x13, 0xdf, 0xfd, 0xb0, 0x36,
	0x51, 0xf9, 0x6d, 0x81, 0x90, 0x9a, 0xf0, 0xbc, 0x9a, 0xf0, 0x4e, 0x9c, 0x2e, 0x9c, 0xb2, 0x69,
	0xbb, 0xe8, 0x1f, 0xc5, 0x20, 0xea, 0x70, 0x0b, 0xa5, 0x17, 0x69, 0x06, 0x35, 0xee, 0x90, 0x25,
	0x98, 0xc5, 0xad, 0x48, 0x81, 0xbb, 0xf2, 0xa5, 0x8a, 0x74, 0x04, 0x07, 0x99, 0x47, 0x81, 0x13,
	0xf1, 0x21, 0x67, 0x51, 0xca, 0x4c, 0xa3, 0xe0, 0xe3, 0x28, 0x67, 0xf6, 0x90, 0xad, 0x84, 0x6c,
	0x69, 0xf0, 0xc1, 0xd2, 0x77, 0xdf, 0xaf, 0x4d, 0xa4, 0x8e, 0xf0, 0xbb, 0x29, 0x32, 0x73, 0x28,
	0x5c, 0x75, 0xd3, 0x06, 0x29, 0xed, 0xb2, 0x3e, 0x57, 0xb7, 0x82, 0xbf, 0x41, 0x2b, 0xf6, 0x9e,
	0x7b, 0x3c, 0x50, 0x97, 0x21, 0x07, 0x9a, 0x8e, 0x49, 0x3d, 0x8a, 0x75, 0xac, 0x42, 0xe6, 0x76,
	0x84, 0xeb, 0x8a, 0xe7, 0x3c, 0x80, 0xa5, 0x71, 0x1b, 0x65, 0x9a, 0xc2, 0xc0, 0xe6, 0x76, 0x44,
	0x60, 0x71, 0xba, 0x77, 0x84, 0xfa, 0x54, 0xa6, 0xc9, 0x18, 0xee, 0xa6, 0xe1, 0xb1, 0x63, 0x97,
	0xe3, 0xf9, 0x6a, 0xcc, 0xea, 0x71, 0xd4, 0xa8, 0x32, 0x1d, 0xc1, 0x8d, 0xf7, 0xc8, 0xe5, 0x5a,
	0x20, 0xc2, 0x90, 0xf2, 0xae, 0x23, 0xbc, 0x47, 0xdb, 0x18, 0x8a, 0xa4, 0x62, 0x8d, 0x12, 0x72,
	0xac, 0xb2, 0xfc, 0xba, 0x56, 0x99, 0x13, 0x05, 0x66, 0xfe, 0x9e, 0x28, 0x30, 0xa2, 0xd1, 0xe4,
	0x75, 0x35, 0xda, 0xd8, 0xd4, 0x34, 0x1a, 0x9d, 0xe1, 0xec, 0xd6, 0x92, 0x9a, 0x9e, 0xe0, 0x54,
	0x53, 0xfa, 0x0d, 0xb2, 0xb8, 0xd7, 0xe9, 0x54, 0x07, 0xd6, 0x33, 0x1e, 0xb5, 0x85, 0xeb, 0x58,
	0xe7, 0xe8, 0x26, 0xe7, 0x69, 0x16, 0xce, 0x44, 0xfe, 0xf9, 0x91, 0xc8, 0xff, 0xa1, 0xae, 0xf3,
	0xe8, 0x33, 0x67, 0xb7, 0x2e, 0xab, 0xa5, 0x87, 0x04, 0xaa, 0x1b, 0x86, 0x49, 0xa6, 0x9b, 0x61,
	0xa7, 0x0f, 0xc1, 0x6b, 0x11, 0xdf, 0x32, 0x1e, 0xc2, 0xb6, 0xf0, 0x87, 0x7c, 0x5b, 0x5c, 0x71,
	0x09, 0x57, 0xcc, 0xc2, 0xb0, 0x2d, 0x84, 0xe8, 0xc0, 0xe5, 0xa1, 0x79, 0x19, 0x3d, 0x94, 0x86,
	0x54, 0x1e, 0x92, 0xd9, 0x47, 0xfb, 0xfb, 0x6d, 0x70, 0x67, 0xe7, 0x52, 0x93, 0x2d, 0x70, 0xf8,
	0x05, 0xf4, 0x80, 0xf8, 0x1b, 0x62, 0x65, 0x3f, 0xec, 0x2a, 0x3d, 0x86, 0x9f, 0xc0, 0x65, 0xb3,
	0x88, 0xa1, 0x0e, 0xcf, 0x51, 0xfc, 0x5d, 0x39, 0x22, 0xd3, 0xfb, 0xe2, 0x19, 0xf7, 0xda, 0xc7,
	0xe0, 0x0b, 0xf0, 0x27, 0x2a, 0x96, 0x94, 0x34, 0x04, 0xc0, 0x30, 0x0e, 0x99, 0x3b, 0xe0, 0xb1,
	0x61, 0xe0, 0x00, 0xce, 0x7a, 0x28, 0x5c, 0xb4, 0xa2, 0x22, 0xe2, 0xf1, 0xb0, 0xf2, 0xeb, 0x02,
	0xb9, 0x5a, 0xf7, 0x5b, 0x3c, 0x0a, 0x1c, 0x2b, 0xa4, 0xdc, 0x17, 0x41, 0xa4, 0xee, 0xa7, 0x42,
	0xe6, 0xe4, 0x49, 0x25, 0x8a, 0x4b, 0x95, 0x69, 0x0a, 0x03, 0x65, 0x97, 0xbf, 0x9a, 0x5e, 0xc4,
	0x83, 0x53, 0xe6, 0x82, 0x7f, 0x91, 0x5e, 0x63, 0x94, 0x00, 0x66, 0xb4, 0xc3, 0x23, 0xab, 0xa7,
	0x33, 0x4b, 0xc7, 0x31, 0x82, 0xe7, 0x38, 0x85, 0xff, 0x2a, 0x90, 0x1b, 0x75, 0x5f, 0xb7, 0xd9,
	0x3a, 0x77, 0xd9, 0xb9, 0xda, 0x2d, 0xa4, 0x53, 0xb8, 0xb3, 0x9a, 0x70, 0x5d, 0x6e, 0xc5, 0xdb,
	0x4d, 0x83, 0xc6, 0x16, 0x59, 0xc6, 0x49, 0x9d, 0x41, 0xbf, 0xcf, 0x82, 0xf3, 0x78, 0x41, 0xb5,
	0xe5, 0x5c, 0x5a, 0xc6, 0xbb, 0xfe, 0x7f, 0x21, 0x93, 0x2a, 0x3d, 0x61, 0xe7, 0x62, 0x10, 0x19,
	0xf7, 0xc8, 0x6c, 0x9b, 0x07, 0x16, 0xf7, 0xa2, 0xbd, 0x93, 0x56, 0x1b, 0x57, 0x9f, 0xaf, 0x5e,
	0x7e, 0xf9, 0x62, 0x6d, 0xde, 0x97, 0xf0, 0x37, 0xe2, 0xe4, 0x9b, 0xbe, 0x4f, 0x75, 0x2e, 0xa3,
	0x4a, 0x96, 0x92, 0xa1, 0x0a, 0x79, 0xb8, 0x95, 0xf9, 0xea, 0xb5, 0x97, 0x2f, 0xd6, 0x0c, 0x6d,
	0x66, 0x20, 0xa9, 0x74, 0x84, 0x3f, 0xb3, 0xbd, 0xbf, 0xdc, 0x24, 0x8b, 0x1d, 0xa7, 0xef, 0xbb,
	0x7c, 0xe8, 0x3f, 0x17, 0xc8, 0x64, 0x12, 0x92, 0x27, 0x9b, 0xf5, 0xc4, 0x9f, 0x4e, 0xe6, 0xf9,
	0xd3, 0xa2, 0xee, 0x4f, 0x57, 0x48, 0xf9, 0xa9, 0xf0, 0x38, 0x72, 0x97, 0x90, 0x90, 0x8c, 0x31,
	0xc2, 0xfa, 0x5a, 0xe4, 0x9e, 0x52, 0x11, 0x56, 0xc3, 0x80, 0xa7, 0xa5, 0xf3, 0xa8, 0x28, 0xdc,
	0xca, 0xf0, 0xd4, 0x7d, 0x95, 0x4f, 0x0d, 0x63, 0x70, 0x0a, 0x93, 0x72, 0x34, 0x9e, 0x72, 0x2c,
	0x47, 0xe3, 0x49, 0x67, 0x90, 0x33, 0xbf, 0x94, 0x41, 0x92, 0xd1, 0x0c, 0x72, 0x93, 0x18, 0x2d,
	0x76, 0x96, 0x7a, 0xdc, 0x66, 0x5d, 0x95, 0x0a, 0x39, 0x94, 0x4c, 0x6e, 0x37, 0x8c, 0x36, 0x2b,
	0xa4, 0x5c, 0x63, 0x3e, 0xb3, 0x9c, 0xe8, 0x1c, 0x3d, 0x55, 0x89, 0x26, 0x63, 0x54, 0x40, 0x1f,
	0xa3, 0x05, 0xfa, 0x90, 0x5e, 0xc0, 0xc3, 0x9e, 0x70, 0x6d, 0xf4, 0x58, 0x05, 0x9a, 0x4b, 0x03,
	0xe3, 0xa5, 0xcf, 0xeb, 0x7e, 0x4d, 0xa5, 0x7b, 0x45, 0x1a, 0x0f, 0xe1, 0xd5, 0x5a, 0x88, 0x4b,
	0xf7, 0x24, 0x07, 0x80, 0x4a, 0xee, 0xcb, 0x12, 0x95, 0xbc, 0xd9, 0x18, 0x68, 0xe4, 0xc7, 0xc0,
	0x5d, 0xce, 0x24, 0xfd, 0x8a, 0x8c, 0x81, 0xf1, 0x18, 0x6e, 0x67, 0x97, 0x73, 0x7b, 0x5f, 0x3c,
	0x91, 0xec, 0x52, 0x5b, 0x97, 0x91, 0x2b, 0x87, 0x02, 0xeb, 0x6d, 0x0f, 0xa2, 0x1e, 0xf7, 0x22,
	0xc7, 0x62, 0x11, 0x37, 0xaf, 0xca, 0xf5, 0x74, 0xcc, 0xf8, 0x80, 0x5c, 0x39, 0x14, 0x2e, 0x1e,
	0xb9, 0x35, 0x88, 0xf8, 0x99, 0x34, 0x56, 0xf3, 0x1a, 0xb2, 0xe6, 0x91, 0xc0, 0xf9, 0x61, 0x10,
	0x05, 0x35, 0x34, 0xaf, 0xcb, 0x1c, 0x3e, 0x01, 0x40, 0x07, 0xb6, 0x07, 0x91, 0xa0, 0xdc, 0x67,
	0x4e, 0x60, 0x9a, 0x48, 0xd6, 0x90, 0x4c, 0x14, 0xb9, 0x21, 0xb3, 0x46, 0x2d, 0x8a, 0xac, 0x93,
	0x59, 0xe5, 0xdc, 0xc1, 0x9f, 0x9a, 0x2b, 0x28, 0x40, 0x87, 0x52, 0x59, 0xc2, 0xcd, 0x57, 0xc8,
	0x12, 0x6e, 0xbd, 0x4e, 0x96, 0xf0, 0xc6, 0xb8, 0x2c, 0xe1, 0x01, 0xb9, 0x84, 0xcb, 0x87, 0xe6,
	0x2a, 0xc6, 0xe4, 0x8a, 0x8a, 0x6c, 0x19, 0x4b, 0xdf, 0x94, 0x4c, 0x0d, 0x50, 0x69, 0xaa, 0x66,
	0x48, 0xbd, 0x0f, 0xad, 0xc0, 0xf1, 0x41, 0x6d, 0xcd, 0x35, 0x3c, 0xb4, 0x0e, 0x41, 0x36, 0x57,
	0xf7, 0x3b, 0x1c, 0x1c, 0xa4, 0x08, 0xd0, 0xd6, 0xd7, 0x91, 0x29, 0x83, 0xa6, 0xf9, 0xda, 0x2c,
	0xe8, 0x9b, 0xff, 0x94, 0xe5, 0x03, 0x14, 0xec, 0xe2, 0xeb, 0x81, 0x08, 0x06, 0x7d, 0xb3, 0x82,
	0x0a, 0xa8, 0x46, 0x79, 0xd1, 0xfe, 0xcd, 0xfc, 0x68, 0x7f, 0x9b, 0xcc, 0xd7, 0xdb, 0x35, 0xe1,
	0x9d, 0xf2, 0x20, 0xc2, 0x0a, 0xe9, 0x36, 0xf2, 0xa5, 0x41, 0xe0, 0x6a, 0xa5, 0xb8, 0xde, 0x92,
	0x5c, 0x29, 0x10, 0x5e, 0xa5, 0xc5, 0xc2, 0x08, 0x14, 0x13, 0x6e, 0x14, 0x15, 0xe7, 0x6d, 0xdc,
	0xf7, 0x08, 0x8e, 0x81, 0xdf, 0x65, 0xa7, 0x5c, 0x63, 0xfd, 0x67, 0x64, 0xcd, 0xc2, 0x99, 0x7c,
	0x63, 0xe3, 0x55, 0xf2, 0x8d, 0x2d, 0xb2, 0xdc, 0x38, 0x8b, 0xb8, 0x17, 0xa1, 0x06, 0x34, 0xce,
	0x7c, 0x27, 0xe0, 0x10, 0x01, 0xdf, 0x91, 0xb1, 0x27, 0x8f, 0x66, 0xd0, 0x31, 0xc1, 0xd9, 0xbc,
	0x83, 0x2b, 0xc6, 0xb9, 0x59, 0x2e, 0x0f, 0x1d, 0x13, 0xd7, 0x9f, 0x82, 0x0b, 0xda, 0x11, 0x6e,
	0x26, 0x82, 0x9a, 0xef, 0xa2, 0xc8, 0xf5, 0x44, 0xe4, 0x98, 0x48, 0x5b, 0x2d, 0xfd, 0xf8, 0x62,
	0x6d, 0x82, 0xe6, 0xca, 0x00, 0xb5, 0x56, 0x28, 0x94, 0x69, 0x47, 0xdc, 0xe9, 0xf6, 0x22, 0xf3,
	0x3d, 0x99, 0x0f, 0x8c, 0x10, 0xa4, 0x63, 0x93, 0x0e, 0xec, 0xfd, 0xd8, 0xb1, 0x49, 0x17, 0x06,
	0x8f, 0xe6, 0x78, 0x60, 0x2f, 0x60, 0x37, 0xad, 0x36, 0x38, 0xfd, 0x4d, 0x99, 0x29, 0x64, 0xf1,
	0x0c, 0x6f, 0x1d, 0x79, 0xef, 0x8e, 0xf0, 0x22, 0x0e, 0x4e, 0x6c, 0x3f, 0x60, 0x61, 0x8f, 0xf2,
	0x3e, 0x73, 0x3c, 0xc7, 0xeb, 0xd6, 0xd9, 0x79, 0x68, 0x7e, 0x80, 0x7a, 0x93, 0x43, 0x01, 0xd9,
	0x75, 0x7e, 0xc2, 0x06, 0x6e, 0x34, 0xac, 0xd6, 0x3f, 0x44, 0xee, 0x11, 0x1c, 0x1c, 0x9e, 0xd2,
	0x3b, 0x88, 0x03, 0xdc, 0xdc, 0x92, 0x41, 0x4a, 0xc7, 0x8c, 0xcf, 0x49, 0xb9, 0xe5, 0xcb, 0x8c,
	0xc1, 0xbc, 0x87, 0xf7, 0x9d, 0x9b, 0xe8, 0x4b, 0x0e, 0x75, 0xd3, 0xc9, 0x0c, 0xe3, 0x7d, 0x32,
	0x8b, 0x1d, 0xab, 0x8e, 0xf3, 0x2d, 0x7f, 0x58, 0x35, 0x3f, 0x02, 0xd5, 0xac, 0xce, 0xbe, 0x7c,
	0xb1, 0x36, 0x8d, 0xf0, 0xc3, 0x2a, 0xd5, 0xe9, 0xc6, 0x1d, 0x42, 0x0e, 0x42, 0x6e, 0x2b, 0xee,
	0x8f, 0x91, 0x9b, 0xbc, 0x7c, 0xb1, 0x76, 0x09, 0xd0, 0x87, 0x55, 0xaa, 0x51, 0x65, 0x52, 0xa9,
	0xa6, 0x9a, 0x9f, 0x60, 0xd0, 0x1a, 0x02, 0xe0, 0xf5, 0x62, 0x5e, 0xf3, 0x53, 0x19, 0xd1, 0xe2,
	0x31, 0xcc, 0x84, 0xdf, 0x94, 0x45, 0x8e, 0x30, 0xef, 0x63, 0x18, 0x1b, 0x02, 0xe0, 0x7d, 0x76,
	0x1c, 0x97, 0x6f, 0x9f, 0x76, 0x71, 0xf2, 0x67, 0x48, 0xd7, 0x21, 0xbc, 0x36, 0xf4, 0xc0, 0x2a,
	0x96, 0x3e, 0x50, 0xd7, 0xa6, 0x61, 0x7a, 0xaa, 0xfe, 0x2f, 0xbf, 0x98, 0xaa, 0x7f, 0xae, 0x2c,
	0xf6, 0xc2, 0x54, 0xfd, 0x8b, 0x6c, 0xaa, 0x8e, 0xb1, 0x41, 0xf4, 0x7d, 0x66, 0x45, 0xfb, 0xac,
	0x6b, 0xfe, 0xab, 0x8a, 0x0d, 0x09, 0x02, 0xe6, 0x3b, 0x1c, 0xb5, 0x84, 0xed, 0x9c, 0x9c, 0xe3,
	0x72, 0xff, 0x26, 0xcd, 0x37, 0x8f, 0x06, 0xf7, 0xd6, 0xb0, 0x54, 0x50, 0xfb, 0x52, 0x46, 0x8b,
	0x78, 0x9c, 0xee, 0x0e, 0x6e, 0x67, 0xbb, 0x83, 0x10, 0x89, 0x2c, 0xd9, 0x87, 0x00, 0x7a, 0x15,
	0xe9, 0x3a, 0x04, 0xfb, 0x6d, 0x58, 0x47, 0xcc, 0xc1, 0xb2, 0xdc, 0xac, 0xc9, 0x8a, 0x68, 0x88,
	0x48, 0x7a, 0x87, 0x9d, 0xca, 0x4b, 0xa9, 0xc7, 0xf4, 0x18, 0x91, 0xeb, 0xc3, 0xaf, 0xbd, 0x41,
	0x64, 0x36, 0x90, 0x3c, 0x04, 0xe4, 0xfa, 0x94, 0x47, 0xc1, 0x39, 0x08, 0x34, 0x77, 0x90, 0xae,
	0x43, 0xa3, 0xfd, 0xcb, 0x87, 0x39, 0xfd, 0x4b, 0x8c, 0x73, 0x3d, 0xc7, 0xb5, 0xe1, 0xc5, 0x5b,
	0xec, 0x4c, 0xe6, 0x5e, 0x8f, 0x54, 0x9c, 0xcb, 0x12, 0x12, 0xf3, 0xac, 0xb9, 0x9c, 0x79, 0x49,
	0x72, 0xde, 0x94, 0x19, 0xd8, 0x28, 0x05, 0xcc, 0xb3, 0xca, 0x22, 0xab, 0x57, 0xe7, 0xae, 0xcc,
	0xf4, 0xbc, 0xc8, 0xfc, 0x4a, 0x9a, 0x67, 0x16, 0x97, 0xa6, 0x2c, 0x87, 0x89, 0xe4, 0xc7, 0xb1,
	0x29, 0xa7, 0x71, 0x38, 0xdb, 0x41, 0xdf, 0x57, 0x45, 0xc3, 0x11, 0x3b, 0x37, 0x9f, 0xc8, 0xbe,
	0x45, 0x0a, 0x34, 0x3e, 0x22, 0x57, 0xe5, 0x5b, 0x56, 0x9d, 0xa8, 0xc5, 0xfc, 0x6d, 0xd7, 0x15,
	0x16, 0x8b, 0x44, 0x60, 0xb6, 0xf0, 0xa9, 0xf3, 0x89, 0xe9, 0x33, 0xd6, 0x07, 0x01, 0xc3, 0xb0,
	0xbc, 0x8b, 0x75, 0x5c, 0x0e, 0x25, 0xcd, 0x9f, 0x5c, 0xe1, 0x5e, 0x96, 0x3f, 0xb9, 0xc3, 0x55,
	0x42, 0x76, 0xf9, 0xf3, 0xb8, 0xda, 0x6b, 0x4b, 0x3d, 0x1e, 0x22, 0x32, 0xc7, 0x83, 0x51, 0xb3,
	0x6e, 0x7e, 0x2d, 0x6d, 0x39, 0x1e, 0xc3, 0xdc, 0x3d, 0xd7, 0x8e, 0xe7, 0x52, 0x39, 0x77, 0x88,
	0x40, 0x06, 0xb0, 0xe3, 0x78, 0xcc, 0x3d, 0x14, 0xae, 0xb2, 0xd6, 0x8e, 0xec, 0x98, 0xa5, 0x51,
	0xc8, 0xeb, 0x28, 0xf7, 0x58, 0x9f, 0x6b, 0xce, 0x6f, 0x10, 0x9a, 0xfb, 0xc8, 0x9c, 0x47, 0x02,
	0xc9, 0x2d, 0x16, 0x3c, 0xab, 0x73, 0x97, 0xab, 0xec, 0xec, 0x40, 0x76, 0x94, 0xd2, 0xa8, 0xf1,
	0x09, 0xb9, 0x46, 0x79, 0x5f, 0xa8, 0x34, 0xaa, 0x2a, 0x44, 0xa8, 0x6c, 0xdc, 0x3c, 0xc4, 0x4b,
	0x1f, 0x43, 0x05, 0xeb, 0xcd, 0x52, 0xda, 0x2c, 0xea, 0x99, 0x47, 0x78, 0xc6, 0x5c, 0x5a, 0x66,
	0x2d, 0x48, 0x23, 0xdb, 0x01, 0xf7, 0x59, 0xc0, 0xcd, 0x7f, 0x1f, 0x59, 0x4b, 0xa3, 0xc2, 0x59,
	0x34, 0xca, 0xfe, 0xfe, 0x13, 0xf3, 0x3f, 0xe4, 0x59, 0xd2, 0xe8, 0x4a, 0x13, 0xdc, 0x79, 0x92,
	0xb0, 0x19, 0x4b, 0xa4, 0xf8, 0x2c, 0xe9, 0xfd, 0xc1, 0x4f, 0xe3, 0x36, 0x99, 0x3a, 0x4d, 0x6a,
	0xf9, 0xd9, 0xad, 0x05, 0x15, 0x2a, 0x54, 0x23, 0x80, 0x4a, 0xe2, 0x83, 0xc9, 0xfb, 0x85, 0xca,
	0x5f, 0x0b, 0x64, 0x61, 0x57, 0xd8, 0xe8, 0x2f, 0x9b, 0xde, 0x89, 0x68, 0x1f, 0x83, 0xcf, 0x54,
	0x51, 0x41, 0x95, 0x7e, 0xf1, 0x10, 0xf2, 0x33, 0x19, 0x01, 0x54, 0xd3, 0x5e, 0x8d, 0xc0, 0xe6,
	0x9b, 0x9e, 0x15, 0x70, 0x26, 0x89, 0xb2, 0x32, 0xd7, 0xa1, 0xb4, 0xaf, 0x97, 0x05, 0xa1, 0xe6,
	0xeb, 0x57, 0x09, 0xc1, 0x25, 0x60, 0x23, 0x21, 0xd6, 0x83, 0x45, 0xaa, 0x21, 0x60, 0x55, 0x71,
	0x34, 0x96, 0x2c, 0x97, 0xa4, 0x55, 0xa5, 0x40, 0xd0, 0xf7, 0x47, 0x4e, 0xb7, 0x97, 0x88, 0x95,
	0xac, 0xd3, 0xc8, 0x9a, 0x43, 0xa9, 0x1c, 0x82, 0x0f, 0xb0, 0x53, 0x3d, 0x32, 0xa8, 0x70, 0xf1,
	0x75, 0x55, 0xc7, 0x10, 0x5f, 0x33, 0xd3, 0xa1, 0x9e, 0x1c, 0xe9, 0x50, 0x67, 0x2a, 0xe9, 0xff,
	0x2d, 0x90, 0x32, 0xac, 0x10, 0x0b, 0xc4, 0x46, 0xb3, 0x12, 0x98, 0x69, 0xed, 0x4f, 0xa2, 0x3a,
	0xc4, 0xe5, 0x9f, 0x2c, 0xb7, 0x8b, 0x49, 0xb9, 0x0d, 0x85, 0x69, 0x18, 0x9f, 0x51, 0xb5, 0x1e,
	0x35, 0x04, 0x7b, 0x33, 0x3c, 0x08, 0xc1, 0x0b, 0x4c, 0xa9, 0xde, 0x8c, 0x1c, 0x66, 0x36, 0xf4,
	0x54, 0x7e, 0x04, 0x82, 0x3d, 0x55, 0x99, 0x5d, 0x77, 0xc2, 0x67, 0xe1, 0xd8, 0xbd, 0xad, 0x93,
	0x59, 0xc5, 0x83, 0xf7, 0x30, 0x89, 0xd1, 0x4e, 0x87, 0x32, 0xb2, 0x7f, 0x73, 0x9d, 0xcc, 0xd7,
	0xdc, 0x01, 0xa4, 0xc3, 0x17, 0x34, 0x5d, 0xd3, 0x4d, 0xf7, 0xc9, 0x91, 0xa6, 0x3b, 0xb8, 0x58,
	0x27, 0x84, 0x43, 0x81, 0x39, 0xa0, 0xcb, 0xc3, 0x7b, 0x28, 0xd3, 0x11, 0x1c, 0x78, 0x61, 0xd0,
	0xe2, 0x41, 0x17, 0x1f, 0xbe, 0xc3, 0x23, 0x75, 0x37, 0x23, 0x38, 0x04, 0x79, 0xf5, 0x33, 0xa9,
	0xab, 0xa5, 0x76, 0x65, 0x61, 0x08, 0x37, 0x90, 0x48, 0x01, 0x3c, 0xac, 0xad, 0x41, 0xcd, 0x26,
	0xe9, 0x28, 0x01, 0xcb, 0x0c, 0x5f, 0x7d, 0xff, 0x69, 0x0b, 0xe1, 0xa2, 0x96, 0x4d, 0xd1, 0x34,
	0x88, 0x65, 0x46, 0x8a, 0xab, 0x2c, 0xb9, 0x52, 0xa0, 0xf1, 0x80, 0x98, 0xd2, 0x4d, 0x29, 0x87,
	0x05, 0x0e, 0x35, 0x0e, 0x33, 0xf2, 0x43, 0xe5, 0x58, 0x3a, 0x68, 0xc0, 0xb6, 0xef, 0xbb, 0x0e,
	0xb7, 0x55, 0x5b, 0x22, 0x1e, 0xaa, 0x96, 0x44, 0xaa, 0x4f, 0x9b, 0x6a, 0x49, 0x64, 0x28, 0xb8,
	0x57, 0xd9, 0xa8, 0xd8, 0x95, 0x5f, 0xda, 0xe4, 0x37, 0xcd, 0x34, 0x38, 0xa6, 0xd1, 0x31, 0x3f,
	0xb6, 0xd1, 0x81, 0xa1, 0xbe, 0x63, 0x05, 0x83, 0x63, 0xe5, 0x6b, 0x17, 0x54, 0x6f, 0x4d, 0x07,
	0xe1, 0xee, 0x31, 0xf6, 0x4b, 0x0c, 0xab, 0x99, 0x50, 0x7d, 0x9f, 0x1a, 0x25, 0x68, 0x32, 0xdb,
	0x3c, 0x70, 0x84, 0x8d, 0x2d, 0x8c, 0x79, 0x9a, 0x06, 0xb1, 0xa4, 0x96, 0x00, 0x7e, 0x58, 0xc4,
	0xc0, 0x20, 0xbb, 0x1a, 0x23, 0xb8, 0x3a, 0x55, 0x4d, 0xd8, 0xdc, 0xaa, 0x09, 0xcf, 0x1a, 0x04,
	0x01, 0xf7, 0x22, 0x6c, 0x73, 0x14, 0x69, 0x0e, 0x05, 0x02, 0xe1, 0xa1, 0x70, 0x65, 0x38, 0xbd,
	0x82, 0x5c, 0xc9, 0xd8, 0xd8, 0x26, 0x4b, 0xb1, 0xad, 0xc5, 0x2e, 0x15, 0x5b, 0x1d, 0xb3, 0x5b,
	0x57, 0x95, 0x13, 0x4e, 0x7b, 0x5b, 0x3a, 0xc2, 0x0e, 0x22, 0xe2, 0x2b, 0x4f, 0x44, 0x5c, 0xbd,
	0x50, 0x44, 0x96, 0xdd, 0xf8, 0x82, 0x2c, 0x34, 0xac, 0x94, 0x80, 0x6b, 0x17, 0x09, 0xc8, 0x30,
	0x1b, 0x0f, 0xc9, 0xa2, 0xee, 0x19, 0x9b, 0xf5, 0xd0, 0xbc, 0x8e, 0xed, 0x83, 0xeb, 0x6a, 0x7e,
	0xd6, 0x6f, 0xaa, 0x82, 0x23, 0x3b, 0xcb, 0xd8, 0x23, 0x57, 0xaa, 0xcc, 0xce, 0x68, 0x45, 0x68,
	0x9a, 0xaf, 0x22, 0x2c, 0x6f, 0xa6, 0xf1, 0x98, 0x5c, 0xae, 0x32, 0x5b, 0xfb, 0x74, 0x00, 0xe2,
	0x6e, 0xbc, 0x8a, 0xb8, 0xd1, 0x79, 0xc6, 0x01, 0xb9, 0xa6, 0xbe, 0xc8, 0xdb, 0x99, 0xcf, 0x20,
	0x2b, 0xaf, 0x22, 0x71, 0xcc, 0x64, 0x5d, 0x6c, 0xe6, 0x0b, 0xcd, 0xcd, 0xd7, 0x12, 0x9b, 0xf9,
	0x58, 0x73, 0x8f, 0xcc, 0xc4, 0xef, 0x1c, 0x9a, 0xb7, 0x50, 0xd2, 0xa2, 0xf6, 0x9c, 0x9a, 0x84,
	0x21, 0x1f, 0x4c, 0x8a, 0xf5, 0x2b, 0x34, 0xdf, 0xb8, 0x70, 0x52, 0xc2, 0x67, 0x7c, 0x0c, 0x05,
	0x8d, 0xdd, 0xb0, 0x3c, 0x9c, 0xb5, 0x7a, 0xd1, 0x2c, 0x8d, 0xd1, 0xb8, 0x4b, 0xa6, 0xa5, 0x1e,
	0x85, 0xe6, 0xda, 0x45, 0x73, 0x62, 0x2e, 0xa3, 0x35, 0xb4, 0x95, 0x38, 0x2e, 0x99, 0xeb, 0x38,
	0xf3, 0xa6, 0xf6, 0x01, 0x2a, 0x1b, 0xb6, 0x94, 0x94, 0x91, 0xa9, 0x58, 0xd1, 0x59, 0x3d, 0x6e,
	0x0f, 0x5c, 0x1e, 0xd4, 0x05, 0x14, 0xe3, 0xaa, 0xcd, 0x94, 0x85, 0xc1, 0x85, 0xd4, 0x5c, 0x87,
	0x7b, 0x51, 0xfb, 0x59, 0x17, 0x23, 0x52, 0x05, 0xf9, 0xd2, 0x20, 0x84, 0xc2, 0x83, 0xbe, 0xff,
	0x55, 0x3f, 0xf2, 0x91, 0xe7, 0x4d, 0xd9, 0xff, 0xd2, 0x20, 0xa8, 0x40, 0xd5, 0x10, 0x8b, 0x06,
	0x6c, 0x36, 0x95, 0x68, 0x0a, 0x33, 0xaa, 0xe4, 0x56, 0xfc, 0x1c, 0xf8, 0xad, 0xdd, 0x3e, 0x86,
	0xdd, 0x0e, 0x63, 0xcc, 0x5b, 0x18, 0x63, 0x2e, 0xe4, 0x31, 0xda, 0xe4, 0xcd, 0x98, 0xde, 0xe2,
	0xfd, 0xd6, 0x38, 0x51, 0x6f, 0xa3, 0xa8, 0x57, 0x61, 0x85, 0xa0, 0x83, 0x78, 0xbd, 0x0a, 0x38,
	0xe5, 0x21, 0x0f, 0x4e, 0xb9, 0xdd, 0xf1, 0x99, 0x25, 0x1b, 0x57, 0x25, 0x3a, 0x96, 0x8e, 0xff,
	0xd5, 0x20, 0xba, 0xe0, 0xed, 0xab, 0xd8, 0xbf, 0x2a, 0xd1, 0x64, 0x0c, 0x95, 0x0d, 0x2c, 0x0f,
	0x73, 0xeb, 0xd5, 0x23, 0xe6, 0x42, 0x91, 0x86, 0x35, 0xde, 0x3b, 0xc8, 0x98, 0x4f, 0x84, 0xac,
	0x3f, 0x26, 0x84, 0x47, 0xcc, 0x6d, 0xf1, 0x3e, 0xce, 0xb9, 0x83, 0x73, 0xf2, 0x48, 0xd8, 0xba,
	0x89, 0xe1, 0x27, 0x42, 0xb6, 0x08, 0xde, 0x45, 0xf6, 0x11, 0x1c, 0xce, 0xaa, 0x63, 0xf1, 0x61,
	0x30, 0x24, 0xbc, 0x27, 0xcf, 0x3a, 0x8e, 0x6e, 0xdc, 0x27, 0xd7, 0xf3, 0x68, 0x71, 0xe3, 0xa9,
	0x44, 0xc7, 0x91, 0x8d, 0xcf, 0xc9, 0x8d, 0x84, 0xb4, 0xe3, 0x0e, 0xc2, 0xde, 0x11, 0x1b, 0xc6,
	0xf5, 0x4d, 0x9c, 0x3b, 0x9e, 0x21, 0x35, 0x5b, 0x65, 0x40, 0xc8, 0xb3, 0xe3, 0xb2, 0x2e, 0xf6,
	0xa8, 0xf4, 0xd9, 0x59, 0x06, 0xb0, 0x04, 0xfd, 0xd2, 0xa0, 0x90, 0xf8, 0x00, 0xe7, 0x64, 0xe1,
	0xf8, 0x6e, 0xea, 0xdc, 0x6d, 0x3c, 0x86, 0xa4, 0x24, 0x88, 0xcb, 0xea, 0x56, 0x15, 0xdb, 0x55,
	0xea, 0x6e, 0xf2, 0xe8, 0x50, 0xe5, 0x00, 0x2d, 0xa7, 0xee, 0xde, 0xc2, 0x99, 0x63, 0xa8, 0xc9,
	0xee, 0xd8, 0x49, 0x14, 0x3f, 0xdd, 0x3d, 0x99, 0x94, 0x65, 0x60, 0xac, 0xed, 0x86, 0x50, 0x8d,
	0xf9, 0xd8, 0xb9, 0x2a, 0xd2, 0x0c, 0x0a, 0x36, 0x96, 0x29, 0x96, 0x5b, 0xec, 0x0c, 0xb2, 0xfd,
	0x1d, 0x66, 0x41, 0x59, 0xfd, 0x31, 0x36, 0x8f, 0x2e, 0xe4, 0xc9, 0x93, 0xe1, 0x78, 0x3b, 0x01,
	0xe7, 0x4a, 0xc6, 0x27, 0xf9, 0x32, 0x74, 0x1e, 0xfc, 0x46, 0x23, 0xdf, 0xa2, 0x13, 0x05, 0x8e,
	0x15, 0x1d, 0x0a, 0x17, 0x5b, 0xc1, 0x9f, 0x62, 0xd6, 0x93, 0x4b, 0x33, 0xea, 0xe4, 0x0d, 0x48,
	0x5b, 0x0f, 0x7c, 0x9b, 0x45, 0x5c, 0xfb, 0x50, 0x9e, 0x7c, 0xfa, 0xba, 0x8f, 0x93, 0x2f, 0x66,
	0x02, 0x97, 0xbd, 0xe3, 0xb2, 0xb0, 0x27, 0xdd, 0xef, 0x67, 0x17, 0xba, 0xec, 0x21, 0x63, 0x75,
	0xe9, 0xc7, 0x9f, 0x57, 0x0b, 0x3f, 0xfd, 0xbc, 0x5a, 0xf8, 0xe3, 0xcf, 0xab, 0x85, 0xef, 0xfe,
	0xb4, 0x3a, 0x71, 0x7c, 0x09, 0xe7, 0xdc, 0xfb, 0x5b, 0x00, 0x00, 0x00, 0xff, 0xff, 0x4f, 0xda,
	0xde, 0x3b, 0x86, 0x28, 0x00, 0x00,
}

func (m *DataPartitionResponsePb) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataPartitionResponsePb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataPartitionResponsePb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EcMaxUnitSize != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.EcMaxUnitSize))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.EcDataNum != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.EcDataNum))
		i--
		dAtA[i] = 0x78
	}
	if len(m.EcHosts) > 0 {
		for iNdEx := len(m.EcHosts) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.EcHosts[iNdEx])
			copy(dAtA[i:], m.EcHosts[iNdEx])
			i = encodeVarintAdmin(dAtA, i, uint64(len(m.EcHosts[iNdEx])))
			i--
			dAtA[i] = 0x72
		}
	}
	if m.EcMigrateStatus != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.EcMigrateStatus))
		i--
		dAtA[i] = 0x68
	}
	if m.Used != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.Used))
		i--
		dAtA[i] = 0x60
	}
	if m.Total != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x58
	}
	if len(m.MediumType) > 0 {
		i -= len(m.MediumType)
		copy(dAtA[i:], m.MediumType)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.MediumType)))
		i--
		dAtA[i] = 0x52
	}
	if m.CreateTime != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.CreateTime))
		i--
		dAtA[i] = 0x48
	}
	if m.IsFrozen {
		i--
		if m.IsFrozen {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.IsRecover {
		i--
		if m.IsRecover {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Epoch != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x30
	}
	{
		size := m.LeaderAddr.Size()
		i -= size
		if _, err := m.LeaderAddr.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintAdmin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.Hosts) > 0 {
		for iNdEx := len(m.Hosts) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Hosts[iNdEx])
			copy(dAtA[i:], m.Hosts[iNdEx])
			i = encodeVarintAdmin(dAtA, i, uint64(len(m.Hosts[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.ReplicaNum != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.ReplicaNum))
		i--
		dAtA[i] = 0x18
	}
	if m.Status != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.PartitionID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.PartitionID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DataPartitionsViewPb) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataPartitionsViewPb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataPartitionsViewPb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DataPartitions) > 0 {
		for iNdEx := len(m.DataPartitions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DataPartitions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MetaPartitionViewPb) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetaPartitionViewPb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetaPartitionViewPb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RocksCount != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.RocksCount))
		i--
		dAtA[i] = 0x78
	}
	if m.MemCount != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.MemCount))
		i--
		dAtA[i] = 0x70
	}
	if m.StoreMode != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.StoreMode))
		i--
		dAtA[i] = 0x68
	}
	if m.Status != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x60
	}
	if len(m.LeaderAddr) > 0 {
		i -= len(m.LeaderAddr)
		copy(dAtA[i:], m.LeaderAddr)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.LeaderAddr)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Learners) > 0 {
		for iNdEx := len(m.Learners) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Learners[iNdEx])
			copy(dAtA[i:], m.Learners[iNdEx])
			i = encodeVarintAdmin(dAtA, i, uint64(len(m.Learners[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.Members) > 0 {
		for iNdEx := len(m.Members) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Members[iNdEx])
			copy(dAtA[i:], m.Members[iNdEx])
			i = encodeVarintAdmin(dAtA, i, uint64(len(m.Members[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.IsRecover {
		i--
		if m.IsRecover {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.MaxExistIno != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.MaxExistIno))
		i--
		dAtA[i] = 0x38
	}
	if m.DentryCount != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.DentryCount))
		i--
		dAtA[i] = 0x30
	}
	if m.InodeCount != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.InodeCount))
		i--
		dAtA[i] = 0x28
	}
	if m.MaxInodeID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.MaxInodeID))
		i--
		dAtA[i] = 0x20
	}
	if m.End != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x18
	}
	if m.Start != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x10
	}
	if m.PartitionID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.PartitionID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MetaPartitionViewsPb) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetaPartitionViewsPb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetaPartitionViewsPb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.MetaPartitions) > 0 {
		for iNdEx := len(m.MetaPartitions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MetaPartitions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *EcPartitionResponsePb) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EcPartitionResponsePb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EcPartitionResponsePb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ParityUnitsNum != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.ParityUnitsNum))
		i--
		dAtA[i] = 0x38
	}
	if m.DataUnitsNum != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.DataUnitsNum))
		i--
		dAtA[i] = 0x30
	}
	if len(m.LeaderAddr) > 0 {
		i -= len(m.LeaderAddr)
		copy(dAtA[i:], m.LeaderAddr)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.LeaderAddr)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Hosts) > 0 {
		for iNdEx := len(m.Hosts) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Hosts[iNdEx])
			copy(dAtA[i:], m.Hosts[iNdEx])
			i = encodeVarintAdmin(dAtA, i, uint64(len(m.Hosts[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.ReplicaNum != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.ReplicaNum))
		i--
		dAtA[i] = 0x18
	}
	if m.Status != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.PartitionID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.PartitionID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EcPartitionsViewPb) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EcPartitionsViewPb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EcPartitionsViewPb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.EcPartitions) > 0 {
		for iNdEx := len(m.EcPartitions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EcPartitions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OSSSecure) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OSSSecure) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OSSSecure) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SecretKey) > 0 {
		i -= len(m.SecretKey)
		copy(dAtA[i:], m.SecretKey)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.SecretKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AccessKey) > 0 {
		i -= len(m.AccessKey)
		copy(dAtA[i:], m.AccessKey)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.AccessKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConnConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConnConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReadTimeoutNs != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.ReadTimeoutNs))
		i--
		dAtA[i] = 0x20
	}
	if m.WriteTimeoutNs != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.WriteTimeoutNs))
		i--
		dAtA[i] = 0x18
	}
	if m.ConnectTimeoutNs != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.ConnectTimeoutNs))
		i--
		dAtA[i] = 0x10
	}
	if m.IdleTimeoutSec != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.IdleTimeoutSec))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VolViewPb) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VolViewPb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VolViewPb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SmartRules) > 0 {
		for iNdEx := len(m.SmartRules) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SmartRules[iNdEx])
			copy(dAtA[i:], m.SmartRules[iNdEx])
			i = encodeVarintAdmin(dAtA, i, uint64(len(m.SmartRules[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if m.SmartEnableTime != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.SmartEnableTime))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.IsSmart {
		i--
		if m.IsSmart {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if m.ConnConfig != nil {
		{
			size, err := m.ConnConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdmin(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.CreateTime != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.CreateTime))
		i--
		dAtA[i] = 0x68
	}
	if m.OSSBucketPolicy != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.OSSBucketPolicy))
		i--
		dAtA[i] = 0x60
	}
	if m.OSSSecure != nil {
		{
			size, err := m.OSSSecure.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdmin(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if len(m.EcPartitions) > 0 {
		for iNdEx := len(m.EcPartitions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EcPartitions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.DataPartitions) > 0 {
		for iNdEx := len(m.DataPartitions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DataPartitions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.MetaPartitions) > 0 {
		for iNdEx := len(m.MetaPartitions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MetaPartitions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.CrossRegionHAType != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.CrossRegionHAType))
		i--
		dAtA[i] = 0x38
	}
	if m.EnableWriteCache {
		i--
		if m.EnableWriteCache {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.ForceROW {
		i--
		if m.ForceROW {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.FollowerRead {
		i--
		if m.FollowerRead {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Status != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HTTPReplyPb) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HTTPReplyPb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HTTPReplyPb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TokenPb) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TokenPb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TokenPb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.VolName) > 0 {
		i -= len(m.VolName)
		copy(dAtA[i:], m.VolName)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.VolName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if m.TokenType != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.TokenType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DpMetricsReportConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DpMetricsReportConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DpMetricsReportConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FetchIntervalSec != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.FetchIntervalSec))
		i--
		dAtA[i] = 0x18
	}
	if m.ReportIntervalSec != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.ReportIntervalSec))
		i--
		dAtA[i] = 0x10
	}
	if m.EnableReport {
		i--
		if m.EnableReport {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DpFollowerReadDelayConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DpFollowerReadDelayConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DpFollowerReadDelayConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DelaySummaryInterval != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.DelaySummaryInterval))
		i--
		dAtA[i] = 0x10
	}
	if m.EnableCollect {
		i--
		if m.EnableCollect {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MetaPartitionLayout) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetaPartitionLayout) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetaPartitionLayout) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PercentOfReplica != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.PercentOfReplica))
		i--
		dAtA[i] = 0x10
	}
	if m.PercentOfMP != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.PercentOfMP))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SimpleVolViewPb) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimpleVolViewPb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimpleVolViewPb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RemoteCacheTTL != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.RemoteCacheTTL))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xc8
	}
	if m.RemoteCacheAutoPrepare {
		i--
		if m.RemoteCacheAutoPrepare {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xc0
	}
	if len(m.RemoteCacheBoostPath) > 0 {
		i -= len(m.RemoteCacheBoostPath)
		copy(dAtA[i:], m.RemoteCacheBoostPath)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.RemoteCacheBoostPath)))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xba
	}
	if m.RemoteCacheBoostEnable {
		i--
		if m.RemoteCacheBoostEnable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xb0
	}
	if m.MarkDeleteTime != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.MarkDeleteTime))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xa8
	}
	if m.RenameConvertStatus != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.RenameConvertStatus))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xa0
	}
	if m.FinalVolStatus != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.FinalVolStatus))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x98
	}
	if len(m.OldVolName) > 0 {
		i -= len(m.OldVolName)
		copy(dAtA[i:], m.OldVolName)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.OldVolName)))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x92
	}
	if m.NewVolID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.NewVolID))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x88
	}
	if len(m.NewVolName) > 0 {
		i -= len(m.NewVolName)
		copy(dAtA[i:], m.NewVolName)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.NewVolName)))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x82
	}
	if m.TrashCleanMaxCount != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.TrashCleanMaxCount))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf8
	}
	if m.TrashCleanDuration != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.TrashCleanDuration))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf0
	}
	if m.EnableBitMapAllocator {
		i--
		if m.EnableBitMapAllocator {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xe8
	}
	if m.UmpCollectWay != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.UmpCollectWay))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xe0
	}
	if m.DelInodeInterval != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.DelInodeInterval))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xd8
	}
	if m.BatchDelInodeCnt != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.BatchDelInodeCnt))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xd0
	}
	if m.TrashCleanInterval != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.TrashCleanInterval))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xc8
	}
	if m.ChildFileMaxCount != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.ChildFileMaxCount))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xc0
	}
	if m.EcMaxUnitSize != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.EcMaxUnitSize))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xb8
	}
	if m.EcRetryWait != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.EcRetryWait))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xb0
	}
	if m.EcTimeOut != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.EcTimeOut))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xa8
	}
	if m.EcSaveTime != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.EcSaveTime))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xa0
	}
	if m.EcWaitTime != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.EcWaitTime))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x98
	}
	if m.EcParityNum != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.EcParityNum))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x90
	}
	if m.EcDataNum != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.EcDataNum))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x88
	}
	if m.EcEnable {
		i--
		if m.EcEnable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x80
	}
	if m.CompactTagModifyTime != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.CompactTagModifyTime))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xf8
	}
	if len(m.CompactTag) > 0 {
		i -= len(m.CompactTag)
		copy(dAtA[i:], m.CompactTag)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.CompactTag)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xf2
	}
	if len(m.SmartRules) > 0 {
		for iNdEx := len(m.SmartRules) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SmartRules[iNdEx])
			copy(dAtA[i:], m.SmartRules[iNdEx])
			i = encodeVarintAdmin(dAtA, i, uint64(len(m.SmartRules[iNdEx])))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xea
		}
	}
	if len(m.SmartEnableTime) > 0 {
		i -= len(m.SmartEnableTime)
		copy(dAtA[i:], m.SmartEnableTime)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.SmartEnableTime)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe2
	}
	if m.IsSmart {
		i--
		if m.IsSmart {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xd8
	}
	if m.CreateStatus != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.CreateStatus))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xd0
	}
	if m.FileAvgSize != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.FileAvgSize))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xc9
	}
	if m.UsedRatio != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.UsedRatio))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xc1
	}
	if m.UsedSize != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.UsedSize))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb8
	}
	if m.TotalSize != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.TotalSize))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb0
	}
	if len(m.UsedSizeGB) > 0 {
		i -= len(m.UsedSizeGB)
		copy(dAtA[i:], m.UsedSizeGB)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.UsedSizeGB)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xaa
	}
	if len(m.TotalSizeGB) > 0 {
		i -= len(m.TotalSizeGB)
		copy(dAtA[i:], m.TotalSizeGB)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.TotalSizeGB)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa2
	}
	{
		size, err := m.MpLayout.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAdmin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3
	i--
	dAtA[i] = 0x9a
	if m.ConvertState != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.ConvertState))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x90
	}
	if m.DefaultStoreMode != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.DefaultStoreMode))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x88
	}
	if m.TrashRemainingDays != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.TrashRemainingDays))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x80
	}
	if m.MinWritableDPNum != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.MinWritableDPNum))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf8
	}
	if m.MinWritableMPNum != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.MinWritableMPNum))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf0
	}
	if m.RwMpCnt != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.RwMpCnt))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe8
	}
	if m.FolReadHostWeight != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.FolReadHostWeight))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe0
	}
	{
		size, err := m.DpFolReadDelayConfig.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAdmin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xda
	if m.DpMetricsReportConfig != nil {
		{
			size, err := m.DpMetricsReportConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdmin(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd2
	}
	if m.ExtentCacheExpireSec != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.ExtentCacheExpireSec))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc8
	}
	if m.ConnConfig != nil {
		{
			size, err := m.ConnConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdmin(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	if len(m.SlaveRegionZone) > 0 {
		i -= len(m.SlaveRegionZone)
		copy(dAtA[i:], m.SlaveRegionZone)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.SlaveRegionZone)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xba
	}
	if len(m.MasterRegionZone) > 0 {
		i -= len(m.MasterRegionZone)
		copy(dAtA[i:], m.MasterRegionZone)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.MasterRegionZone)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb2
	}
	if m.MPConvertMode != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.MPConvertMode))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa8
	}
	if m.DPConvertMode != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.DPConvertMode))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa0
	}
	if m.OSSBucketPolicy != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.OSSBucketPolicy))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x98
	}
	if m.Quorum != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.Quorum))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if len(m.DpSelectorParm) > 0 {
		i -= len(m.DpSelectorParm)
		copy(dAtA[i:], m.DpSelectorParm)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.DpSelectorParm)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8a
	}
	if len(m.DpSelectorName) > 0 {
		i -= len(m.DpSelectorName)
		copy(dAtA[i:], m.DpSelectorName)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.DpSelectorName)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	if len(m.Tokens) > 0 {
		for k := range m.Tokens {
			v := m.Tokens[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintAdmin(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAdmin(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAdmin(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xf2
		}
	}
	if m.CrossRegionHAType != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.CrossRegionHAType))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.EnableWriteCache {
		i--
		if m.EnableWriteCache {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.ForceROW {
		i--
		if m.ForceROW {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.EnableToken {
		i--
		if m.EnableToken {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if len(m.CreateTime) > 0 {
		i -= len(m.CreateTime)
		copy(dAtA[i:], m.CreateTime)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.CreateTime)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if m.AutoRepair {
		i--
		if m.AutoRepair {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.CrossZone {
		i--
		if m.CrossZone {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.VolWriteMutexEnable {
		i--
		if m.VolWriteMutexEnable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.Authenticate {
		i--
		if m.Authenticate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.NeedToLowerReplica {
		i--
		if m.NeedToLowerReplica {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.NearRead {
		i--
		if m.NearRead {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.FollowerRead {
		i--
		if m.FollowerRead {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.DpCnt != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.DpCnt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.MpCnt != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.MpCnt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.RwDpCnt != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.RwDpCnt))
		i--
		dAtA[i] = 0x78
	}
	if m.DpWriteableThreshold != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.DpWriteableThreshold))))
		i--
		dAtA[i] = 0x71
	}
	if m.Capacity != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.Capacity))
		i--
		dAtA[i] = 0x68
	}
	if m.Status != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x60
	}
	if m.MaxMetaPartitionID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.MaxMetaPartitionID))
		i--
		dAtA[i] = 0x58
	}
	if m.DentryCount != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.DentryCount))
		i--
		dAtA[i] = 0x50
	}
	if m.InodeCount != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.InodeCount))
		i--
		dAtA[i] = 0x48
	}
	if m.MpLearnerNum != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.MpLearnerNum))
		i--
		dAtA[i] = 0x40
	}
	if m.DpLearnerNum != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.DpLearnerNum))
		i--
		dAtA[i] = 0x38
	}
	if m.MpReplicaNum != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.MpReplicaNum))
		i--
		dAtA[i] = 0x30
	}
	if m.DpReplicaNum != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.DpReplicaNum))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ZoneName) > 0 {
		i -= len(m.ZoneName)
		copy(dAtA[i:], m.ZoneName)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.ZoneName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.ID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NodeStatInfoPb) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeStatInfoPb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeStatInfoPb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.HighUsedRatioNodes != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.HighUsedRatioNodes))
		i--
		dAtA[i] = 0x38
	}
	if m.WritableNodes != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.WritableNodes))
		i--
		dAtA[i] = 0x30
	}
	if m.TotalNodes != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.TotalNodes))
		i--
		dAtA[i] = 0x28
	}
	if len(m.UsedRatio) > 0 {
		i -= len(m.UsedRatio)
		copy(dAtA[i:], m.UsedRatio)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.UsedRatio)))
		i--
		dAtA[i] = 0x22
	}
	if m.IncreasedGB != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.IncreasedGB))
		i--
		dAtA[i] = 0x18
	}
	if m.UsedGB != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.UsedGB))
		i--
		dAtA[i] = 0x10
	}
	if m.TotalGB != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.TotalGB))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BadPartitionView) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BadPartitionView) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BadPartitionView) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PartitionID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.PartitionID))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodeView) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeView) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeView) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x2a
	}
	if m.IsWritable {
		i--
		if m.IsWritable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.ID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x18
	}
	if m.Status {
		i--
		if m.Status {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DataNodeBadDisksView) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataNodeBadDisksView) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataNodeBadDisksView) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BadDiskPath) > 0 {
		for iNdEx := len(m.BadDiskPath) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.BadDiskPath[iNdEx])
			copy(dAtA[i:], m.BadDiskPath[iNdEx])
			i = encodeVarintAdmin(dAtA, i, uint64(len(m.BadDiskPath[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClusterViewPb) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterViewPb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterViewPb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FlashNodes) > 0 {
		for iNdEx := len(m.FlashNodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FlashNodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xca
		}
	}
	if m.AutoUpdatePartitionReplicaNum {
		i--
		if m.AutoUpdatePartitionReplicaNum {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xc0
	}
	if m.DisableStrictVolZone {
		i--
		if m.DisableStrictVolZone {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb8
	}
	if m.BitMapAllocatorMinFreeFactor != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.BitMapAllocatorMinFreeFactor))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb1
	}
	if m.BitMapAllocatorMaxUsedFactor != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.BitMapAllocatorMaxUsedFactor))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa9
	}
	if m.MetaRaftLogCap != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.MetaRaftLogCap))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa0
	}
	if m.MetaRaftLogSize != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.MetaRaftLogSize))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x98
	}
	if m.MetaTrashCleanInterval != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.MetaTrashCleanInterval))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x90
	}
	if m.MetaDelEKRecordFileMaxMB != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.MetaDelEKRecordFileMaxMB))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x88
	}
	if m.MetaRocksWalTTL != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.MetaRocksWalTTL))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x80
	}
	if m.MetaRocksDisableFlushFlag != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.MetaRocksDisableFlushFlag))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf8
	}
	if m.MetaRocksFlushWalInterval != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.MetaRocksFlushWalInterval))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf0
	}
	if m.MetaRocksLogReservedCnt != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.MetaRocksLogReservedCnt))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe8
	}
	if m.MetaRocksLogReservedTime != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.MetaRocksLogReservedTime))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe0
	}
	if m.MetaRocksLogSize != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.MetaRocksLogSize))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd8
	}
	if m.MetaRocksWalMemSize != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.MetaRocksWalMemSize))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd0
	}
	if m.MetaRockDBWalFileSize != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.MetaRockDBWalFileSize))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc8
	}
	if m.LogMaxMB != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.LogMaxMB))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc0
	}
	if m.RocksDBDiskReservedSpace != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.RocksDBDiskReservedSpace))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb8
	}
	if m.MetaNodeMemModeRocksdbDiskThreshold != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.MetaNodeMemModeRocksdbDiskThreshold))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb5
	}
	if m.MetaNodeRocksdbDiskThreshold != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.MetaNodeRocksdbDiskThreshold))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xad
	}
	if m.UmpJmtpBatch != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.UmpJmtpBatch))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa0
	}
	if len(m.UmpJmtpAddr) > 0 {
		i -= len(m.UmpJmtpAddr)
		copy(dAtA[i:], m.UmpJmtpAddr)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.UmpJmtpAddr)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	if len(m.ClientPkgAddr) > 0 {
		i -= len(m.ClientPkgAddr)
		copy(dAtA[i:], m.ClientPkgAddr)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.ClientPkgAddr)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	if len(m.SchedulerDomain) > 0 {
		i -= len(m.SchedulerDomain)
		copy(dAtA[i:], m.SchedulerDomain)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.SchedulerDomain)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8a
	}
	if len(m.DataNodeBadDisks) > 0 {
		for iNdEx := len(m.DataNodeBadDisks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DataNodeBadDisks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.EcNodes) > 0 {
		for iNdEx := len(m.EcNodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EcNodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xfa
		}
	}
	if len(m.CodEcnodes) > 0 {
		for iNdEx := len(m.CodEcnodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CodEcnodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xf2
		}
	}
	if len(m.DataNodes) > 0 {
		for iNdEx := len(m.DataNodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DataNodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xea
		}
	}
	if len(m.MetaNodes) > 0 {
		for iNdEx := len(m.MetaNodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MetaNodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xe2
		}
	}
	if len(m.MigratedMetaPartitions) > 0 {
		for iNdEx := len(m.MigratedMetaPartitions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MigratedMetaPartitions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xda
		}
	}
	if len(m.MigratedDataPartitions) > 0 {
		for iNdEx := len(m.MigratedDataPartitions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MigratedDataPartitions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xd2
		}
	}
	if len(m.BadEcPartitionIDs) > 0 {
		for iNdEx := len(m.BadEcPartitionIDs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BadEcPartitionIDs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xca
		}
	}
	if len(m.BadMetaPartitionIDs) > 0 {
		for iNdEx := len(m.BadMetaPartitionIDs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BadMetaPartitionIDs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xc2
		}
	}
	if len(m.BadPartitionIDs) > 0 {
		for iNdEx := len(m.BadPartitionIDs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BadPartitionIDs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xba
		}
	}
	if m.EcNodeStatInfo != nil {
		{
			size, err := m.EcNodeStatInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdmin(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.MetaNodeStatInfo != nil {
		{
			size, err := m.MetaNodeStatInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdmin(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.DataNodeStatInfo != nil {
		{
			size, err := m.DataNodeStatInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdmin(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.VolCount != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.VolCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.MaxCodecConcurrent != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.MaxCodecConcurrent))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.EcScrubStartTime != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.EcScrubStartTime))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.EcScrubPeriod != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.EcScrubPeriod))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.EcMaxScrubExtents != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.EcMaxScrubExtents))
		i--
		dAtA[i] = 0x78
	}
	if m.EcScrubEnable {
		i--
		if m.EcScrubEnable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if m.MaxMetaPartitionID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.MaxMetaPartitionID))
		i--
		dAtA[i] = 0x68
	}
	if m.MaxMetaNodeID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.MaxMetaNodeID))
		i--
		dAtA[i] = 0x60
	}
	if m.MaxDataPartitionID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.MaxDataPartitionID))
		i--
		dAtA[i] = 0x58
	}
	if m.Applied != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.Applied))
		i--
		dAtA[i] = 0x50
	}
	if m.DeleteMarkDelVolInterval != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.DeleteMarkDelVolInterval))
		i--
		dAtA[i] = 0x48
	}
	if m.MpRecoverPool != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.MpRecoverPool))
		i--
		dAtA[i] = 0x40
	}
	if m.DpRecoverPool != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.DpRecoverPool))
		i--
		dAtA[i] = 0x38
	}
	if m.MetaNodeThreshold != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.MetaNodeThreshold))))
		i--
		dAtA[i] = 0x35
	}
	if m.NodeSetCapacity != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.NodeSetCapacity))
		i--
		dAtA[i] = 0x28
	}
	if m.AutoMergeNodeSet {
		i--
		if m.AutoMergeNodeSet {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.DisableAutoAlloc {
		i--
		if m.DisableAutoAlloc {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.LeaderAddr) > 0 {
		i -= len(m.LeaderAddr)
		copy(dAtA[i:], m.LeaderAddr)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.LeaderAddr)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintAdmin(dAtA []byte, offset int, v uint64) int {
	offset -= sovAdmin(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *DataPartitionResponsePb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PartitionID != 0 {
		n += 1 + sovAdmin(uint64(m.PartitionID))
	}
	if m.Status != 0 {
		n += 1 + sovAdmin(uint64(m.Status))
	}
	if m.ReplicaNum != 0 {
		n += 1 + sovAdmin(uint64(m.ReplicaNum))
	}
	if len(m.Hosts) > 0 {
		for _, s := range m.Hosts {
			l = len(s)
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	l = m.LeaderAddr.Size()
	n += 1 + l + sovAdmin(uint64(l))
	if m.Epoch != 0 {
		n += 1 + sovAdmin(uint64(m.Epoch))
	}
	if m.IsRecover {
		n += 2
	}
	if m.IsFrozen {
		n += 2
	}
	if m.CreateTime != 0 {
		n += 1 + sovAdmin(uint64(m.CreateTime))
	}
	l = len(m.MediumType)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.Total != 0 {
		n += 1 + sovAdmin(uint64(m.Total))
	}
	if m.Used != 0 {
		n += 1 + sovAdmin(uint64(m.Used))
	}
	if m.EcMigrateStatus != 0 {
		n += 1 + sovAdmin(uint64(m.EcMigrateStatus))
	}
	if len(m.EcHosts) > 0 {
		for _, s := range m.EcHosts {
			l = len(s)
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	if m.EcDataNum != 0 {
		n += 1 + sovAdmin(uint64(m.EcDataNum))
	}
	if m.EcMaxUnitSize != 0 {
		n += 2 + sovAdmin(uint64(m.EcMaxUnitSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DataPartitionsViewPb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DataPartitions) > 0 {
		for _, e := range m.DataPartitions {
			l = e.Size()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MetaPartitionViewPb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PartitionID != 0 {
		n += 1 + sovAdmin(uint64(m.PartitionID))
	}
	if m.Start != 0 {
		n += 1 + sovAdmin(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovAdmin(uint64(m.End))
	}
	if m.MaxInodeID != 0 {
		n += 1 + sovAdmin(uint64(m.MaxInodeID))
	}
	if m.InodeCount != 0 {
		n += 1 + sovAdmin(uint64(m.InodeCount))
	}
	if m.DentryCount != 0 {
		n += 1 + sovAdmin(uint64(m.DentryCount))
	}
	if m.MaxExistIno != 0 {
		n += 1 + sovAdmin(uint64(m.MaxExistIno))
	}
	if m.IsRecover {
		n += 2
	}
	if len(m.Members) > 0 {
		for _, s := range m.Members {
			l = len(s)
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	if len(m.Learners) > 0 {
		for _, s := range m.Learners {
			l = len(s)
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	l = len(m.LeaderAddr)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovAdmin(uint64(m.Status))
	}
	if m.StoreMode != 0 {
		n += 1 + sovAdmin(uint64(m.StoreMode))
	}
	if m.MemCount != 0 {
		n += 1 + sovAdmin(uint64(m.MemCount))
	}
	if m.RocksCount != 0 {
		n += 1 + sovAdmin(uint64(m.RocksCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MetaPartitionViewsPb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MetaPartitions) > 0 {
		for _, e := range m.MetaPartitions {
			l = e.Size()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EcPartitionResponsePb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PartitionID != 0 {
		n += 1 + sovAdmin(uint64(m.PartitionID))
	}
	if m.Status != 0 {
		n += 1 + sovAdmin(uint64(m.Status))
	}
	if m.ReplicaNum != 0 {
		n += 1 + sovAdmin(uint64(m.ReplicaNum))
	}
	if len(m.Hosts) > 0 {
		for _, s := range m.Hosts {
			l = len(s)
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	l = len(m.LeaderAddr)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.DataUnitsNum != 0 {
		n += 1 + sovAdmin(uint64(m.DataUnitsNum))
	}
	if m.ParityUnitsNum != 0 {
		n += 1 + sovAdmin(uint64(m.ParityUnitsNum))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EcPartitionsViewPb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.EcPartitions) > 0 {
		for _, e := range m.EcPartitions {
			l = e.Size()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OSSSecure) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccessKey)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.SecretKey)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *ConnConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IdleTimeoutSec != 0 {
		n += 1 + sovAdmin(uint64(m.IdleTimeoutSec))
	}
	if m.ConnectTimeoutNs != 0 {
		n += 1 + sovAdmin(uint64(m.ConnectTimeoutNs))
	}
	if m.WriteTimeoutNs != 0 {
		n += 1 + sovAdmin(uint64(m.WriteTimeoutNs))
	}
	if m.ReadTimeoutNs != 0 {
		n += 1 + sovAdmin(uint64(m.ReadTimeoutNs))
	}
	return n
}

func (m *VolViewPb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovAdmin(uint64(m.Status))
	}
	if m.FollowerRead {
		n += 2
	}
	if m.ForceROW {
		n += 2
	}
	if m.EnableWriteCache {
		n += 2
	}
	if m.CrossRegionHAType != 0 {
		n += 1 + sovAdmin(uint64(m.CrossRegionHAType))
	}
	if len(m.MetaPartitions) > 0 {
		for _, e := range m.MetaPartitions {
			l = e.Size()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	if len(m.DataPartitions) > 0 {
		for _, e := range m.DataPartitions {
			l = e.Size()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	if len(m.EcPartitions) > 0 {
		for _, e := range m.EcPartitions {
			l = e.Size()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	if m.OSSSecure != nil {
		l = m.OSSSecure.Size()
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.OSSBucketPolicy != 0 {
		n += 1 + sovAdmin(uint64(m.OSSBucketPolicy))
	}
	if m.CreateTime != 0 {
		n += 1 + sovAdmin(uint64(m.CreateTime))
	}
	if m.ConnConfig != nil {
		l = m.ConnConfig.Size()
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.IsSmart {
		n += 2
	}
	if m.SmartEnableTime != 0 {
		n += 2 + sovAdmin(uint64(m.SmartEnableTime))
	}
	if len(m.SmartRules) > 0 {
		for _, s := range m.SmartRules {
			l = len(s)
			n += 2 + l + sovAdmin(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HTTPReplyPb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovAdmin(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TokenPb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TokenType != 0 {
		n += 1 + sovAdmin(uint64(m.TokenType))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.VolName)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DpMetricsReportConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnableReport {
		n += 2
	}
	if m.ReportIntervalSec != 0 {
		n += 1 + sovAdmin(uint64(m.ReportIntervalSec))
	}
	if m.FetchIntervalSec != 0 {
		n += 1 + sovAdmin(uint64(m.FetchIntervalSec))
	}
	return n
}

func (m *DpFollowerReadDelayConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnableCollect {
		n += 2
	}
	if m.DelaySummaryInterval != 0 {
		n += 1 + sovAdmin(uint64(m.DelaySummaryInterval))
	}
	return n
}

func (m *MetaPartitionLayout) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PercentOfMP != 0 {
		n += 1 + sovAdmin(uint64(m.PercentOfMP))
	}
	if m.PercentOfReplica != 0 {
		n += 1 + sovAdmin(uint64(m.PercentOfReplica))
	}
	return n
}

func (m *SimpleVolViewPb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovAdmin(uint64(m.ID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.ZoneName)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.DpReplicaNum != 0 {
		n += 1 + sovAdmin(uint64(m.DpReplicaNum))
	}
	if m.MpReplicaNum != 0 {
		n += 1 + sovAdmin(uint64(m.MpReplicaNum))
	}
	if m.DpLearnerNum != 0 {
		n += 1 + sovAdmin(uint64(m.DpLearnerNum))
	}
	if m.MpLearnerNum != 0 {
		n += 1 + sovAdmin(uint64(m.MpLearnerNum))
	}
	if m.InodeCount != 0 {
		n += 1 + sovAdmin(uint64(m.InodeCount))
	}
	if m.DentryCount != 0 {
		n += 1 + sovAdmin(uint64(m.DentryCount))
	}
	if m.MaxMetaPartitionID != 0 {
		n += 1 + sovAdmin(uint64(m.MaxMetaPartitionID))
	}
	if m.Status != 0 {
		n += 1 + sovAdmin(uint64(m.Status))
	}
	if m.Capacity != 0 {
		n += 1 + sovAdmin(uint64(m.Capacity))
	}
	if m.DpWriteableThreshold != 0 {
		n += 9
	}
	if m.RwDpCnt != 0 {
		n += 1 + sovAdmin(uint64(m.RwDpCnt))
	}
	if m.MpCnt != 0 {
		n += 2 + sovAdmin(uint64(m.MpCnt))
	}
	if m.DpCnt != 0 {
		n += 2 + sovAdmin(uint64(m.DpCnt))
	}
	if m.FollowerRead {
		n += 3
	}
	if m.NearRead {
		n += 3
	}
	if m.NeedToLowerReplica {
		n += 3
	}
	if m.Authenticate {
		n += 3
	}
	if m.VolWriteMutexEnable {
		n += 3
	}
	if m.CrossZone {
		n += 3
	}
	if m.AutoRepair {
		n += 3
	}
	l = len(m.CreateTime)
	if l > 0 {
		n += 2 + l + sovAdmin(uint64(l))
	}
	if m.EnableToken {
		n += 3
	}
	if m.ForceROW {
		n += 3
	}
	if m.EnableWriteCache {
		n += 3
	}
	if m.CrossRegionHAType != 0 {
		n += 2 + sovAdmin(uint64(m.CrossRegionHAType))
	}
	if len(m.Tokens) > 0 {
		for k, v := range m.Tokens {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovAdmin(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovAdmin(uint64(len(k))) + l
			n += mapEntrySize + 2 + sovAdmin(uint64(mapEntrySize))
		}
	}
	l = len(m.Description)
	if l > 0 {
		n += 2 + l + sovAdmin(uint64(l))
	}
	l = len(m.DpSelectorName)
	if l > 0 {
		n += 2 + l + sovAdmin(uint64(l))
	}
	l = len(m.DpSelectorParm)
	if l > 0 {
		n += 2 + l + sovAdmin(uint64(l))
	}
	if m.Quorum != 0 {
		n += 2 + sovAdmin(uint64(m.Quorum))
	}
	if m.OSSBucketPolicy != 0 {
		n += 2 + sovAdmin(uint64(m.OSSBucketPolicy))
	}
	if m.DPConvertMode != 0 {
		n += 2 + sovAdmin(uint64(m.DPConvertMode))
	}
	if m.MPConvertMode != 0 {
		n += 2 + sovAdmin(uint64(m.MPConvertMode))
	}
	l = len(m.MasterRegionZone)
	if l > 0 {
		n += 2 + l + sovAdmin(uint64(l))
	}
	l = len(m.SlaveRegionZone)
	if l > 0 {
		n += 2 + l + sovAdmin(uint64(l))
	}
	if m.ConnConfig != nil {
		l = m.ConnConfig.Size()
		n += 2 + l + sovAdmin(uint64(l))
	}
	if m.ExtentCacheExpireSec != 0 {
		n += 2 + sovAdmin(uint64(m.ExtentCacheExpireSec))
	}
	if m.DpMetricsReportConfig != nil {
		l = m.DpMetricsReportConfig.Size()
		n += 2 + l + sovAdmin(uint64(l))
	}
	l = m.DpFolReadDelayConfig.Size()
	n += 2 + l + sovAdmin(uint64(l))
	if m.FolReadHostWeight != 0 {
		n += 2 + sovAdmin(uint64(m.FolReadHostWeight))
	}
	if m.RwMpCnt != 0 {
		n += 2 + sovAdmin(uint64(m.RwMpCnt))
	}
	if m.MinWritableMPNum != 0 {
		n += 2 + sovAdmin(uint64(m.MinWritableMPNum))
	}
	if m.MinWritableDPNum != 0 {
		n += 2 + sovAdmin(uint64(m.MinWritableDPNum))
	}
	if m.TrashRemainingDays != 0 {
		n += 2 + sovAdmin(uint64(m.TrashRemainingDays))
	}
	if m.DefaultStoreMode != 0 {
		n += 2 + sovAdmin(uint64(m.DefaultStoreMode))
	}
	if m.ConvertState != 0 {
		n += 2 + sovAdmin(uint64(m.ConvertState))
	}
	l = m.MpLayout.Size()
	n += 2 + l + sovAdmin(uint64(l))
	l = len(m.TotalSizeGB)
	if l > 0 {
		n += 2 + l + sovAdmin(uint64(l))
	}
	l = len(m.UsedSizeGB)
	if l > 0 {
		n += 2 + l + sovAdmin(uint64(l))
	}
	if m.TotalSize != 0 {
		n += 2 + sovAdmin(uint64(m.TotalSize))
	}
	if m.UsedSize != 0 {
		n += 2 + sovAdmin(uint64(m.UsedSize))
	}
	if m.UsedRatio != 0 {
		n += 10
	}
	if m.FileAvgSize != 0 {
		n += 10
	}
	if m.CreateStatus != 0 {
		n += 2 + sovAdmin(uint64(m.CreateStatus))
	}
	if m.IsSmart {
		n += 3
	}
	l = len(m.SmartEnableTime)
	if l > 0 {
		n += 2 + l + sovAdmin(uint64(l))
	}
	if len(m.SmartRules) > 0 {
		for _, s := range m.SmartRules {
			l = len(s)
			n += 2 + l + sovAdmin(uint64(l))
		}
	}
	l = len(m.CompactTag)
	if l > 0 {
		n += 2 + l + sovAdmin(uint64(l))
	}
	if m.CompactTagModifyTime != 0 {
		n += 2 + sovAdmin(uint64(m.CompactTagModifyTime))
	}
	if m.EcEnable {
		n += 3
	}
	if m.EcDataNum != 0 {
		n += 2 + sovAdmin(uint64(m.EcDataNum))
	}
	if m.EcParityNum != 0 {
		n += 2 + sovAdmin(uint64(m.EcParityNum))
	}
	if m.EcWaitTime != 0 {
		n += 2 + sovAdmin(uint64(m.EcWaitTime))
	}
	if m.EcSaveTime != 0 {
		n += 2 + sovAdmin(uint64(m.EcSaveTime))
	}
	if m.EcTimeOut != 0 {
		n += 2 + sovAdmin(uint64(m.EcTimeOut))
	}
	if m.EcRetryWait != 0 {
		n += 2 + sovAdmin(uint64(m.EcRetryWait))
	}
	if m.EcMaxUnitSize != 0 {
		n += 2 + sovAdmin(uint64(m.EcMaxUnitSize))
	}
	if m.ChildFileMaxCount != 0 {
		n += 2 + sovAdmin(uint64(m.ChildFileMaxCount))
	}
	if m.TrashCleanInterval != 0 {
		n += 2 + sovAdmin(uint64(m.TrashCleanInterval))
	}
	if m.BatchDelInodeCnt != 0 {
		n += 2 + sovAdmin(uint64(m.BatchDelInodeCnt))
	}
	if m.DelInodeInterval != 0 {
		n += 2 + sovAdmin(uint64(m.DelInodeInterval))
	}
	if m.UmpCollectWay != 0 {
		n += 2 + sovAdmin(uint64(m.UmpCollectWay))
	}
	if m.EnableBitMapAllocator {
		n += 3
	}
	if m.TrashCleanDuration != 0 {
		n += 2 + sovAdmin(uint64(m.TrashCleanDuration))
	}
	if m.TrashCleanMaxCount != 0 {
		n += 2 + sovAdmin(uint64(m.TrashCleanMaxCount))
	}
	l = len(m.NewVolName)
	if l > 0 {
		n += 2 + l + sovAdmin(uint64(l))
	}
	if m.NewVolID != 0 {
		n += 2 + sovAdmin(uint64(m.NewVolID))
	}
	l = len(m.OldVolName)
	if l > 0 {
		n += 2 + l + sovAdmin(uint64(l))
	}
	if m.FinalVolStatus != 0 {
		n += 2 + sovAdmin(uint64(m.FinalVolStatus))
	}
	if m.RenameConvertStatus != 0 {
		n += 2 + sovAdmin(uint64(m.RenameConvertStatus))
	}
	if m.MarkDeleteTime != 0 {
		n += 2 + sovAdmin(uint64(m.MarkDeleteTime))
	}
	if m.RemoteCacheBoostEnable {
		n += 3
	}
	l = len(m.RemoteCacheBoostPath)
	if l > 0 {
		n += 2 + l + sovAdmin(uint64(l))
	}
	if m.RemoteCacheAutoPrepare {
		n += 3
	}
	if m.RemoteCacheTTL != 0 {
		n += 2 + sovAdmin(uint64(m.RemoteCacheTTL))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NodeStatInfoPb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TotalGB != 0 {
		n += 1 + sovAdmin(uint64(m.TotalGB))
	}
	if m.UsedGB != 0 {
		n += 1 + sovAdmin(uint64(m.UsedGB))
	}
	if m.IncreasedGB != 0 {
		n += 1 + sovAdmin(uint64(m.IncreasedGB))
	}
	l = len(m.UsedRatio)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.TotalNodes != 0 {
		n += 1 + sovAdmin(uint64(m.TotalNodes))
	}
	if m.WritableNodes != 0 {
		n += 1 + sovAdmin(uint64(m.WritableNodes))
	}
	if m.HighUsedRatioNodes != 0 {
		n += 1 + sovAdmin(uint64(m.HighUsedRatioNodes))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BadPartitionView) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.PartitionID != 0 {
		n += 1 + sovAdmin(uint64(m.PartitionID))
	}
	return n
}

func (m *NodeView) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.Status {
		n += 2
	}
	if m.ID != 0 {
		n += 1 + sovAdmin(uint64(m.ID))
	}
	if m.IsWritable {
		n += 2
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *DataNodeBadDisksView) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if len(m.BadDiskPath) > 0 {
		for _, s := range m.BadDiskPath {
			l = len(s)
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	return n
}

func (m *ClusterViewPb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.LeaderAddr)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.DisableAutoAlloc {
		n += 2
	}
	if m.AutoMergeNodeSet {
		n += 2
	}
	if m.NodeSetCapacity != 0 {
		n += 1 + sovAdmin(uint64(m.NodeSetCapacity))
	}
	if m.MetaNodeThreshold != 0 {
		n += 5
	}
	if m.DpRecoverPool != 0 {
		n += 1 + sovAdmin(uint64(m.DpRecoverPool))
	}
	if m.MpRecoverPool != 0 {
		n += 1 + sovAdmin(uint64(m.MpRecoverPool))
	}
	if m.DeleteMarkDelVolInterval != 0 {
		n += 1 + sovAdmin(uint64(m.DeleteMarkDelVolInterval))
	}
	if m.Applied != 0 {
		n += 1 + sovAdmin(uint64(m.Applied))
	}
	if m.MaxDataPartitionID != 0 {
		n += 1 + sovAdmin(uint64(m.MaxDataPartitionID))
	}
	if m.MaxMetaNodeID != 0 {
		n += 1 + sovAdmin(uint64(m.MaxMetaNodeID))
	}
	if m.MaxMetaPartitionID != 0 {
		n += 1 + sovAdmin(uint64(m.MaxMetaPartitionID))
	}
	if m.EcScrubEnable {
		n += 2
	}
	if m.EcMaxScrubExtents != 0 {
		n += 1 + sovAdmin(uint64(m.EcMaxScrubExtents))
	}
	if m.EcScrubPeriod != 0 {
		n += 2 + sovAdmin(uint64(m.EcScrubPeriod))
	}
	if m.EcScrubStartTime != 0 {
		n += 2 + sovAdmin(uint64(m.EcScrubStartTime))
	}
	if m.MaxCodecConcurrent != 0 {
		n += 2 + sovAdmin(uint64(m.MaxCodecConcurrent))
	}
	if m.VolCount != 0 {
		n += 2 + sovAdmin(uint64(m.VolCount))
	}
	if m.DataNodeStatInfo != nil {
		l = m.DataNodeStatInfo.Size()
		n += 2 + l + sovAdmin(uint64(l))
	}
	if m.MetaNodeStatInfo != nil {
		l = m.MetaNodeStatInfo.Size()
		n += 2 + l + sovAdmin(uint64(l))
	}
	if m.EcNodeStatInfo != nil {
		l = m.EcNodeStatInfo.Size()
		n += 2 + l + sovAdmin(uint64(l))
	}
	if len(m.BadPartitionIDs) > 0 {
		for _, e := range m.BadPartitionIDs {
			l = e.Size()
			n += 2 + l + sovAdmin(uint64(l))
		}
	}
	if len(m.BadMetaPartitionIDs) > 0 {
		for _, e := range m.BadMetaPartitionIDs {
			l = e.Size()
			n += 2 + l + sovAdmin(uint64(l))
		}
	}
	if len(m.BadEcPartitionIDs) > 0 {
		for _, e := range m.BadEcPartitionIDs {
			l = e.Size()
			n += 2 + l + sovAdmin(uint64(l))
		}
	}
	if len(m.MigratedDataPartitions) > 0 {
		for _, e := range m.MigratedDataPartitions {
			l = e.Size()
			n += 2 + l + sovAdmin(uint64(l))
		}
	}
	if len(m.MigratedMetaPartitions) > 0 {
		for _, e := range m.MigratedMetaPartitions {
			l = e.Size()
			n += 2 + l + sovAdmin(uint64(l))
		}
	}
	if len(m.MetaNodes) > 0 {
		for _, e := range m.MetaNodes {
			l = e.Size()
			n += 2 + l + sovAdmin(uint64(l))
		}
	}
	if len(m.DataNodes) > 0 {
		for _, e := range m.DataNodes {
			l = e.Size()
			n += 2 + l + sovAdmin(uint64(l))
		}
	}
	if len(m.CodEcnodes) > 0 {
		for _, e := range m.CodEcnodes {
			l = e.Size()
			n += 2 + l + sovAdmin(uint64(l))
		}
	}
	if len(m.EcNodes) > 0 {
		for _, e := range m.EcNodes {
			l = e.Size()
			n += 2 + l + sovAdmin(uint64(l))
		}
	}
	if len(m.DataNodeBadDisks) > 0 {
		for _, e := range m.DataNodeBadDisks {
			l = e.Size()
			n += 2 + l + sovAdmin(uint64(l))
		}
	}
	l = len(m.SchedulerDomain)
	if l > 0 {
		n += 2 + l + sovAdmin(uint64(l))
	}
	l = len(m.ClientPkgAddr)
	if l > 0 {
		n += 2 + l + sovAdmin(uint64(l))
	}
	l = len(m.UmpJmtpAddr)
	if l > 0 {
		n += 2 + l + sovAdmin(uint64(l))
	}
	if m.UmpJmtpBatch != 0 {
		n += 2 + sovAdmin(uint64(m.UmpJmtpBatch))
	}
	if m.MetaNodeRocksdbDiskThreshold != 0 {
		n += 6
	}
	if m.MetaNodeMemModeRocksdbDiskThreshold != 0 {
		n += 6
	}
	if m.RocksDBDiskReservedSpace != 0 {
		n += 2 + sovAdmin(uint64(m.RocksDBDiskReservedSpace))
	}
	if m.LogMaxMB != 0 {
		n += 2 + sovAdmin(uint64(m.LogMaxMB))
	}
	if m.MetaRockDBWalFileSize != 0 {
		n += 2 + sovAdmin(uint64(m.MetaRockDBWalFileSize))
	}
	if m.MetaRocksWalMemSize != 0 {
		n += 2 + sovAdmin(uint64(m.MetaRocksWalMemSize))
	}
	if m.MetaRocksLogSize != 0 {
		n += 2 + sovAdmin(uint64(m.MetaRocksLogSize))
	}
	if m.MetaRocksLogReservedTime != 0 {
		n += 2 + sovAdmin(uint64(m.MetaRocksLogReservedTime))
	}
	if m.MetaRocksLogReservedCnt != 0 {
		n += 2 + sovAdmin(uint64(m.MetaRocksLogReservedCnt))
	}
	if m.MetaRocksFlushWalInterval != 0 {
		n += 2 + sovAdmin(uint64(m.MetaRocksFlushWalInterval))
	}
	if m.MetaRocksDisableFlushFlag != 0 {
		n += 2 + sovAdmin(uint64(m.MetaRocksDisableFlushFlag))
	}
	if m.MetaRocksWalTTL != 0 {
		n += 2 + sovAdmin(uint64(m.MetaRocksWalTTL))
	}
	if m.MetaDelEKRecordFileMaxMB != 0 {
		n += 2 + sovAdmin(uint64(m.MetaDelEKRecordFileMaxMB))
	}
	if m.MetaTrashCleanInterval != 0 {
		n += 2 + sovAdmin(uint64(m.MetaTrashCleanInterval))
	}
	if m.MetaRaftLogSize != 0 {
		n += 2 + sovAdmin(uint64(m.MetaRaftLogSize))
	}
	if m.MetaRaftLogCap != 0 {
		n += 2 + sovAdmin(uint64(m.MetaRaftLogCap))
	}
	if m.BitMapAllocatorMaxUsedFactor != 0 {
		n += 10
	}
	if m.BitMapAllocatorMinFreeFactor != 0 {
		n += 10
	}
	if m.DisableStrictVolZone {
		n += 3
	}
	if m.AutoUpdatePartitionReplicaNum {
		n += 3
	}
	if len(m.FlashNodes) > 0 {
		for _, e := range m.FlashNodes {
			l = e.Size()
			n += 2 + l + sovAdmin(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovAdmin(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAdmin(x uint64) (n int) {
	return sovAdmin(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DataPartitionResponsePb) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataPartitionResponsePb: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataPartitionResponsePb: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionID", wireType)
			}
			m.PartitionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartitionID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaNum", wireType)
			}
			m.ReplicaNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hosts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hosts = append(m.Hosts, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderAddr", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LeaderAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRecover", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRecover = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFrozen", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFrozen = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			m.CreateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediumType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MediumType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Used", wireType)
			}
			m.Used = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Used |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EcMigrateStatus", wireType)
			}
			m.EcMigrateStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EcMigrateStatus |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EcHosts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EcHosts = append(m.EcHosts, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EcDataNum", wireType)
			}
			m.EcDataNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EcDataNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EcMaxUnitSize", wireType)
			}
			m.EcMaxUnitSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EcMaxUnitSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataPartitionsViewPb) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataPartitionsViewPb: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataPartitionsViewPb: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataPartitions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataPartitions = append(m.DataPartitions, &DataPartitionResponsePb{})
			if err := m.DataPartitions[len(m.DataPartitions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetaPartitionViewPb) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetaPartitionViewPb: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetaPartitionViewPb: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionID", wireType)
			}
			m.PartitionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartitionID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxInodeID", wireType)
			}
			m.MaxInodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxInodeID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InodeCount", wireType)
			}
			m.InodeCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InodeCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DentryCount", wireType)
			}
			m.DentryCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DentryCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxExistIno", wireType)
			}
			m.MaxExistIno = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxExistIno |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRecover", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRecover = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = append(m.Members, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Learners", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Learners = append(m.Learners, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeaderAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreMode", wireType)
			}
			m.StoreMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreMode |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemCount", wireType)
			}
			m.MemCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RocksCount", wireType)
			}
			m.RocksCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RocksCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetaPartitionViewsPb) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetaPartitionViewsPb: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetaPartitionViewsPb: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaPartitions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetaPartitions = append(m.MetaPartitions, &MetaPartitionViewPb{})
			if err := m.MetaPartitions[len(m.MetaPartitions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EcPartitionResponsePb) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EcPartitionResponsePb: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EcPartitionResponsePb: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionID", wireType)
			}
			m.PartitionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartitionID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaNum", wireType)
			}
			m.ReplicaNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hosts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hosts = append(m.Hosts, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeaderAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataUnitsNum", wireType)
			}
			m.DataUnitsNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataUnitsNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParityUnitsNum", wireType)
			}
			m.ParityUnitsNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParityUnitsNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EcPartitionsViewPb) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EcPartitionsViewPb: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EcPartitionsViewPb: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EcPartitions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EcPartitions = append(m.EcPartitions, &EcPartitionResponsePb{})
			if err := m.EcPartitions[len(m.EcPartitions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OSSSecure) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OSSSecure: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OSSSecure: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecretKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdleTimeoutSec", wireType)
			}
			m.IdleTimeoutSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdleTimeoutSec |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectTimeoutNs", wireType)
			}
			m.ConnectTimeoutNs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnectTimeoutNs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteTimeoutNs", wireType)
			}
			m.WriteTimeoutNs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WriteTimeoutNs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadTimeoutNs", wireType)
			}
			m.ReadTimeoutNs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadTimeoutNs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VolViewPb) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VolViewPb: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VolViewPb: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FollowerRead", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FollowerRead = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceROW", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForceROW = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableWriteCache", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableWriteCache = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrossRegionHAType", wireType)
			}
			m.CrossRegionHAType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CrossRegionHAType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaPartitions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetaPartitions = append(m.MetaPartitions, &MetaPartitionViewPb{})
			if err := m.MetaPartitions[len(m.MetaPartitions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataPartitions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataPartitions = append(m.DataPartitions, &DataPartitionResponsePb{})
			if err := m.DataPartitions[len(m.DataPartitions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EcPartitions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EcPartitions = append(m.EcPartitions, &EcPartitionResponsePb{})
			if err := m.EcPartitions[len(m.EcPartitions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OSSSecure", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OSSSecure == nil {
				m.OSSSecure = &OSSSecure{}
			}
			if err := m.OSSSecure.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OSSBucketPolicy", wireType)
			}
			m.OSSBucketPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OSSBucketPolicy |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			m.CreateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConnConfig == nil {
				m.ConnConfig = &ConnConfig{}
			}
			if err := m.ConnConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSmart", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSmart = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SmartEnableTime", wireType)
			}
			m.SmartEnableTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SmartEnableTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SmartRules", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SmartRules = append(m.SmartRules, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HTTPReplyPb) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HTTPReplyPb: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HTTPReplyPb: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TokenPb) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TokenPb: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TokenPb: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenType", wireType)
			}
			m.TokenType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TokenType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DpMetricsReportConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DpMetricsReportConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DpMetricsReportConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableReport", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableReport = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportIntervalSec", wireType)
			}
			m.ReportIntervalSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReportIntervalSec |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FetchIntervalSec", wireType)
			}
			m.FetchIntervalSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FetchIntervalSec |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DpFollowerReadDelayConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DpFollowerReadDelayConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DpFollowerReadDelayConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableCollect", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableCollect = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelaySummaryInterval", wireType)
			}
			m.DelaySummaryInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DelaySummaryInterval |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetaPartitionLayout) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetaPartitionLayout: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetaPartitionLayout: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PercentOfMP", wireType)
			}
			m.PercentOfMP = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PercentOfMP |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PercentOfReplica", wireType)
			}
			m.PercentOfReplica = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PercentOfReplica |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimpleVolViewPb) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimpleVolViewPb: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimpleVolViewPb: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZoneName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ZoneName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DpReplicaNum", wireType)
			}
			m.DpReplicaNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DpReplicaNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MpReplicaNum", wireType)
			}
			m.MpReplicaNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MpReplicaNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DpLearnerNum", wireType)
			}
			m.DpLearnerNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DpLearnerNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MpLearnerNum", wireType)
			}
			m.MpLearnerNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MpLearnerNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InodeCount", wireType)
			}
			m.InodeCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InodeCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DentryCount", wireType)
			}
			m.DentryCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DentryCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMetaPartitionID", wireType)
			}
			m.MaxMetaPartitionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxMetaPartitionID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capacity", wireType)
			}
			m.Capacity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Capacity |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DpWriteableThreshold", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.DpWriteableThreshold = float64(math.Float64frombits(v))
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RwDpCnt", wireType)
			}
			m.RwDpCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RwDpCnt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MpCnt", wireType)
			}
			m.MpCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MpCnt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DpCnt", wireType)
			}
			m.DpCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DpCnt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FollowerRead", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FollowerRead = bool(v != 0)
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NearRead", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NearRead = bool(v != 0)
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedToLowerReplica", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedToLowerReplica = bool(v != 0)
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authenticate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Authenticate = bool(v != 0)
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolWriteMutexEnable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VolWriteMutexEnable = bool(v != 0)
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrossZone", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CrossZone = bool(v != 0)
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoRepair", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoRepair = bool(v != 0)
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreateTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableToken", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableToken = bool(v != 0)
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceROW", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForceROW = bool(v != 0)
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableWriteCache", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableWriteCache = bool(v != 0)
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrossRegionHAType", wireType)
			}
			m.CrossRegionHAType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CrossRegionHAType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tokens", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tokens == nil {
				m.Tokens = make(map[string]*TokenPb)
			}
			var mapkey string
			var mapvalue *TokenPb
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdmin
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdmin
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAdmin
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAdmin
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdmin
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthAdmin
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthAdmin
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &TokenPb{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAdmin(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAdmin
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tokens[mapkey] = mapvalue
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DpSelectorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DpSelectorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DpSelectorParm", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DpSelectorParm = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quorum", wireType)
			}
			m.Quorum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quorum |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OSSBucketPolicy", wireType)
			}
			m.OSSBucketPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OSSBucketPolicy |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DPConvertMode", wireType)
			}
			m.DPConvertMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DPConvertMode |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MPConvertMode", wireType)
			}
			m.MPConvertMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MPConvertMode |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MasterRegionZone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MasterRegionZone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlaveRegionZone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SlaveRegionZone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConnConfig == nil {
				m.ConnConfig = &ConnConfig{}
			}
			if err := m.ConnConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtentCacheExpireSec", wireType)
			}
			m.ExtentCacheExpireSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExtentCacheExpireSec |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DpMetricsReportConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DpMetricsReportConfig == nil {
				m.DpMetricsReportConfig = &DpMetricsReportConfig{}
			}
			if err := m.DpMetricsReportConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DpFolReadDelayConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DpFolReadDelayConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FolReadHostWeight", wireType)
			}
			m.FolReadHostWeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FolReadHostWeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 45:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RwMpCnt", wireType)
			}
			m.RwMpCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RwMpCnt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 46:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinWritableMPNum", wireType)
			}
			m.MinWritableMPNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinWritableMPNum |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 47:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinWritableDPNum", wireType)
			}
			m.MinWritableDPNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinWritableDPNum |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 48:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrashRemainingDays", wireType)
			}
			m.TrashRemainingDays = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrashRemainingDays |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 49:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultStoreMode", wireType)
			}
			m.DefaultStoreMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultStoreMode |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 50:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConvertState", wireType)
			}
			m.ConvertState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConvertState |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MpLayout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MpLayout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSizeGB", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalSizeGB = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 53:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedSizeGB", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UsedSizeGB = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 54:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSize", wireType)
			}
			m.TotalSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 55:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedSize", wireType)
			}
			m.UsedSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsedSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 56:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedRatio", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.UsedRatio = float64(math.Float64frombits(v))
		case 57:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileAvgSize", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.FileAvgSize = float64(math.Float64frombits(v))
		case 58:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateStatus", wireType)
			}
			m.CreateStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateStatus |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 59:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSmart", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSmart = bool(v != 0)
		case 60:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SmartEnableTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SmartEnableTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 61:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SmartRules", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SmartRules = append(m.SmartRules, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 62:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompactTag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CompactTag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 63:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompactTagModifyTime", wireType)
			}
			m.CompactTagModifyTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompactTagModifyTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 64:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EcEnable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EcEnable = bool(v != 0)
		case 65:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EcDataNum", wireType)
			}
			m.EcDataNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EcDataNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 66:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EcParityNum", wireType)
			}
			m.EcParityNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EcParityNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 67:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EcWaitTime", wireType)
			}
			m.EcWaitTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EcWaitTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 68:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EcSaveTime", wireType)
			}
			m.EcSaveTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EcSaveTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 69:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EcTimeOut", wireType)
			}
			m.EcTimeOut = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EcTimeOut |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 70:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EcRetryWait", wireType)
			}
			m.EcRetryWait = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EcRetryWait |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 71:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EcMaxUnitSize", wireType)
			}
			m.EcMaxUnitSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EcMaxUnitSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 72:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildFileMaxCount", wireType)
			}
			m.ChildFileMaxCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChildFileMaxCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 73:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrashCleanInterval", wireType)
			}
			m.TrashCleanInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrashCleanInterval |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 74:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchDelInodeCnt", wireType)
			}
			m.BatchDelInodeCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchDelInodeCnt |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 75:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelInodeInterval", wireType)
			}
			m.DelInodeInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DelInodeInterval |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 76:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UmpCollectWay", wireType)
			}
			m.UmpCollectWay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UmpCollectWay |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 77:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableBitMapAllocator", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableBitMapAllocator = bool(v != 0)
		case 78:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrashCleanDuration", wireType)
			}
			m.TrashCleanDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrashCleanDuration |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 79:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrashCleanMaxCount", wireType)
			}
			m.TrashCleanMaxCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrashCleanMaxCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 80:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewVolName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewVolName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 81:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewVolID", wireType)
			}
			m.NewVolID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewVolID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 82:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldVolName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OldVolName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 83:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalVolStatus", wireType)
			}
			m.FinalVolStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FinalVolStatus |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 84:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RenameConvertStatus", wireType)
			}
			m.RenameConvertStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RenameConvertStatus |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 85:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarkDeleteTime", wireType)
			}
			m.MarkDeleteTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarkDeleteTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 86:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteCacheBoostEnable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RemoteCacheBoostEnable = bool(v != 0)
		case 87:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteCacheBoostPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteCacheBoostPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 88:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteCacheAutoPrepare", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RemoteCacheAutoPrepare = bool(v != 0)
		case 89:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteCacheTTL", wireType)
			}
			m.RemoteCacheTTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemoteCacheTTL |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeStatInfoPb) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeStatInfoPb: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeStatInfoPb: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalGB", wireType)
			}
			m.TotalGB = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalGB |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedGB", wireType)
			}
			m.UsedGB = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsedGB |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncreasedGB", wireType)
			}
			m.IncreasedGB = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IncreasedGB |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UsedRatio = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalNodes", wireType)
			}
			m.TotalNodes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalNodes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WritableNodes", wireType)
			}
			m.WritableNodes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WritableNodes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighUsedRatioNodes", wireType)
			}
			m.HighUsedRatioNodes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HighUsedRatioNodes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BadPartitionView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BadPartitionView: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BadPartitionView: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionID", wireType)
			}
			m.PartitionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartitionID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeView: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeView: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsWritable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsWritable = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataNodeBadDisksView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataNodeBadDisksView: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataNodeBadDisksView: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadDiskPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadDiskPath = append(m.BadDiskPath, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterViewPb) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterViewPb: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterViewPb: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeaderAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableAutoAlloc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableAutoAlloc = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoMergeNodeSet", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoMergeNodeSet = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeSetCapacity", wireType)
			}
			m.NodeSetCapacity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeSetCapacity |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaNodeThreshold", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.MetaNodeThreshold = float32(math.Float32frombits(v))
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DpRecoverPool", wireType)
			}
			m.DpRecoverPool = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DpRecoverPool |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MpRecoverPool", wireType)
			}
			m.MpRecoverPool = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MpRecoverPool |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteMarkDelVolInterval", wireType)
			}
			m.DeleteMarkDelVolInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeleteMarkDelVolInterval |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Applied", wireType)
			}
			m.Applied = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Applied |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDataPartitionID", wireType)
			}
			m.MaxDataPartitionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxDataPartitionID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMetaNodeID", wireType)
			}
			m.MaxMetaNodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxMetaNodeID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMetaPartitionID", wireType)
			}
			m.MaxMetaPartitionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxMetaPartitionID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EcScrubEnable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EcScrubEnable = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EcMaxScrubExtents", wireType)
			}
			m.EcMaxScrubExtents = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EcMaxScrubExtents |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EcScrubPeriod", wireType)
			}
			m.EcScrubPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EcScrubPeriod |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EcScrubStartTime", wireType)
			}
			m.EcScrubStartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EcScrubStartTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxCodecConcurrent", wireType)
			}
			m.MaxCodecConcurrent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxCodecConcurrent |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolCount", wireType)
			}
			m.VolCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VolCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataNodeStatInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DataNodeStatInfo == nil {
				m.DataNodeStatInfo = &NodeStatInfoPb{}
			}
			if err := m.DataNodeStatInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaNodeStatInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MetaNodeStatInfo == nil {
				m.MetaNodeStatInfo = &NodeStatInfoPb{}
			}
			if err := m.MetaNodeStatInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EcNodeStatInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EcNodeStatInfo == nil {
				m.EcNodeStatInfo = &NodeStatInfoPb{}
			}
			if err := m.EcNodeStatInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadPartitionIDs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadPartitionIDs = append(m.BadPartitionIDs, BadPartitionView{})
			if err := m.BadPartitionIDs[len(m.BadPartitionIDs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadMetaPartitionIDs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadMetaPartitionIDs = append(m.BadMetaPartitionIDs, BadPartitionView{})
			if err := m.BadMetaPartitionIDs[len(m.BadMetaPartitionIDs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadEcPartitionIDs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadEcPartitionIDs = append(m.BadEcPartitionIDs, BadPartitionView{})
			if err := m.BadEcPartitionIDs[len(m.BadEcPartitionIDs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MigratedDataPartitions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MigratedDataPartitions = append(m.MigratedDataPartitions, BadPartitionView{})
			if err := m.MigratedDataPartitions[len(m.MigratedDataPartitions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MigratedMetaPartitions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MigratedMetaPartitions = append(m.MigratedMetaPartitions, BadPartitionView{})
			if err := m.MigratedMetaPartitions[len(m.MigratedMetaPartitions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaNodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetaNodes = append(m.MetaNodes, NodeView{})
			if err := m.MetaNodes[len(m.MetaNodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataNodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataNodes = append(m.DataNodes, NodeView{})
			if err := m.DataNodes[len(m.DataNodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CodEcnodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CodEcnodes = append(m.CodEcnodes, NodeView{})
			if err := m.CodEcnodes[len(m.CodEcnodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EcNodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EcNodes = append(m.EcNodes, NodeView{})
			if err := m.EcNodes[len(m.EcNodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataNodeBadDisks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataNodeBadDisks = append(m.DataNodeBadDisks, DataNodeBadDisksView{})
			if err := m.DataNodeBadDisks[len(m.DataNodeBadDisks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchedulerDomain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchedulerDomain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientPkgAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientPkgAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UmpJmtpAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UmpJmtpAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UmpJmtpBatch", wireType)
			}
			m.UmpJmtpBatch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UmpJmtpBatch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 37:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaNodeRocksdbDiskThreshold", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.MetaNodeRocksdbDiskThreshold = float32(math.Float32frombits(v))
		case 38:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaNodeMemModeRocksdbDiskThreshold", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.MetaNodeMemModeRocksdbDiskThreshold = float32(math.Float32frombits(v))
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RocksDBDiskReservedSpace", wireType)
			}
			m.RocksDBDiskReservedSpace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RocksDBDiskReservedSpace |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogMaxMB", wireType)
			}
			m.LogMaxMB = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogMaxMB |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaRockDBWalFileSize", wireType)
			}
			m.MetaRockDBWalFileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MetaRockDBWalFileSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaRocksWalMemSize", wireType)
			}
			m.MetaRocksWalMemSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MetaRocksWalMemSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 43:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaRocksLogSize", wireType)
			}
			m.MetaRocksLogSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MetaRocksLogSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaRocksLogReservedTime", wireType)
			}
			m.MetaRocksLogReservedTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MetaRocksLogReservedTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 45:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaRocksLogReservedCnt", wireType)
			}
			m.MetaRocksLogReservedCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MetaRocksLogReservedCnt |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 46:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaRocksFlushWalInterval", wireType)
			}
			m.MetaRocksFlushWalInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MetaRocksFlushWalInterval |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 47:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaRocksDisableFlushFlag", wireType)
			}
			m.MetaRocksDisableFlushFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MetaRocksDisableFlushFlag |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 48:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaRocksWalTTL", wireType)
			}
			m.MetaRocksWalTTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MetaRocksWalTTL |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 49:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaDelEKRecordFileMaxMB", wireType)
			}
			m.MetaDelEKRecordFileMaxMB = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MetaDelEKRecordFileMaxMB |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 50:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaTrashCleanInterval", wireType)
			}
			m.MetaTrashCleanInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MetaTrashCleanInterval |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 51:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaRaftLogSize", wireType)
			}
			m.MetaRaftLogSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MetaRaftLogSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 52:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaRaftLogCap", wireType)
			}
			m.MetaRaftLogCap = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MetaRaftLogCap |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 53:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BitMapAllocatorMaxUsedFactor", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.BitMapAllocatorMaxUsedFactor = float64(math.Float64frombits(v))
		case 54:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BitMapAllocatorMinFreeFactor", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.BitMapAllocatorMinFreeFactor = float64(math.Float64frombits(v))
		case 55:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableStrictVolZone", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableStrictVolZone = bool(v != 0)
		case 56:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoUpdatePartitionReplicaNum", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoUpdatePartitionReplicaNum = bool(v != 0)
		case 57:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlashNodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FlashNodes = append(m.FlashNodes, NodeView{})
			if err := m.FlashNodes[len(m.FlashNodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAdmin(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAdmin
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAdmin
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAdmin
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAdmin        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAdmin          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAdmin = fmt.Errorf("proto: unexpected end of group")
)
