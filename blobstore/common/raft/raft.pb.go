// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: raft.proto

package raft

import (
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	raftpb "go.etcd.io/etcd/raft/v3/raftpb"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = proto.Marshal
	_ = fmt.Errorf
	_ = math.Inf
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type MemberChangeType int32

const (
	MemberChangeType_AddMember    MemberChangeType = 0
	MemberChangeType_RemoveMember MemberChangeType = 1
)

var MemberChangeType_name = map[int32]string{
	0: "AddMember",
	1: "RemoveMember",
}

var MemberChangeType_value = map[string]int32{
	"AddMember":    0,
	"RemoveMember": 1,
}

func (x MemberChangeType) String() string {
	return proto.EnumName(MemberChangeType_name, int32(x))
}

func (MemberChangeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b042552c306ae59b, []int{0}
}

type RaftSnapshotHeader_SnapshotType int32

const (
	RaftSnapshotHeader_RECOVERY RaftSnapshotHeader_SnapshotType = 0
	RaftSnapshotHeader_BALANCE  RaftSnapshotHeader_SnapshotType = 1
)

var RaftSnapshotHeader_SnapshotType_name = map[int32]string{
	0: "RECOVERY",
	1: "BALANCE",
}

var RaftSnapshotHeader_SnapshotType_value = map[string]int32{
	"RECOVERY": 0,
	"BALANCE":  1,
}

func (x RaftSnapshotHeader_SnapshotType) String() string {
	return proto.EnumName(RaftSnapshotHeader_SnapshotType_name, int32(x))
}

func (RaftSnapshotHeader_SnapshotType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b042552c306ae59b, []int{7, 0}
}

type RaftSnapshotHeader_Strategy int32

const (
	RaftSnapshotHeader_KV_BATCH RaftSnapshotHeader_Strategy = 0
)

var RaftSnapshotHeader_Strategy_name = map[int32]string{
	0: "KV_BATCH",
}

var RaftSnapshotHeader_Strategy_value = map[string]int32{
	"KV_BATCH": 0,
}

func (x RaftSnapshotHeader_Strategy) String() string {
	return proto.EnumName(RaftSnapshotHeader_Strategy_name, int32(x))
}

func (RaftSnapshotHeader_Strategy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b042552c306ae59b, []int{7, 1}
}

type RaftSnapshotResponse_Status int32

const (
	RaftSnapshotResponse_UNKNOWN  RaftSnapshotResponse_Status = 0
	RaftSnapshotResponse_ACCEPTED RaftSnapshotResponse_Status = 1
	RaftSnapshotResponse_APPLIED  RaftSnapshotResponse_Status = 2
	RaftSnapshotResponse_ERROR    RaftSnapshotResponse_Status = 3
	RaftSnapshotResponse_DECLINED RaftSnapshotResponse_Status = 4
)

var RaftSnapshotResponse_Status_name = map[int32]string{
	0: "UNKNOWN",
	1: "ACCEPTED",
	2: "APPLIED",
	3: "ERROR",
	4: "DECLINED",
}

var RaftSnapshotResponse_Status_value = map[string]int32{
	"UNKNOWN":  0,
	"ACCEPTED": 1,
	"APPLIED":  2,
	"ERROR":    3,
	"DECLINED": 4,
}

func (x RaftSnapshotResponse_Status) String() string {
	return proto.EnumName(RaftSnapshotResponse_Status_name, int32(x))
}

func (RaftSnapshotResponse_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b042552c306ae59b, []int{9, 0}
}

type Error struct {
	ErrorCode            uint32   `protobuf:"varint,1,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`
	ErrorMsg             string   `protobuf:"bytes,2,opt,name=error_msg,json=errorMsg,proto3" json:"error_msg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Error) Reset()         { *m = Error{} }
func (m *Error) String() string { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()    {}
func (*Error) Descriptor() ([]byte, []int) {
	return fileDescriptor_b042552c306ae59b, []int{0}
}

func (m *Error) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}

func (m *Error) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Error.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}

func (m *Error) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Error.Merge(m, src)
}

func (m *Error) XXX_Size() int {
	return m.Size()
}

func (m *Error) XXX_DiscardUnknown() {
	xxx_messageInfo_Error.DiscardUnknown(m)
}

var xxx_messageInfo_Error proto.InternalMessageInfo

func (m *Error) GetErrorCode() uint32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

func (m *Error) GetErrorMsg() string {
	if m != nil {
		return m.ErrorMsg
	}
	return ""
}

type ProposalData struct {
	Module               []byte   `protobuf:"bytes,1,opt,name=module,proto3" json:"module,omitempty"`
	Op                   uint32   `protobuf:"varint,2,opt,name=op,proto3" json:"op,omitempty"`
	Data                 []byte   `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	Context              []byte   `protobuf:"bytes,4,opt,name=context,proto3" json:"context,omitempty"`
	notifyID             uint64   `protobuf:"varint,5,opt,name=notify_id,json=notifyId,proto3" json:"-"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProposalData) Reset()         { *m = ProposalData{} }
func (m *ProposalData) String() string { return proto.CompactTextString(m) }
func (*ProposalData) ProtoMessage()    {}
func (*ProposalData) Descriptor() ([]byte, []int) {
	return fileDescriptor_b042552c306ae59b, []int{1}
}

func (m *ProposalData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}

func (m *ProposalData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProposalData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}

func (m *ProposalData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProposalData.Merge(m, src)
}

func (m *ProposalData) XXX_Size() int {
	return m.Size()
}

func (m *ProposalData) XXX_DiscardUnknown() {
	xxx_messageInfo_ProposalData.DiscardUnknown(m)
}

var xxx_messageInfo_ProposalData proto.InternalMessageInfo

func (m *ProposalData) GetModule() []byte {
	if m != nil {
		return m.Module
	}
	return nil
}

func (m *ProposalData) GetOp() uint32 {
	if m != nil {
		return m.Op
	}
	return 0
}

func (m *ProposalData) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *ProposalData) GetContext() []byte {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *ProposalData) GetnotifyID() uint64 {
	if m != nil {
		return m.notifyID
	}
	return 0
}

type Member struct {
	NodeID               uint64           `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	Host                 string           `protobuf:"bytes,2,opt,name=host,proto3" json:"host,omitempty"`
	Type                 MemberChangeType `protobuf:"varint,3,opt,name=type,proto3,enum=inodedb.raft.MemberChangeType" json:"type,omitempty"`
	Learner              bool             `protobuf:"varint,4,opt,name=learner,proto3" json:"learner,omitempty"`
	Context              []byte           `protobuf:"bytes,5,opt,name=context,proto3" json:"context,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Member) Reset()         { *m = Member{} }
func (m *Member) String() string { return proto.CompactTextString(m) }
func (*Member) ProtoMessage()    {}
func (*Member) Descriptor() ([]byte, []int) {
	return fileDescriptor_b042552c306ae59b, []int{2}
}

func (m *Member) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}

func (m *Member) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Member.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}

func (m *Member) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Member.Merge(m, src)
}

func (m *Member) XXX_Size() int {
	return m.Size()
}

func (m *Member) XXX_DiscardUnknown() {
	xxx_messageInfo_Member.DiscardUnknown(m)
}

var xxx_messageInfo_Member proto.InternalMessageInfo

func (m *Member) GetNodeID() uint64 {
	if m != nil {
		return m.NodeID
	}
	return 0
}

func (m *Member) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *Member) GetType() MemberChangeType {
	if m != nil {
		return m.Type
	}
	return MemberChangeType_AddMember
}

func (m *Member) GetLearner() bool {
	if m != nil {
		return m.Learner
	}
	return false
}

func (m *Member) GetContext() []byte {
	if m != nil {
		return m.Context
	}
	return nil
}

type RaftHeartbeat struct {
	GroupID              uint64   `protobuf:"varint,1,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	From                 uint64   `protobuf:"varint,2,opt,name=from,proto3" json:"from,omitempty"`
	To                   uint64   `protobuf:"varint,3,opt,name=to,proto3" json:"to,omitempty"`
	Term                 uint64   `protobuf:"varint,4,opt,name=term,proto3" json:"term,omitempty"`
	Commit               uint64   `protobuf:"varint,5,opt,name=commit,proto3" json:"commit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RaftHeartbeat) Reset()         { *m = RaftHeartbeat{} }
func (m *RaftHeartbeat) String() string { return proto.CompactTextString(m) }
func (*RaftHeartbeat) ProtoMessage()    {}
func (*RaftHeartbeat) Descriptor() ([]byte, []int) {
	return fileDescriptor_b042552c306ae59b, []int{3}
}

func (m *RaftHeartbeat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}

func (m *RaftHeartbeat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftHeartbeat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}

func (m *RaftHeartbeat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftHeartbeat.Merge(m, src)
}

func (m *RaftHeartbeat) XXX_Size() int {
	return m.Size()
}

func (m *RaftHeartbeat) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftHeartbeat.DiscardUnknown(m)
}

var xxx_messageInfo_RaftHeartbeat proto.InternalMessageInfo

func (m *RaftHeartbeat) GetGroupID() uint64 {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func (m *RaftHeartbeat) GetFrom() uint64 {
	if m != nil {
		return m.From
	}
	return 0
}

func (m *RaftHeartbeat) GetTo() uint64 {
	if m != nil {
		return m.To
	}
	return 0
}

func (m *RaftHeartbeat) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *RaftHeartbeat) GetCommit() uint64 {
	if m != nil {
		return m.Commit
	}
	return 0
}

type RaftMessageRequest struct {
	GroupID              uint64          `protobuf:"varint,1,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	From                 uint64          `protobuf:"varint,2,opt,name=from,proto3" json:"from,omitempty"`
	To                   uint64          `protobuf:"varint,3,opt,name=to,proto3" json:"to,omitempty"`
	Message              raftpb.Message  `protobuf:"bytes,4,opt,name=message,proto3" json:"message"`
	Heartbeats           []RaftHeartbeat `protobuf:"bytes,5,rep,name=heartbeats,proto3" json:"heartbeats"`
	HeartbeatResponses   []RaftHeartbeat `protobuf:"bytes,6,rep,name=heartbeat_responses,json=heartbeatResponses,proto3" json:"heartbeat_responses"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *RaftMessageRequest) Reset()         { *m = RaftMessageRequest{} }
func (m *RaftMessageRequest) String() string { return proto.CompactTextString(m) }
func (*RaftMessageRequest) ProtoMessage()    {}
func (*RaftMessageRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b042552c306ae59b, []int{4}
}

func (m *RaftMessageRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}

func (m *RaftMessageRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftMessageRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}

func (m *RaftMessageRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftMessageRequest.Merge(m, src)
}

func (m *RaftMessageRequest) XXX_Size() int {
	return m.Size()
}

func (m *RaftMessageRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftMessageRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RaftMessageRequest proto.InternalMessageInfo

func (m *RaftMessageRequest) GetGroupID() uint64 {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func (m *RaftMessageRequest) GetFrom() uint64 {
	if m != nil {
		return m.From
	}
	return 0
}

func (m *RaftMessageRequest) GetTo() uint64 {
	if m != nil {
		return m.To
	}
	return 0
}

func (m *RaftMessageRequest) GetMessage() raftpb.Message {
	if m != nil {
		return m.Message
	}
	return raftpb.Message{}
}

func (m *RaftMessageRequest) GetHeartbeats() []RaftHeartbeat {
	if m != nil {
		return m.Heartbeats
	}
	return nil
}

func (m *RaftMessageRequest) GetHeartbeatResponses() []RaftHeartbeat {
	if m != nil {
		return m.HeartbeatResponses
	}
	return nil
}

type RaftMessageResponse struct {
	GroupID              uint64   `protobuf:"varint,1,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	From                 uint64   `protobuf:"varint,2,opt,name=from,proto3" json:"from,omitempty"`
	To                   uint64   `protobuf:"varint,3,opt,name=to,proto3" json:"to,omitempty"`
	Err                  *Error   `protobuf:"bytes,4,opt,name=err,proto3" json:"err,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RaftMessageResponse) Reset()         { *m = RaftMessageResponse{} }
func (m *RaftMessageResponse) String() string { return proto.CompactTextString(m) }
func (*RaftMessageResponse) ProtoMessage()    {}
func (*RaftMessageResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b042552c306ae59b, []int{5}
}

func (m *RaftMessageResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}

func (m *RaftMessageResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftMessageResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}

func (m *RaftMessageResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftMessageResponse.Merge(m, src)
}

func (m *RaftMessageResponse) XXX_Size() int {
	return m.Size()
}

func (m *RaftMessageResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftMessageResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RaftMessageResponse proto.InternalMessageInfo

func (m *RaftMessageResponse) GetGroupID() uint64 {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func (m *RaftMessageResponse) GetFrom() uint64 {
	if m != nil {
		return m.From
	}
	return 0
}

func (m *RaftMessageResponse) GetTo() uint64 {
	if m != nil {
		return m.To
	}
	return 0
}

func (m *RaftMessageResponse) GetErr() *Error {
	if m != nil {
		return m.Err
	}
	return nil
}

type RaftMessageRequestBatch struct {
	Requests             []RaftMessageRequest `protobuf:"bytes,1,rep,name=requests,proto3" json:"requests"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *RaftMessageRequestBatch) Reset()         { *m = RaftMessageRequestBatch{} }
func (m *RaftMessageRequestBatch) String() string { return proto.CompactTextString(m) }
func (*RaftMessageRequestBatch) ProtoMessage()    {}
func (*RaftMessageRequestBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_b042552c306ae59b, []int{6}
}

func (m *RaftMessageRequestBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}

func (m *RaftMessageRequestBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftMessageRequestBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}

func (m *RaftMessageRequestBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftMessageRequestBatch.Merge(m, src)
}

func (m *RaftMessageRequestBatch) XXX_Size() int {
	return m.Size()
}

func (m *RaftMessageRequestBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftMessageRequestBatch.DiscardUnknown(m)
}

var xxx_messageInfo_RaftMessageRequestBatch proto.InternalMessageInfo

func (m *RaftMessageRequestBatch) GetRequests() []RaftMessageRequest {
	if m != nil {
		return m.Requests
	}
	return nil
}

type RaftSnapshotHeader struct {
	ID                   string                          `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Type                 RaftSnapshotHeader_SnapshotType `protobuf:"varint,2,opt,name=type,proto3,enum=inodedb.raft.RaftSnapshotHeader_SnapshotType" json:"type,omitempty"`
	Strategy             RaftSnapshotHeader_Strategy     `protobuf:"varint,3,opt,name=strategy,proto3,enum=inodedb.raft.RaftSnapshotHeader_Strategy" json:"strategy,omitempty"`
	RaftMessageRequest   *RaftMessageRequest             `protobuf:"bytes,4,opt,name=raft_message_request,json=raftMessageRequest,proto3" json:"raft_message_request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                        `json:"-"`
	XXX_unrecognized     []byte                          `json:"-"`
	XXX_sizecache        int32                           `json:"-"`
}

func (m *RaftSnapshotHeader) Reset()         { *m = RaftSnapshotHeader{} }
func (m *RaftSnapshotHeader) String() string { return proto.CompactTextString(m) }
func (*RaftSnapshotHeader) ProtoMessage()    {}
func (*RaftSnapshotHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_b042552c306ae59b, []int{7}
}

func (m *RaftSnapshotHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}

func (m *RaftSnapshotHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftSnapshotHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}

func (m *RaftSnapshotHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftSnapshotHeader.Merge(m, src)
}

func (m *RaftSnapshotHeader) XXX_Size() int {
	return m.Size()
}

func (m *RaftSnapshotHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftSnapshotHeader.DiscardUnknown(m)
}

var xxx_messageInfo_RaftSnapshotHeader proto.InternalMessageInfo

func (m *RaftSnapshotHeader) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *RaftSnapshotHeader) GetType() RaftSnapshotHeader_SnapshotType {
	if m != nil {
		return m.Type
	}
	return RaftSnapshotHeader_RECOVERY
}

func (m *RaftSnapshotHeader) GetStrategy() RaftSnapshotHeader_Strategy {
	if m != nil {
		return m.Strategy
	}
	return RaftSnapshotHeader_KV_BATCH
}

func (m *RaftSnapshotHeader) GetRaftMessageRequest() *RaftMessageRequest {
	if m != nil {
		return m.RaftMessageRequest
	}
	return nil
}

type RaftSnapshotRequest struct {
	Header               *RaftSnapshotHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	Seq                  uint32              `protobuf:"varint,2,opt,name=seq,proto3" json:"seq,omitempty"`
	Final                bool                `protobuf:"varint,3,opt,name=final,proto3" json:"final,omitempty"`
	Data                 []byte              `protobuf:"bytes,4,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *RaftSnapshotRequest) Reset()         { *m = RaftSnapshotRequest{} }
func (m *RaftSnapshotRequest) String() string { return proto.CompactTextString(m) }
func (*RaftSnapshotRequest) ProtoMessage()    {}
func (*RaftSnapshotRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b042552c306ae59b, []int{8}
}

func (m *RaftSnapshotRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}

func (m *RaftSnapshotRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftSnapshotRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}

func (m *RaftSnapshotRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftSnapshotRequest.Merge(m, src)
}

func (m *RaftSnapshotRequest) XXX_Size() int {
	return m.Size()
}

func (m *RaftSnapshotRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftSnapshotRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RaftSnapshotRequest proto.InternalMessageInfo

func (m *RaftSnapshotRequest) GetHeader() *RaftSnapshotHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *RaftSnapshotRequest) GetSeq() uint32 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *RaftSnapshotRequest) GetFinal() bool {
	if m != nil {
		return m.Final
	}
	return false
}

func (m *RaftSnapshotRequest) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type RaftSnapshotResponse struct {
	Status               RaftSnapshotResponse_Status `protobuf:"varint,1,opt,name=status,proto3,enum=inodedb.raft.RaftSnapshotResponse_Status" json:"status,omitempty"`
	Message              string                      `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *RaftSnapshotResponse) Reset()         { *m = RaftSnapshotResponse{} }
func (m *RaftSnapshotResponse) String() string { return proto.CompactTextString(m) }
func (*RaftSnapshotResponse) ProtoMessage()    {}
func (*RaftSnapshotResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b042552c306ae59b, []int{9}
}

func (m *RaftSnapshotResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}

func (m *RaftSnapshotResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftSnapshotResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}

func (m *RaftSnapshotResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftSnapshotResponse.Merge(m, src)
}

func (m *RaftSnapshotResponse) XXX_Size() int {
	return m.Size()
}

func (m *RaftSnapshotResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftSnapshotResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RaftSnapshotResponse proto.InternalMessageInfo

func (m *RaftSnapshotResponse) GetStatus() RaftSnapshotResponse_Status {
	if m != nil {
		return m.Status
	}
	return RaftSnapshotResponse_UNKNOWN
}

func (m *RaftSnapshotResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func init() {
	proto.RegisterEnum("inodedb.raft.MemberChangeType", MemberChangeType_name, MemberChangeType_value)
	proto.RegisterEnum("inodedb.raft.RaftSnapshotHeader_SnapshotType", RaftSnapshotHeader_SnapshotType_name, RaftSnapshotHeader_SnapshotType_value)
	proto.RegisterEnum("inodedb.raft.RaftSnapshotHeader_Strategy", RaftSnapshotHeader_Strategy_name, RaftSnapshotHeader_Strategy_value)
	proto.RegisterEnum("inodedb.raft.RaftSnapshotResponse_Status", RaftSnapshotResponse_Status_name, RaftSnapshotResponse_Status_value)
	proto.RegisterType((*Error)(nil), "inodedb.raft.Error")
	proto.RegisterType((*ProposalData)(nil), "inodedb.raft.ProposalData")
	proto.RegisterType((*Member)(nil), "inodedb.raft.Member")
	proto.RegisterType((*RaftHeartbeat)(nil), "inodedb.raft.RaftHeartbeat")
	proto.RegisterType((*RaftMessageRequest)(nil), "inodedb.raft.RaftMessageRequest")
	proto.RegisterType((*RaftMessageResponse)(nil), "inodedb.raft.RaftMessageResponse")
	proto.RegisterType((*RaftMessageRequestBatch)(nil), "inodedb.raft.RaftMessageRequestBatch")
	proto.RegisterType((*RaftSnapshotHeader)(nil), "inodedb.raft.RaftSnapshotHeader")
	proto.RegisterType((*RaftSnapshotRequest)(nil), "inodedb.raft.RaftSnapshotRequest")
	proto.RegisterType((*RaftSnapshotResponse)(nil), "inodedb.raft.RaftSnapshotResponse")
}

func init() { proto.RegisterFile("raft.proto", fileDescriptor_b042552c306ae59b) }

var fileDescriptor_b042552c306ae59b = []byte{
	// 889 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x55, 0xdd, 0x6e, 0xe3, 0x44,
	0x14, 0xce, 0x38, 0x8e, 0xe3, 0x9c, 0xa6, 0x8b, 0x77, 0x5a, 0x16, 0x6b, 0x57, 0x34, 0x91, 0x91,
	0x50, 0x17, 0xb4, 0xae, 0xd4, 0xbd, 0x41, 0xe2, 0x2a, 0xb1, 0x2d, 0x36, 0x6c, 0x9b, 0x56, 0xb3,
	0x65, 0x11, 0x48, 0x28, 0x72, 0xea, 0xc9, 0x8f, 0x54, 0x67, 0xbc, 0x33, 0x53, 0x44, 0x9f, 0x01,
	0xc1, 0x15, 0x0f, 0x01, 0x2f, 0xc1, 0xf5, 0xde, 0xc1, 0x13, 0x44, 0x28, 0x97, 0x3c, 0x05, 0x9a,
	0xf1, 0x38, 0x4d, 0xb6, 0x88, 0xe5, 0x62, 0x6f, 0xa2, 0x73, 0xce, 0x9c, 0x6f, 0xfc, 0x7d, 0xdf,
	0xcc, 0x99, 0x00, 0xf0, 0x74, 0x22, 0xc3, 0x82, 0x33, 0xc9, 0x70, 0x7b, 0xbe, 0x60, 0x19, 0xcd,
	0xc6, 0xa1, 0xaa, 0x3d, 0xbc, 0xaf, 0x7e, 0x8b, 0xf1, 0xd1, 0x6d, 0xc3, 0xc3, 0xfd, 0x29, 0x9b,
	0x32, 0x1d, 0x1e, 0xa9, 0xa8, 0xac, 0x06, 0x11, 0x34, 0x12, 0xce, 0x19, 0xc7, 0x1f, 0x02, 0x50,
	0x15, 0x8c, 0x2e, 0x59, 0x46, 0x7d, 0xd4, 0x45, 0x87, 0xbb, 0xa4, 0xa5, 0x2b, 0x11, 0xcb, 0x28,
	0x7e, 0x04, 0x65, 0x32, 0xca, 0xc5, 0xd4, 0xb7, 0xba, 0xe8, 0xb0, 0x45, 0x5c, 0x5d, 0x38, 0x15,
	0xd3, 0xe0, 0x17, 0x04, 0xed, 0x73, 0xce, 0x0a, 0x26, 0xd2, 0xab, 0x38, 0x95, 0x29, 0x7e, 0x00,
	0x4e, 0xce, 0xb2, 0xeb, 0xab, 0x72, 0xa3, 0x36, 0x31, 0x19, 0xbe, 0x07, 0x16, 0x2b, 0x34, 0x7c,
	0x97, 0x58, 0xac, 0xc0, 0x18, 0xec, 0x2c, 0x95, 0xa9, 0x5f, 0xd7, 0x5d, 0x3a, 0xc6, 0x3e, 0x34,
	0x2f, 0xd9, 0x42, 0xd2, 0x1f, 0xa4, 0x6f, 0xeb, 0x72, 0x95, 0xe2, 0x10, 0x5a, 0x0b, 0x26, 0xe7,
	0x93, 0x9b, 0xd1, 0x3c, 0xf3, 0x1b, 0x5d, 0x74, 0x68, 0xf7, 0xef, 0xaf, 0x96, 0x1d, 0xb7, 0x2c,
	0x0e, 0xe2, 0xbf, 0x97, 0x1d, 0xf4, 0x84, 0x54, 0x69, 0x16, 0xfc, 0x86, 0xc0, 0x39, 0xa5, 0xf9,
	0x98, 0x72, 0xfc, 0x11, 0x34, 0x95, 0x3d, 0x0a, 0x88, 0x34, 0x10, 0x56, 0xcb, 0x8e, 0x33, 0x64,
	0x19, 0x1d, 0xc4, 0xc4, 0x51, 0x4b, 0x83, 0x4c, 0xb1, 0x99, 0x31, 0x21, 0x8d, 0x3c, 0x1d, 0xe3,
	0x63, 0xb0, 0xe5, 0x4d, 0x41, 0x35, 0xc3, 0x7b, 0xc7, 0x07, 0xe1, 0xa6, 0xcb, 0x61, 0xb9, 0x79,
	0x34, 0x4b, 0x17, 0x53, 0x7a, 0x71, 0x53, 0x50, 0xa2, 0x7b, 0x95, 0x82, 0x2b, 0x9a, 0xf2, 0x05,
	0xe5, 0x5a, 0x81, 0x4b, 0xaa, 0x74, 0x53, 0x5b, 0x63, 0x4b, 0x5b, 0xf0, 0x13, 0x82, 0x5d, 0x92,
	0x4e, 0xe4, 0x33, 0x9a, 0x72, 0x39, 0xa6, 0xa9, 0xc4, 0x1f, 0x83, 0x3b, 0xe5, 0xec, 0xba, 0xb8,
	0xe5, 0xbc, 0xb3, 0x5a, 0x76, 0x9a, 0x5f, 0xa8, 0xda, 0x20, 0x26, 0x4d, 0xbd, 0x58, 0xb2, 0x9e,
	0x70, 0x96, 0x6b, 0xd6, 0x36, 0xd1, 0xb1, 0xf2, 0x59, 0x32, 0xcd, 0xd9, 0x26, 0x96, 0x64, 0xaa,
	0x47, 0x52, 0x9e, 0x6b, 0x3a, 0x36, 0xd1, 0xb1, 0x3a, 0xa3, 0x4b, 0x96, 0xe7, 0xf3, 0x92, 0x8a,
	0x4d, 0x4c, 0xf6, 0xa5, 0xed, 0x3a, 0x5e, 0x33, 0xf8, 0xd5, 0x02, 0xac, 0xf8, 0x9c, 0x52, 0x21,
	0xd2, 0x29, 0x25, 0xf4, 0xd5, 0x35, 0x15, 0xef, 0x96, 0xd4, 0x11, 0x34, 0xf3, 0x72, 0x77, 0xcd,
	0x6b, 0xe7, 0xf8, 0xbd, 0xb0, 0xbc, 0xb5, 0xa1, 0xf9, 0x68, 0xdf, 0x7e, 0xbd, 0xec, 0xd4, 0x48,
	0xd5, 0x85, 0x7b, 0x00, 0xb3, 0xca, 0x1e, 0xe1, 0x37, 0xba, 0xf5, 0xc3, 0x9d, 0xe3, 0x47, 0xdb,
	0x27, 0xb2, 0x65, 0xa1, 0xc1, 0x6f, 0x80, 0x30, 0x81, 0xbd, 0x75, 0x36, 0xe2, 0x54, 0x14, 0x6c,
	0x21, 0xa8, 0xf0, 0x9d, 0xff, 0xbb, 0x17, 0x5e, 0xa3, 0x49, 0x05, 0x0e, 0x7e, 0x46, 0xb0, 0xb7,
	0x65, 0x55, 0xb9, 0xf0, 0x4e, 0xbd, 0xfa, 0x14, 0xea, 0x94, 0x73, 0xe3, 0xd3, 0xde, 0x36, 0x4f,
	0x3d, 0xbf, 0x9a, 0x1f, 0x22, 0xaa, 0x2b, 0xf8, 0x0e, 0x3e, 0xb8, 0x7b, 0x74, 0xfd, 0x54, 0x5e,
	0xce, 0x70, 0x1f, 0x5c, 0x5e, 0xe6, 0xc2, 0x47, 0x5a, 0x74, 0xf7, 0xae, 0xe8, 0x37, 0x80, 0xa5,
	0xf2, 0x35, 0x2e, 0xf8, 0xc3, 0x5c, 0x8d, 0x17, 0x8b, 0xb4, 0x10, 0x33, 0xa6, 0x3c, 0xca, 0x28,
	0xc7, 0x0f, 0xc0, 0x32, 0x42, 0x5b, 0x7d, 0x67, 0xb5, 0xec, 0x58, 0x83, 0x98, 0x58, 0xf3, 0x0c,
	0xf7, 0xcc, 0x04, 0x59, 0x7a, 0x82, 0x9e, 0xdc, 0xfd, 0xdc, 0xf6, 0x3e, 0x61, 0x95, 0x6e, 0x0c,
	0x54, 0x02, 0xae, 0x90, 0x3c, 0x95, 0x74, 0x7a, 0x63, 0x06, 0xf1, 0xf1, 0xdb, 0xb7, 0x31, 0x00,
	0xb2, 0x86, 0x62, 0x02, 0xfb, 0xaa, 0x7b, 0x64, 0xee, 0xd3, 0xc8, 0x28, 0x32, 0xae, 0xbe, 0xd5,
	0x08, 0x82, 0xf9, 0x9d, 0x5a, 0xf0, 0x18, 0xda, 0x9b, 0x84, 0x71, 0x1b, 0x5c, 0x92, 0x44, 0x67,
	0x2f, 0x13, 0xf2, 0x8d, 0x57, 0xc3, 0x3b, 0xd0, 0xec, 0xf7, 0x4e, 0x7a, 0xc3, 0x28, 0xf1, 0x50,
	0xe0, 0x83, 0x5b, 0x91, 0x52, 0x6d, 0xcf, 0x5f, 0x8e, 0xfa, 0xbd, 0x8b, 0xe8, 0x99, 0x57, 0x0b,
	0x7e, 0x34, 0x37, 0xa8, 0xda, 0xa9, 0x9a, 0xb6, 0xcf, 0xc0, 0x99, 0x69, 0x35, 0xda, 0xd6, 0x7f,
	0xa5, 0xb8, 0xad, 0x9a, 0x98, 0x7e, 0xec, 0x41, 0x5d, 0xd0, 0x57, 0xe6, 0xa5, 0x55, 0x21, 0xde,
	0x87, 0xc6, 0x64, 0xbe, 0x48, 0xaf, 0xb4, 0x81, 0x2e, 0x29, 0x93, 0xf5, 0x03, 0x6c, 0xdf, 0x3e,
	0xc0, 0xc1, 0xef, 0x08, 0xf6, 0xb7, 0xd9, 0x98, 0x0b, 0xdd, 0x03, 0x47, 0xc8, 0x54, 0x5e, 0x0b,
	0x4d, 0xe7, 0x3f, 0x0f, 0xa1, 0xc2, 0x84, 0x2f, 0x34, 0x80, 0x18, 0xa0, 0x7a, 0x00, 0xab, 0x99,
	0x2f, 0x5f, 0xd9, 0x2a, 0x0d, 0x06, 0xe0, 0x94, 0xbd, 0xca, 0xb4, 0xaf, 0x86, 0xcf, 0x87, 0x67,
	0x5f, 0x0f, 0xbd, 0x9a, 0x32, 0xaa, 0x17, 0x45, 0xc9, 0xf9, 0x45, 0x12, 0x7b, 0x48, 0x2d, 0xf5,
	0xce, 0xcf, 0x4f, 0x06, 0x49, 0xec, 0x59, 0xb8, 0x05, 0x8d, 0x84, 0x90, 0x33, 0xe2, 0xd5, 0x55,
	0x57, 0x9c, 0x44, 0x27, 0x83, 0x61, 0x12, 0x7b, 0xf6, 0x27, 0x4f, 0xc1, 0x7b, 0xf3, 0x65, 0xc6,
	0xbb, 0xd0, 0xea, 0x65, 0x59, 0x59, 0xf6, 0x6a, 0xd8, 0x83, 0x36, 0xa1, 0x39, 0xfb, 0x9e, 0x9a,
	0x0a, 0xea, 0xbf, 0xff, 0x7a, 0x75, 0x80, 0xfe, 0x5c, 0x1d, 0xa0, 0xbf, 0x56, 0x07, 0xe8, 0xdb,
	0x66, 0x78, 0xf4, 0xb9, 0x12, 0x35, 0x76, 0xf4, 0xdf, 0xe4, 0xd3, 0x7f, 0x02, 0x00, 0x00, 0xff,
	0xff, 0xb8, 0xc8, 0x7b, 0xcf, 0x6b, 0x07, 0x00, 0x00,
}

func (m *Error) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Error) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Error) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ErrorMsg) > 0 {
		i -= len(m.ErrorMsg)
		copy(dAtA[i:], m.ErrorMsg)
		i = encodeVarintRaft(dAtA, i, uint64(len(m.ErrorMsg)))
		i--
		dAtA[i] = 0x12
	}
	if m.ErrorCode != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.ErrorCode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProposalData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProposalData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.notifyID != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.notifyID))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Context) > 0 {
		i -= len(m.Context)
		copy(dAtA[i:], m.Context)
		i = encodeVarintRaft(dAtA, i, uint64(len(m.Context)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintRaft(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Op != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Module) > 0 {
		i -= len(m.Module)
		copy(dAtA[i:], m.Module)
		i = encodeVarintRaft(dAtA, i, uint64(len(m.Module)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Member) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Member) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Member) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Context) > 0 {
		i -= len(m.Context)
		copy(dAtA[i:], m.Context)
		i = encodeVarintRaft(dAtA, i, uint64(len(m.Context)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Learner {
		i--
		if m.Learner {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Type != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Host) > 0 {
		i -= len(m.Host)
		copy(dAtA[i:], m.Host)
		i = encodeVarintRaft(dAtA, i, uint64(len(m.Host)))
		i--
		dAtA[i] = 0x12
	}
	if m.NodeID != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.NodeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RaftHeartbeat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftHeartbeat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftHeartbeat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Commit != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Commit))
		i--
		dAtA[i] = 0x28
	}
	if m.Term != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x20
	}
	if m.To != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.To))
		i--
		dAtA[i] = 0x18
	}
	if m.From != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.From))
		i--
		dAtA[i] = 0x10
	}
	if m.GroupID != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.GroupID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RaftMessageRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftMessageRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftMessageRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.HeartbeatResponses) > 0 {
		for iNdEx := len(m.HeartbeatResponses) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.HeartbeatResponses[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRaft(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Heartbeats) > 0 {
		for iNdEx := len(m.Heartbeats) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Heartbeats[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRaft(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	{
		size, err := m.Message.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRaft(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.To != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.To))
		i--
		dAtA[i] = 0x18
	}
	if m.From != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.From))
		i--
		dAtA[i] = 0x10
	}
	if m.GroupID != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.GroupID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RaftMessageResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftMessageResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftMessageResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.To != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.To))
		i--
		dAtA[i] = 0x18
	}
	if m.From != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.From))
		i--
		dAtA[i] = 0x10
	}
	if m.GroupID != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.GroupID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RaftMessageRequestBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftMessageRequestBatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftMessageRequestBatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Requests) > 0 {
		for iNdEx := len(m.Requests) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Requests[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRaft(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RaftSnapshotHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftSnapshotHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftSnapshotHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RaftMessageRequest != nil {
		{
			size, err := m.RaftMessageRequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Strategy != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Strategy))
		i--
		dAtA[i] = 0x18
	}
	if m.Type != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintRaft(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RaftSnapshotRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftSnapshotRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftSnapshotRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintRaft(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x22
	}
	if m.Final {
		i--
		if m.Final {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Seq != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x10
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RaftSnapshotResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftSnapshotResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftSnapshotResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintRaft(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintRaft(dAtA []byte, offset int, v uint64) int {
	offset -= sovRaft(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}

func (m *Error) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovRaft(uint64(m.ErrorCode))
	}
	l = len(m.ErrorMsg)
	if l > 0 {
		n += 1 + l + sovRaft(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProposalData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Module)
	if l > 0 {
		n += 1 + l + sovRaft(uint64(l))
	}
	if m.Op != 0 {
		n += 1 + sovRaft(uint64(m.Op))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRaft(uint64(l))
	}
	l = len(m.Context)
	if l > 0 {
		n += 1 + l + sovRaft(uint64(l))
	}
	if m.notifyID != 0 {
		n += 1 + sovRaft(uint64(m.notifyID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Member) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeID != 0 {
		n += 1 + sovRaft(uint64(m.NodeID))
	}
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovRaft(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovRaft(uint64(m.Type))
	}
	if m.Learner {
		n += 2
	}
	l = len(m.Context)
	if l > 0 {
		n += 1 + l + sovRaft(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RaftHeartbeat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupID != 0 {
		n += 1 + sovRaft(uint64(m.GroupID))
	}
	if m.From != 0 {
		n += 1 + sovRaft(uint64(m.From))
	}
	if m.To != 0 {
		n += 1 + sovRaft(uint64(m.To))
	}
	if m.Term != 0 {
		n += 1 + sovRaft(uint64(m.Term))
	}
	if m.Commit != 0 {
		n += 1 + sovRaft(uint64(m.Commit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RaftMessageRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupID != 0 {
		n += 1 + sovRaft(uint64(m.GroupID))
	}
	if m.From != 0 {
		n += 1 + sovRaft(uint64(m.From))
	}
	if m.To != 0 {
		n += 1 + sovRaft(uint64(m.To))
	}
	l = m.Message.Size()
	n += 1 + l + sovRaft(uint64(l))
	if len(m.Heartbeats) > 0 {
		for _, e := range m.Heartbeats {
			l = e.Size()
			n += 1 + l + sovRaft(uint64(l))
		}
	}
	if len(m.HeartbeatResponses) > 0 {
		for _, e := range m.HeartbeatResponses {
			l = e.Size()
			n += 1 + l + sovRaft(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RaftMessageResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupID != 0 {
		n += 1 + sovRaft(uint64(m.GroupID))
	}
	if m.From != 0 {
		n += 1 + sovRaft(uint64(m.From))
	}
	if m.To != 0 {
		n += 1 + sovRaft(uint64(m.To))
	}
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovRaft(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RaftMessageRequestBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Requests) > 0 {
		for _, e := range m.Requests {
			l = e.Size()
			n += 1 + l + sovRaft(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RaftSnapshotHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovRaft(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovRaft(uint64(m.Type))
	}
	if m.Strategy != 0 {
		n += 1 + sovRaft(uint64(m.Strategy))
	}
	if m.RaftMessageRequest != nil {
		l = m.RaftMessageRequest.Size()
		n += 1 + l + sovRaft(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RaftSnapshotRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovRaft(uint64(l))
	}
	if m.Seq != 0 {
		n += 1 + sovRaft(uint64(m.Seq))
	}
	if m.Final {
		n += 2
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRaft(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RaftSnapshotResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovRaft(uint64(m.Status))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovRaft(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovRaft(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}

func sozRaft(x uint64) (n int) {
	return sovRaft(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}

func (m *Error) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Error: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Error: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func (m *ProposalData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProposalData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProposalData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Module", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Module = append(m.Module[:0], dAtA[iNdEx:postIndex]...)
			if m.Module == nil {
				m.Module = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Context = append(m.Context[:0], dAtA[iNdEx:postIndex]...)
			if m.Context == nil {
				m.Context = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field notifyID", wireType)
			}
			m.notifyID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.notifyID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func (m *Member) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Member: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Member: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= MemberChangeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Learner", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Learner = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Context = append(m.Context[:0], dAtA[iNdEx:postIndex]...)
			if m.Context == nil {
				m.Context = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func (m *RaftHeartbeat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftHeartbeat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftHeartbeat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.From |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			m.To = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.To |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			m.Commit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Commit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func (m *RaftMessageRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftMessageRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftMessageRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.From |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			m.To = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.To |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Heartbeats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Heartbeats = append(m.Heartbeats, RaftHeartbeat{})
			if err := m.Heartbeats[len(m.Heartbeats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeartbeatResponses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeartbeatResponses = append(m.HeartbeatResponses, RaftHeartbeat{})
			if err := m.HeartbeatResponses[len(m.HeartbeatResponses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func (m *RaftMessageResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftMessageResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftMessageResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.From |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			m.To = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.To |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &Error{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func (m *RaftMessageRequestBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftMessageRequestBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftMessageRequestBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requests = append(m.Requests, RaftMessageRequest{})
			if err := m.Requests[len(m.Requests)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func (m *RaftSnapshotHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftSnapshotHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftSnapshotHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= RaftSnapshotHeader_SnapshotType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strategy", wireType)
			}
			m.Strategy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Strategy |= RaftSnapshotHeader_Strategy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftMessageRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RaftMessageRequest == nil {
				m.RaftMessageRequest = &RaftMessageRequest{}
			}
			if err := m.RaftMessageRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func (m *RaftSnapshotRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftSnapshotRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftSnapshotRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RaftSnapshotHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Final", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Final = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func (m *RaftSnapshotResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftSnapshotResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftSnapshotResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= RaftSnapshotResponse_Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func skipRaft(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthRaft
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupRaft
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthRaft
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthRaft        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRaft          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupRaft = fmt.Errorf("proto: unexpected end of group")
)
