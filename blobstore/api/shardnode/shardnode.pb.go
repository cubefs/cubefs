// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: shardnode.proto

package shardnode

import (
	fmt "fmt"
	clustermgr "github.com/cubefs/cubefs/blobstore/api/clustermgr"
	github_com_cubefs_cubefs_blobstore_common_proto "github.com/cubefs/cubefs/blobstore/common/proto"
	sharding "github.com/cubefs/cubefs/blobstore/common/sharding"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Item struct {
	ID                   []byte   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Fields               []Field  `protobuf:"bytes,2,rep,name=fields,proto3" json:"fields"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Item) Reset()         { *m = Item{} }
func (m *Item) String() string { return proto.CompactTextString(m) }
func (*Item) ProtoMessage()    {}
func (*Item) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{0}
}
func (m *Item) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Item) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Item.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Item) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Item.Merge(m, src)
}
func (m *Item) XXX_Size() int {
	return m.Size()
}
func (m *Item) XXX_DiscardUnknown() {
	xxx_messageInfo_Item.DiscardUnknown(m)
}

var xxx_messageInfo_Item proto.InternalMessageInfo

func (m *Item) GetID() []byte {
	if m != nil {
		return m.ID
	}
	return nil
}

func (m *Item) GetFields() []Field {
	if m != nil {
		return m.Fields
	}
	return nil
}

type Field struct {
	ID                   github_com_cubefs_cubefs_blobstore_common_proto.FieldID `protobuf:"varint,1,opt,name=id,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.FieldID" json:"id,omitempty"`
	Value                []byte                                                  `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                `json:"-"`
	XXX_unrecognized     []byte                                                  `json:"-"`
	XXX_sizecache        int32                                                   `json:"-"`
}

func (m *Field) Reset()         { *m = Field{} }
func (m *Field) String() string { return proto.CompactTextString(m) }
func (*Field) ProtoMessage()    {}
func (*Field) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{1}
}
func (m *Field) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Field) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Field.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Field) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Field.Merge(m, src)
}
func (m *Field) XXX_Size() int {
	return m.Size()
}
func (m *Field) XXX_DiscardUnknown() {
	xxx_messageInfo_Field.DiscardUnknown(m)
}

var xxx_messageInfo_Field proto.InternalMessageInfo

func (m *Field) GetID() github_com_cubefs_cubefs_blobstore_common_proto.FieldID {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Field) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type ShardOpHeader struct {
	SpaceID              github_com_cubefs_cubefs_blobstore_common_proto.SpaceID `protobuf:"varint,1,opt,name=space_id,json=spaceId,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.SpaceID" json:"space_id,omitempty"`
	DiskID               github_com_cubefs_cubefs_blobstore_common_proto.DiskID  `protobuf:"varint,2,opt,name=disk_id,json=diskId,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.DiskID" json:"disk_id,omitempty"`
	ShardID              github_com_cubefs_cubefs_blobstore_common_proto.ShardID `protobuf:"varint,3,opt,name=shard_id,json=shardId,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.ShardID" json:"shard_id,omitempty"`
	SpaceVersion         uint64                                                  `protobuf:"varint,4,opt,name=spaceVersion,proto3" json:"spaceVersion,omitempty"`
	RouteVersion         uint64                                                  `protobuf:"varint,5,opt,name=route_version,json=routeVersion,proto3" json:"route_version,omitempty"`
	ShardKeys            [][]byte                                                `protobuf:"bytes,6,rep,name=shard_keys,json=shardKeys,proto3" json:"shard_keys,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                `json:"-"`
	XXX_unrecognized     []byte                                                  `json:"-"`
	XXX_sizecache        int32                                                   `json:"-"`
}

func (m *ShardOpHeader) Reset()         { *m = ShardOpHeader{} }
func (m *ShardOpHeader) String() string { return proto.CompactTextString(m) }
func (*ShardOpHeader) ProtoMessage()    {}
func (*ShardOpHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{2}
}
func (m *ShardOpHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardOpHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardOpHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardOpHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardOpHeader.Merge(m, src)
}
func (m *ShardOpHeader) XXX_Size() int {
	return m.Size()
}
func (m *ShardOpHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardOpHeader.DiscardUnknown(m)
}

var xxx_messageInfo_ShardOpHeader proto.InternalMessageInfo

func (m *ShardOpHeader) GetSpaceID() github_com_cubefs_cubefs_blobstore_common_proto.SpaceID {
	if m != nil {
		return m.SpaceID
	}
	return 0
}

func (m *ShardOpHeader) GetDiskID() github_com_cubefs_cubefs_blobstore_common_proto.DiskID {
	if m != nil {
		return m.DiskID
	}
	return 0
}

func (m *ShardOpHeader) GetShardID() github_com_cubefs_cubefs_blobstore_common_proto.ShardID {
	if m != nil {
		return m.ShardID
	}
	return 0
}

func (m *ShardOpHeader) GetSpaceVersion() uint64 {
	if m != nil {
		return m.SpaceVersion
	}
	return 0
}

func (m *ShardOpHeader) GetRouteVersion() uint64 {
	if m != nil {
		return m.RouteVersion
	}
	return 0
}

func (m *ShardOpHeader) GetShardKeys() [][]byte {
	if m != nil {
		return m.ShardKeys
	}
	return nil
}

type InsertItemRequest struct {
	Header               ShardOpHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Item                 Item          `protobuf:"bytes,2,opt,name=item,proto3" json:"item"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *InsertItemRequest) Reset()         { *m = InsertItemRequest{} }
func (m *InsertItemRequest) String() string { return proto.CompactTextString(m) }
func (*InsertItemRequest) ProtoMessage()    {}
func (*InsertItemRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{3}
}
func (m *InsertItemRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InsertItemRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InsertItemRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InsertItemRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InsertItemRequest.Merge(m, src)
}
func (m *InsertItemRequest) XXX_Size() int {
	return m.Size()
}
func (m *InsertItemRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InsertItemRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InsertItemRequest proto.InternalMessageInfo

func (m *InsertItemRequest) GetHeader() ShardOpHeader {
	if m != nil {
		return m.Header
	}
	return ShardOpHeader{}
}

func (m *InsertItemRequest) GetItem() Item {
	if m != nil {
		return m.Item
	}
	return Item{}
}

type InsertItemResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InsertItemResponse) Reset()         { *m = InsertItemResponse{} }
func (m *InsertItemResponse) String() string { return proto.CompactTextString(m) }
func (*InsertItemResponse) ProtoMessage()    {}
func (*InsertItemResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{4}
}
func (m *InsertItemResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InsertItemResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InsertItemResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InsertItemResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InsertItemResponse.Merge(m, src)
}
func (m *InsertItemResponse) XXX_Size() int {
	return m.Size()
}
func (m *InsertItemResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_InsertItemResponse.DiscardUnknown(m)
}

var xxx_messageInfo_InsertItemResponse proto.InternalMessageInfo

type UpdateItemRequest struct {
	Header               ShardOpHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Item                 Item          `protobuf:"bytes,2,opt,name=item,proto3" json:"item"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *UpdateItemRequest) Reset()         { *m = UpdateItemRequest{} }
func (m *UpdateItemRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateItemRequest) ProtoMessage()    {}
func (*UpdateItemRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{5}
}
func (m *UpdateItemRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateItemRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateItemRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateItemRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateItemRequest.Merge(m, src)
}
func (m *UpdateItemRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateItemRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateItemRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateItemRequest proto.InternalMessageInfo

func (m *UpdateItemRequest) GetHeader() ShardOpHeader {
	if m != nil {
		return m.Header
	}
	return ShardOpHeader{}
}

func (m *UpdateItemRequest) GetItem() Item {
	if m != nil {
		return m.Item
	}
	return Item{}
}

type UpdateItemResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateItemResponse) Reset()         { *m = UpdateItemResponse{} }
func (m *UpdateItemResponse) String() string { return proto.CompactTextString(m) }
func (*UpdateItemResponse) ProtoMessage()    {}
func (*UpdateItemResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{6}
}
func (m *UpdateItemResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateItemResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateItemResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateItemResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateItemResponse.Merge(m, src)
}
func (m *UpdateItemResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdateItemResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateItemResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateItemResponse proto.InternalMessageInfo

type DeleteItemRequest struct {
	Header               ShardOpHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	ID                   []byte        `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *DeleteItemRequest) Reset()         { *m = DeleteItemRequest{} }
func (m *DeleteItemRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteItemRequest) ProtoMessage()    {}
func (*DeleteItemRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{7}
}
func (m *DeleteItemRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteItemRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteItemRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteItemRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteItemRequest.Merge(m, src)
}
func (m *DeleteItemRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteItemRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteItemRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteItemRequest proto.InternalMessageInfo

func (m *DeleteItemRequest) GetHeader() ShardOpHeader {
	if m != nil {
		return m.Header
	}
	return ShardOpHeader{}
}

func (m *DeleteItemRequest) GetID() []byte {
	if m != nil {
		return m.ID
	}
	return nil
}

type DeleteItemResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteItemResponse) Reset()         { *m = DeleteItemResponse{} }
func (m *DeleteItemResponse) String() string { return proto.CompactTextString(m) }
func (*DeleteItemResponse) ProtoMessage()    {}
func (*DeleteItemResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{8}
}
func (m *DeleteItemResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteItemResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteItemResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteItemResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteItemResponse.Merge(m, src)
}
func (m *DeleteItemResponse) XXX_Size() int {
	return m.Size()
}
func (m *DeleteItemResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteItemResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteItemResponse proto.InternalMessageInfo

type GetItemRequest struct {
	Header               ShardOpHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	ID                   []byte        `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *GetItemRequest) Reset()         { *m = GetItemRequest{} }
func (m *GetItemRequest) String() string { return proto.CompactTextString(m) }
func (*GetItemRequest) ProtoMessage()    {}
func (*GetItemRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{9}
}
func (m *GetItemRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetItemRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetItemRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetItemRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetItemRequest.Merge(m, src)
}
func (m *GetItemRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetItemRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetItemRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetItemRequest proto.InternalMessageInfo

func (m *GetItemRequest) GetHeader() ShardOpHeader {
	if m != nil {
		return m.Header
	}
	return ShardOpHeader{}
}

func (m *GetItemRequest) GetID() []byte {
	if m != nil {
		return m.ID
	}
	return nil
}

type GetItemResponse struct {
	Item                 Item     `protobuf:"bytes,1,opt,name=item,proto3" json:"item"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetItemResponse) Reset()         { *m = GetItemResponse{} }
func (m *GetItemResponse) String() string { return proto.CompactTextString(m) }
func (*GetItemResponse) ProtoMessage()    {}
func (*GetItemResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{10}
}
func (m *GetItemResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetItemResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetItemResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetItemResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetItemResponse.Merge(m, src)
}
func (m *GetItemResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetItemResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetItemResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetItemResponse proto.InternalMessageInfo

func (m *GetItemResponse) GetItem() Item {
	if m != nil {
		return m.Item
	}
	return Item{}
}

type AddShardRequest struct {
	DiskID               github_com_cubefs_cubefs_blobstore_common_proto.DiskID  `protobuf:"varint,1,opt,name=disk_id,json=diskId,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.DiskID" json:"disk_id,omitempty"`
	ShardID              github_com_cubefs_cubefs_blobstore_common_proto.ShardID `protobuf:"varint,2,opt,name=shard_id,json=shardId,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.ShardID" json:"shard_id,omitempty"`
	Range                sharding.Range                                          `protobuf:"bytes,3,opt,name=range,proto3" json:"range"`
	Units                []clustermgr.ShardUnitInfo                              `protobuf:"bytes,4,rep,name=units,proto3" json:"units"`
	Epoch                uint64                                                  `protobuf:"varint,5,opt,name=epoch,proto3" json:"epoch,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                `json:"-"`
	XXX_unrecognized     []byte                                                  `json:"-"`
	XXX_sizecache        int32                                                   `json:"-"`
}

func (m *AddShardRequest) Reset()         { *m = AddShardRequest{} }
func (m *AddShardRequest) String() string { return proto.CompactTextString(m) }
func (*AddShardRequest) ProtoMessage()    {}
func (*AddShardRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{11}
}
func (m *AddShardRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddShardRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddShardRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddShardRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddShardRequest.Merge(m, src)
}
func (m *AddShardRequest) XXX_Size() int {
	return m.Size()
}
func (m *AddShardRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddShardRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddShardRequest proto.InternalMessageInfo

func (m *AddShardRequest) GetDiskID() github_com_cubefs_cubefs_blobstore_common_proto.DiskID {
	if m != nil {
		return m.DiskID
	}
	return 0
}

func (m *AddShardRequest) GetShardID() github_com_cubefs_cubefs_blobstore_common_proto.ShardID {
	if m != nil {
		return m.ShardID
	}
	return 0
}

func (m *AddShardRequest) GetRange() sharding.Range {
	if m != nil {
		return m.Range
	}
	return sharding.Range{}
}

func (m *AddShardRequest) GetUnits() []clustermgr.ShardUnitInfo {
	if m != nil {
		return m.Units
	}
	return nil
}

func (m *AddShardRequest) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

type AddShardResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddShardResponse) Reset()         { *m = AddShardResponse{} }
func (m *AddShardResponse) String() string { return proto.CompactTextString(m) }
func (*AddShardResponse) ProtoMessage()    {}
func (*AddShardResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{12}
}
func (m *AddShardResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddShardResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddShardResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddShardResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddShardResponse.Merge(m, src)
}
func (m *AddShardResponse) XXX_Size() int {
	return m.Size()
}
func (m *AddShardResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AddShardResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AddShardResponse proto.InternalMessageInfo

type UpdateShardRequest struct {
	DiskID               github_com_cubefs_cubefs_blobstore_common_proto.DiskID          `protobuf:"varint,1,opt,name=disk_id,json=diskId,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.DiskID" json:"disk_id,omitempty"`
	ShardID              github_com_cubefs_cubefs_blobstore_common_proto.ShardID         `protobuf:"varint,2,opt,name=shard_id,json=shardId,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.ShardID" json:"shard_id,omitempty"`
	ShardUpdateType      github_com_cubefs_cubefs_blobstore_common_proto.ShardUpdateType `protobuf:"varint,3,opt,name=ShardUpdateType,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.ShardUpdateType" json:"ShardUpdateType,omitempty"`
	Unit                 clustermgr.ShardUnitInfo                                        `protobuf:"bytes,4,opt,name=unit,proto3" json:"unit"`
	XXX_NoUnkeyedLiteral struct{}                                                        `json:"-"`
	XXX_unrecognized     []byte                                                          `json:"-"`
	XXX_sizecache        int32                                                           `json:"-"`
}

func (m *UpdateShardRequest) Reset()         { *m = UpdateShardRequest{} }
func (m *UpdateShardRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateShardRequest) ProtoMessage()    {}
func (*UpdateShardRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{13}
}
func (m *UpdateShardRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateShardRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateShardRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateShardRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateShardRequest.Merge(m, src)
}
func (m *UpdateShardRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateShardRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateShardRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateShardRequest proto.InternalMessageInfo

func (m *UpdateShardRequest) GetDiskID() github_com_cubefs_cubefs_blobstore_common_proto.DiskID {
	if m != nil {
		return m.DiskID
	}
	return 0
}

func (m *UpdateShardRequest) GetShardID() github_com_cubefs_cubefs_blobstore_common_proto.ShardID {
	if m != nil {
		return m.ShardID
	}
	return 0
}

func (m *UpdateShardRequest) GetShardUpdateType() github_com_cubefs_cubefs_blobstore_common_proto.ShardUpdateType {
	if m != nil {
		return m.ShardUpdateType
	}
	return 0
}

func (m *UpdateShardRequest) GetUnit() clustermgr.ShardUnitInfo {
	if m != nil {
		return m.Unit
	}
	return clustermgr.ShardUnitInfo{}
}

type UpdateShardResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateShardResponse) Reset()         { *m = UpdateShardResponse{} }
func (m *UpdateShardResponse) String() string { return proto.CompactTextString(m) }
func (*UpdateShardResponse) ProtoMessage()    {}
func (*UpdateShardResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{14}
}
func (m *UpdateShardResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateShardResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateShardResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateShardResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateShardResponse.Merge(m, src)
}
func (m *UpdateShardResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdateShardResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateShardResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateShardResponse proto.InternalMessageInfo

type GetShardRequest struct {
	DiskID               github_com_cubefs_cubefs_blobstore_common_proto.DiskID  `protobuf:"varint,1,opt,name=disk_id,json=diskId,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.DiskID" json:"disk_id,omitempty"`
	ShardID              github_com_cubefs_cubefs_blobstore_common_proto.ShardID `protobuf:"varint,2,opt,name=shard_id,json=shardId,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.ShardID" json:"shard_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                `json:"-"`
	XXX_unrecognized     []byte                                                  `json:"-"`
	XXX_sizecache        int32                                                   `json:"-"`
}

func (m *GetShardRequest) Reset()         { *m = GetShardRequest{} }
func (m *GetShardRequest) String() string { return proto.CompactTextString(m) }
func (*GetShardRequest) ProtoMessage()    {}
func (*GetShardRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{15}
}
func (m *GetShardRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetShardRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetShardRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetShardRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetShardRequest.Merge(m, src)
}
func (m *GetShardRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetShardRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetShardRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetShardRequest proto.InternalMessageInfo

func (m *GetShardRequest) GetDiskID() github_com_cubefs_cubefs_blobstore_common_proto.DiskID {
	if m != nil {
		return m.DiskID
	}
	return 0
}

func (m *GetShardRequest) GetShardID() github_com_cubefs_cubefs_blobstore_common_proto.ShardID {
	if m != nil {
		return m.ShardID
	}
	return 0
}

type GetShardResponse struct {
	Shard                clustermgr.Shard `protobuf:"bytes,1,opt,name=shard,proto3" json:"shard"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *GetShardResponse) Reset()         { *m = GetShardResponse{} }
func (m *GetShardResponse) String() string { return proto.CompactTextString(m) }
func (*GetShardResponse) ProtoMessage()    {}
func (*GetShardResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{16}
}
func (m *GetShardResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetShardResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetShardResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetShardResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetShardResponse.Merge(m, src)
}
func (m *GetShardResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetShardResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetShardResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetShardResponse proto.InternalMessageInfo

func (m *GetShardResponse) GetShard() clustermgr.Shard {
	if m != nil {
		return m.Shard
	}
	return clustermgr.Shard{}
}

func init() {
	proto.RegisterType((*Item)(nil), "cubefs.blobstore.api.shardnode.Item")
	proto.RegisterType((*Field)(nil), "cubefs.blobstore.api.shardnode.Field")
	proto.RegisterType((*ShardOpHeader)(nil), "cubefs.blobstore.api.shardnode.ShardOpHeader")
	proto.RegisterType((*InsertItemRequest)(nil), "cubefs.blobstore.api.shardnode.InsertItemRequest")
	proto.RegisterType((*InsertItemResponse)(nil), "cubefs.blobstore.api.shardnode.InsertItemResponse")
	proto.RegisterType((*UpdateItemRequest)(nil), "cubefs.blobstore.api.shardnode.UpdateItemRequest")
	proto.RegisterType((*UpdateItemResponse)(nil), "cubefs.blobstore.api.shardnode.UpdateItemResponse")
	proto.RegisterType((*DeleteItemRequest)(nil), "cubefs.blobstore.api.shardnode.DeleteItemRequest")
	proto.RegisterType((*DeleteItemResponse)(nil), "cubefs.blobstore.api.shardnode.DeleteItemResponse")
	proto.RegisterType((*GetItemRequest)(nil), "cubefs.blobstore.api.shardnode.GetItemRequest")
	proto.RegisterType((*GetItemResponse)(nil), "cubefs.blobstore.api.shardnode.GetItemResponse")
	proto.RegisterType((*AddShardRequest)(nil), "cubefs.blobstore.api.shardnode.AddShardRequest")
	proto.RegisterType((*AddShardResponse)(nil), "cubefs.blobstore.api.shardnode.AddShardResponse")
	proto.RegisterType((*UpdateShardRequest)(nil), "cubefs.blobstore.api.shardnode.UpdateShardRequest")
	proto.RegisterType((*UpdateShardResponse)(nil), "cubefs.blobstore.api.shardnode.UpdateShardResponse")
	proto.RegisterType((*GetShardRequest)(nil), "cubefs.blobstore.api.shardnode.GetShardRequest")
	proto.RegisterType((*GetShardResponse)(nil), "cubefs.blobstore.api.shardnode.GetShardResponse")
}

func init() { proto.RegisterFile("shardnode.proto", fileDescriptor_9d3815ca0e5f30f0) }

var fileDescriptor_9d3815ca0e5f30f0 = []byte{
	// 743 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x55, 0x4f, 0x6f, 0xd3, 0x4e,
	0x10, 0xfd, 0xd9, 0xf9, 0xf7, 0x63, 0x92, 0x92, 0x76, 0x29, 0x28, 0x8a, 0x44, 0x52, 0x99, 0x7f,
	0x95, 0x00, 0x5b, 0x0a, 0x12, 0x1c, 0x90, 0x40, 0x4d, 0xa3, 0xd2, 0xd0, 0x03, 0xaa, 0x4b, 0x7b,
	0x40, 0x42, 0x95, 0x13, 0x6f, 0x13, 0xab, 0x89, 0xd7, 0x78, 0xed, 0x8a, 0xde, 0xf8, 0x20, 0x1c,
	0x90, 0xf8, 0x32, 0x3d, 0x22, 0x71, 0x8f, 0x90, 0x3f, 0x46, 0x4f, 0x68, 0x67, 0xd7, 0x49, 0xda,
	0x02, 0x85, 0x48, 0x45, 0xa8, 0xb7, 0x64, 0x3d, 0xef, 0xcd, 0x9b, 0x99, 0xdd, 0x37, 0x50, 0xe6,
	0x7d, 0x27, 0x74, 0x7d, 0xe6, 0x52, 0x33, 0x08, 0x59, 0xc4, 0x48, 0xad, 0x1b, 0x77, 0xe8, 0x1e,
	0x37, 0x3b, 0x03, 0xd6, 0xe1, 0x11, 0x0b, 0xa9, 0xe9, 0x04, 0x9e, 0x39, 0x8e, 0xaa, 0x2e, 0xf6,
	0x58, 0x8f, 0x61, 0xa8, 0x25, 0x7e, 0x49, 0x54, 0xf5, 0x81, 0x44, 0x59, 0x63, 0x94, 0xd5, 0x65,
	0xc3, 0x21, 0xf3, 0x2d, 0x04, 0x7a, 0x7e, 0xcf, 0x0a, 0x1d, 0xbf, 0xa7, 0x72, 0x54, 0xef, 0x9f,
	0x89, 0x76, 0x02, 0xcf, 0xea, 0x0e, 0x62, 0x1e, 0xd1, 0x70, 0xd8, 0x0b, 0x25, 0x4a, 0x06, 0x1b,
	0x5d, 0xc8, 0xb6, 0x23, 0x3a, 0x24, 0x37, 0x40, 0xf7, 0xdc, 0x8a, 0xb6, 0xa4, 0x2d, 0x97, 0x9a,
	0xf9, 0x64, 0x54, 0xd7, 0xdb, 0x2d, 0x5b, 0xf7, 0x5c, 0xb2, 0x0a, 0xf9, 0x3d, 0x8f, 0x0e, 0x5c,
	0x5e, 0xd1, 0x97, 0x32, 0xcb, 0xc5, 0xc6, 0x1d, 0xf3, 0xd7, 0x15, 0x98, 0x6b, 0x22, 0xba, 0x99,
	0x3d, 0x1a, 0xd5, 0xff, 0xb3, 0x15, 0xd4, 0x08, 0x20, 0x87, 0xc7, 0x64, 0x73, 0x9c, 0x65, 0xae,
	0xb9, 0x22, 0xb3, 0x1c, 0x8f, 0xea, 0x4f, 0x7a, 0x5e, 0xd4, 0x8f, 0x3b, 0x66, 0x97, 0x0d, 0x2d,
	0xa5, 0xfd, 0x67, 0x05, 0xa3, 0x68, 0x99, 0x43, 0x09, 0x5c, 0x84, 0xdc, 0x81, 0x33, 0x88, 0x69,
	0x45, 0x17, 0xda, 0x6d, 0xf9, 0xc7, 0xf8, 0x98, 0x81, 0xb9, 0x2d, 0xa1, 0xe9, 0x55, 0xb0, 0x4e,
	0x1d, 0x97, 0x86, 0xc4, 0x81, 0xff, 0x79, 0xe0, 0x74, 0xe9, 0xae, 0x12, 0x90, 0x6d, 0xae, 0x25,
	0xa3, 0x7a, 0x61, 0x4b, 0x9c, 0xcd, 0xa6, 0x42, 0x41, 0xed, 0x02, 0xf2, 0xb6, 0x5d, 0xf2, 0x16,
	0x0a, 0xae, 0xc7, 0xf7, 0x45, 0x06, 0x1d, 0x4b, 0x6c, 0x25, 0xa3, 0x7a, 0xbe, 0xe5, 0xf1, 0x7d,
	0x4c, 0xf0, 0xf8, 0x4f, 0x13, 0x48, 0xa4, 0x9d, 0x17, 0xa4, 0x6d, 0x17, 0x2b, 0x10, 0x25, 0x09,
	0xfe, 0x0c, 0xf2, 0xcb, 0x0a, 0xc4, 0xd9, 0x8c, 0x15, 0x48, 0xa8, 0x5d, 0x40, 0xde, 0xb6, 0x4b,
	0x0c, 0x28, 0x61, 0x31, 0x3b, 0x34, 0xe4, 0x1e, 0xf3, 0x2b, 0x59, 0xd1, 0x28, 0xfb, 0xc4, 0x19,
	0xb9, 0x05, 0x73, 0x21, 0x8b, 0x23, 0xba, 0x7b, 0xa0, 0x82, 0x72, 0x32, 0x08, 0x0f, 0xd3, 0xa0,
	0x9b, 0x00, 0x52, 0xeb, 0x3e, 0x3d, 0xe4, 0x95, 0xfc, 0x52, 0x66, 0xb9, 0x64, 0x5f, 0xc1, 0x93,
	0x0d, 0x7a, 0xc8, 0x8d, 0x4f, 0x1a, 0x2c, 0xb4, 0x7d, 0x4e, 0xc3, 0x48, 0x5c, 0x3e, 0x9b, 0xbe,
	0x8b, 0x29, 0x8f, 0xc8, 0x06, 0xe4, 0xfb, 0x38, 0x2c, 0x1c, 0x50, 0xb1, 0xf1, 0xf0, 0xbc, 0xbb,
	0x76, 0x62, 0xc2, 0xe9, 0x9d, 0x93, 0x14, 0xe4, 0x19, 0x64, 0xbd, 0x88, 0x0e, 0x71, 0x12, 0xc5,
	0xc6, 0xed, 0xf3, 0xa8, 0x84, 0x0e, 0xc5, 0x80, 0x38, 0x63, 0x11, 0xc8, 0xb4, 0x42, 0x1e, 0x30,
	0x9f, 0x53, 0x14, 0xbe, 0x1d, 0xb8, 0x4e, 0x44, 0xff, 0x65, 0xe1, 0xd3, 0x0a, 0x95, 0xf0, 0xf7,
	0xb0, 0xd0, 0xa2, 0x03, 0x7a, 0x81, 0xba, 0xa5, 0x83, 0xe8, 0xa7, 0x1d, 0x44, 0xe8, 0x99, 0xce,
	0xac, 0xf4, 0xc4, 0x70, 0xf5, 0x05, 0x8d, 0xfe, 0xba, 0x98, 0x4d, 0x28, 0x8f, 0xd3, 0x4a, 0x25,
	0xe3, 0x7e, 0x6b, 0x33, 0xf6, 0xfb, 0x58, 0x87, 0xf2, 0x8a, 0xeb, 0xa2, 0x9a, 0xb4, 0x96, 0x29,
	0x27, 0xd0, 0x2e, 0xd8, 0x09, 0xf4, 0x8b, 0x71, 0x82, 0x55, 0xc8, 0xe1, 0x4e, 0x41, 0xa7, 0x29,
	0x36, 0xee, 0x9d, 0x6d, 0x8b, 0xc4, 0x9b, 0xe9, 0x0a, 0x32, 0x6d, 0x11, 0xae, 0x3a, 0x23, 0xb1,
	0xe4, 0x25, 0xe4, 0x62, 0xdf, 0x8b, 0x78, 0x25, 0x8b, 0xbb, 0xc3, 0xfc, 0x71, 0x6f, 0x27, 0x9b,
	0x49, 0xca, 0xd8, 0xf6, 0xbd, 0xa8, 0xed, 0xef, 0xb1, 0x94, 0x0b, 0x29, 0x84, 0xcf, 0xd3, 0x80,
	0x75, 0xfb, 0xca, 0x6e, 0xe4, 0x1f, 0x83, 0xc0, 0xfc, 0xa4, 0xf7, 0xea, 0x6a, 0x7d, 0xce, 0xa4,
	0x2f, 0xe0, 0x92, 0xcd, 0xe4, 0x83, 0x06, 0x65, 0xd9, 0x21, 0xac, 0xee, 0xf5, 0x61, 0x40, 0xd5,
	0x22, 0xd8, 0x49, 0x46, 0xf5, 0xd3, 0x9f, 0x8e, 0x47, 0xf5, 0xe7, 0x33, 0xa5, 0x9c, 0x50, 0xd8,
	0xa7, 0x39, 0xc9, 0x3a, 0x64, 0xc5, 0x38, 0x70, 0x31, 0xcc, 0x3a, 0x50, 0x64, 0x30, 0xae, 0xc3,
	0xb5, 0x13, 0x43, 0x52, 0xc3, 0xfb, 0xaa, 0xe1, 0x0b, 0xbd, 0x5c, 0x93, 0x33, 0x76, 0x60, 0x7e,
	0x52, 0x94, 0xf2, 0x9d, 0x26, 0xe4, 0xf0, 0xb3, 0x32, 0x9e, 0xbb, 0xbf, 0xd7, 0xcb, 0xf4, 0x51,
	0x20, 0xb4, 0x59, 0x3d, 0x4a, 0x6a, 0xda, 0x97, 0xa4, 0xa6, 0x7d, 0x4b, 0x6a, 0xda, 0x9b, 0x92,
	0x69, 0x3d, 0x1d, 0x1b, 0x55, 0x27, 0x8f, 0x5a, 0x1e, 0x7d, 0x0f, 0x00, 0x00, 0xff, 0xff, 0xa1,
	0x3a, 0x20, 0x96, 0x84, 0x0a, 0x00, 0x00,
}

func (m *Item) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Item) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Item) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Fields[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintShardnode(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintShardnode(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Field) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Field) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Field) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintShardnode(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if m.ID != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ShardOpHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardOpHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShardOpHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ShardKeys) > 0 {
		for iNdEx := len(m.ShardKeys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ShardKeys[iNdEx])
			copy(dAtA[i:], m.ShardKeys[iNdEx])
			i = encodeVarintShardnode(dAtA, i, uint64(len(m.ShardKeys[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.RouteVersion != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.RouteVersion))
		i--
		dAtA[i] = 0x28
	}
	if m.SpaceVersion != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.SpaceVersion))
		i--
		dAtA[i] = 0x20
	}
	if m.ShardID != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.ShardID))
		i--
		dAtA[i] = 0x18
	}
	if m.DiskID != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.DiskID))
		i--
		dAtA[i] = 0x10
	}
	if m.SpaceID != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.SpaceID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *InsertItemRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InsertItemRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InsertItemRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *InsertItemResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InsertItemResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InsertItemResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *UpdateItemRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateItemRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateItemRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *UpdateItemResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateItemResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateItemResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *DeleteItemRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteItemRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteItemRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintShardnode(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DeleteItemResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteItemResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteItemResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *GetItemRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetItemRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetItemRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintShardnode(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *GetItemResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetItemResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetItemResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AddShardRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddShardRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddShardRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Epoch != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Units) > 0 {
		for iNdEx := len(m.Units) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Units[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintShardnode(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	{
		size, err := m.Range.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.ShardID != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.ShardID))
		i--
		dAtA[i] = 0x10
	}
	if m.DiskID != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.DiskID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AddShardResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddShardResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddShardResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *UpdateShardRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateShardRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateShardRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Unit.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.ShardUpdateType != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.ShardUpdateType))
		i--
		dAtA[i] = 0x18
	}
	if m.ShardID != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.ShardID))
		i--
		dAtA[i] = 0x10
	}
	if m.DiskID != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.DiskID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateShardResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateShardResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateShardResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *GetShardRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetShardRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetShardRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ShardID != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.ShardID))
		i--
		dAtA[i] = 0x10
	}
	if m.DiskID != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.DiskID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetShardResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetShardResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetShardResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Shard.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintShardnode(dAtA []byte, offset int, v uint64) int {
	offset -= sovShardnode(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Item) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovShardnode(uint64(l))
	}
	if len(m.Fields) > 0 {
		for _, e := range m.Fields {
			l = e.Size()
			n += 1 + l + sovShardnode(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Field) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovShardnode(uint64(m.ID))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovShardnode(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShardOpHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SpaceID != 0 {
		n += 1 + sovShardnode(uint64(m.SpaceID))
	}
	if m.DiskID != 0 {
		n += 1 + sovShardnode(uint64(m.DiskID))
	}
	if m.ShardID != 0 {
		n += 1 + sovShardnode(uint64(m.ShardID))
	}
	if m.SpaceVersion != 0 {
		n += 1 + sovShardnode(uint64(m.SpaceVersion))
	}
	if m.RouteVersion != 0 {
		n += 1 + sovShardnode(uint64(m.RouteVersion))
	}
	if len(m.ShardKeys) > 0 {
		for _, b := range m.ShardKeys {
			l = len(b)
			n += 1 + l + sovShardnode(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InsertItemRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovShardnode(uint64(l))
	l = m.Item.Size()
	n += 1 + l + sovShardnode(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InsertItemResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateItemRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovShardnode(uint64(l))
	l = m.Item.Size()
	n += 1 + l + sovShardnode(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateItemResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteItemRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovShardnode(uint64(l))
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovShardnode(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteItemResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetItemRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovShardnode(uint64(l))
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovShardnode(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetItemResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Item.Size()
	n += 1 + l + sovShardnode(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddShardRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DiskID != 0 {
		n += 1 + sovShardnode(uint64(m.DiskID))
	}
	if m.ShardID != 0 {
		n += 1 + sovShardnode(uint64(m.ShardID))
	}
	l = m.Range.Size()
	n += 1 + l + sovShardnode(uint64(l))
	if len(m.Units) > 0 {
		for _, e := range m.Units {
			l = e.Size()
			n += 1 + l + sovShardnode(uint64(l))
		}
	}
	if m.Epoch != 0 {
		n += 1 + sovShardnode(uint64(m.Epoch))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddShardResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateShardRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DiskID != 0 {
		n += 1 + sovShardnode(uint64(m.DiskID))
	}
	if m.ShardID != 0 {
		n += 1 + sovShardnode(uint64(m.ShardID))
	}
	if m.ShardUpdateType != 0 {
		n += 1 + sovShardnode(uint64(m.ShardUpdateType))
	}
	l = m.Unit.Size()
	n += 1 + l + sovShardnode(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateShardResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetShardRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DiskID != 0 {
		n += 1 + sovShardnode(uint64(m.DiskID))
	}
	if m.ShardID != 0 {
		n += 1 + sovShardnode(uint64(m.ShardID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetShardResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Shard.Size()
	n += 1 + l + sovShardnode(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovShardnode(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozShardnode(x uint64) (n int) {
	return sovShardnode(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Item) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Item: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Item: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = append(m.ID[:0], dAtA[iNdEx:postIndex]...)
			if m.ID == nil {
				m.ID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, Field{})
			if err := m.Fields[len(m.Fields)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Field) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Field: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Field: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= github_com_cubefs_cubefs_blobstore_common_proto.FieldID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardOpHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardOpHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardOpHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceID", wireType)
			}
			m.SpaceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpaceID |= github_com_cubefs_cubefs_blobstore_common_proto.SpaceID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskID", wireType)
			}
			m.DiskID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskID |= github_com_cubefs_cubefs_blobstore_common_proto.DiskID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardID", wireType)
			}
			m.ShardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardID |= github_com_cubefs_cubefs_blobstore_common_proto.ShardID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceVersion", wireType)
			}
			m.SpaceVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpaceVersion |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteVersion", wireType)
			}
			m.RouteVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouteVersion |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardKeys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShardKeys = append(m.ShardKeys, make([]byte, postIndex-iNdEx))
			copy(m.ShardKeys[len(m.ShardKeys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InsertItemRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InsertItemRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InsertItemRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InsertItemResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InsertItemResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InsertItemResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateItemRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateItemRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateItemRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateItemResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateItemResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateItemResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteItemRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteItemRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteItemRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = append(m.ID[:0], dAtA[iNdEx:postIndex]...)
			if m.ID == nil {
				m.ID = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteItemResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteItemResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteItemResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetItemRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetItemRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetItemRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = append(m.ID[:0], dAtA[iNdEx:postIndex]...)
			if m.ID == nil {
				m.ID = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetItemResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetItemResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetItemResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddShardRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddShardRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddShardRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskID", wireType)
			}
			m.DiskID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskID |= github_com_cubefs_cubefs_blobstore_common_proto.DiskID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardID", wireType)
			}
			m.ShardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardID |= github_com_cubefs_cubefs_blobstore_common_proto.ShardID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Units", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Units = append(m.Units, clustermgr.ShardUnitInfo{})
			if err := m.Units[len(m.Units)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddShardResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddShardResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddShardResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateShardRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateShardRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateShardRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskID", wireType)
			}
			m.DiskID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskID |= github_com_cubefs_cubefs_blobstore_common_proto.DiskID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardID", wireType)
			}
			m.ShardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardID |= github_com_cubefs_cubefs_blobstore_common_proto.ShardID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardUpdateType", wireType)
			}
			m.ShardUpdateType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardUpdateType |= github_com_cubefs_cubefs_blobstore_common_proto.ShardUpdateType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Unit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateShardResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateShardResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateShardResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetShardRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetShardRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetShardRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskID", wireType)
			}
			m.DiskID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskID |= github_com_cubefs_cubefs_blobstore_common_proto.DiskID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardID", wireType)
			}
			m.ShardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardID |= github_com_cubefs_cubefs_blobstore_common_proto.ShardID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetShardResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetShardResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetShardResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Shard.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipShardnode(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthShardnode
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupShardnode
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthShardnode
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthShardnode        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowShardnode          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupShardnode = fmt.Errorf("proto: unexpected end of group")
)
