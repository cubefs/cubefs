// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: shardnode.proto

package shardnode

import (
	fmt "fmt"
	clustermgr "github.com/cubefs/cubefs/blobstore/api/clustermgr"
	github_com_cubefs_cubefs_blobstore_common_codemode "github.com/cubefs/cubefs/blobstore/common/codemode"
	github_com_cubefs_cubefs_blobstore_common_proto "github.com/cubefs/cubefs/blobstore/common/proto"
	proto1 "github.com/cubefs/cubefs/blobstore/common/proto"
	raft "github.com/cubefs/cubefs/blobstore/common/raft"
	sharding "github.com/cubefs/cubefs/blobstore/common/sharding"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Item struct {
	ID                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Fields               []Field  `protobuf:"bytes,2,rep,name=fields,proto3" json:"fields"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Item) Reset()         { *m = Item{} }
func (m *Item) String() string { return proto.CompactTextString(m) }
func (*Item) ProtoMessage()    {}
func (*Item) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{0}
}
func (m *Item) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Item) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Item.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Item) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Item.Merge(m, src)
}
func (m *Item) XXX_Size() int {
	return m.Size()
}
func (m *Item) XXX_DiscardUnknown() {
	xxx_messageInfo_Item.DiscardUnknown(m)
}

var xxx_messageInfo_Item proto.InternalMessageInfo

func (m *Item) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *Item) GetFields() []Field {
	if m != nil {
		return m.Fields
	}
	return nil
}

type Field struct {
	ID                   github_com_cubefs_cubefs_blobstore_common_proto.FieldID `protobuf:"varint,1,opt,name=id,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.FieldID" json:"id,omitempty"`
	Value                []byte                                                  `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                `json:"-"`
	XXX_unrecognized     []byte                                                  `json:"-"`
	XXX_sizecache        int32                                                   `json:"-"`
}

func (m *Field) Reset()         { *m = Field{} }
func (m *Field) String() string { return proto.CompactTextString(m) }
func (*Field) ProtoMessage()    {}
func (*Field) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{1}
}
func (m *Field) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Field) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Field.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Field) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Field.Merge(m, src)
}
func (m *Field) XXX_Size() int {
	return m.Size()
}
func (m *Field) XXX_DiscardUnknown() {
	xxx_messageInfo_Field.DiscardUnknown(m)
}

var xxx_messageInfo_Field proto.InternalMessageInfo

func (m *Field) GetID() github_com_cubefs_cubefs_blobstore_common_proto.FieldID {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Field) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type ShardOpHeader struct {
	SpaceID              github_com_cubefs_cubefs_blobstore_common_proto.SpaceID      `protobuf:"varint,1,opt,name=space_id,json=spaceId,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.SpaceID" json:"space_id,omitempty"`
	DiskID               github_com_cubefs_cubefs_blobstore_common_proto.DiskID       `protobuf:"varint,2,opt,name=disk_id,json=diskId,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.DiskID" json:"disk_id,omitempty"`
	Suid                 github_com_cubefs_cubefs_blobstore_common_proto.Suid         `protobuf:"varint,3,opt,name=suid,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.Suid" json:"suid,omitempty"`
	SpaceVersion         uint64                                                       `protobuf:"varint,4,opt,name=spaceVersion,proto3" json:"spaceVersion,omitempty"`
	RouteVersion         github_com_cubefs_cubefs_blobstore_common_proto.RouteVersion `protobuf:"varint,5,opt,name=route_version,json=routeVersion,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.RouteVersion" json:"route_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                     `json:"-"`
	XXX_unrecognized     []byte                                                       `json:"-"`
	XXX_sizecache        int32                                                        `json:"-"`
}

func (m *ShardOpHeader) Reset()         { *m = ShardOpHeader{} }
func (m *ShardOpHeader) String() string { return proto.CompactTextString(m) }
func (*ShardOpHeader) ProtoMessage()    {}
func (*ShardOpHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{2}
}
func (m *ShardOpHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardOpHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardOpHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardOpHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardOpHeader.Merge(m, src)
}
func (m *ShardOpHeader) XXX_Size() int {
	return m.Size()
}
func (m *ShardOpHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardOpHeader.DiscardUnknown(m)
}

var xxx_messageInfo_ShardOpHeader proto.InternalMessageInfo

func (m *ShardOpHeader) GetSpaceID() github_com_cubefs_cubefs_blobstore_common_proto.SpaceID {
	if m != nil {
		return m.SpaceID
	}
	return 0
}

func (m *ShardOpHeader) GetDiskID() github_com_cubefs_cubefs_blobstore_common_proto.DiskID {
	if m != nil {
		return m.DiskID
	}
	return 0
}

func (m *ShardOpHeader) GetSuid() github_com_cubefs_cubefs_blobstore_common_proto.Suid {
	if m != nil {
		return m.Suid
	}
	return 0
}

func (m *ShardOpHeader) GetSpaceVersion() uint64 {
	if m != nil {
		return m.SpaceVersion
	}
	return 0
}

func (m *ShardOpHeader) GetRouteVersion() github_com_cubefs_cubefs_blobstore_common_proto.RouteVersion {
	if m != nil {
		return m.RouteVersion
	}
	return 0
}

type InsertItemArgs struct {
	Header               ShardOpHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Item                 Item          `protobuf:"bytes,2,opt,name=item,proto3" json:"item"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *InsertItemArgs) Reset()         { *m = InsertItemArgs{} }
func (m *InsertItemArgs) String() string { return proto.CompactTextString(m) }
func (*InsertItemArgs) ProtoMessage()    {}
func (*InsertItemArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{3}
}
func (m *InsertItemArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InsertItemArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InsertItemArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InsertItemArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InsertItemArgs.Merge(m, src)
}
func (m *InsertItemArgs) XXX_Size() int {
	return m.Size()
}
func (m *InsertItemArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_InsertItemArgs.DiscardUnknown(m)
}

var xxx_messageInfo_InsertItemArgs proto.InternalMessageInfo

func (m *InsertItemArgs) GetHeader() ShardOpHeader {
	if m != nil {
		return m.Header
	}
	return ShardOpHeader{}
}

func (m *InsertItemArgs) GetItem() Item {
	if m != nil {
		return m.Item
	}
	return Item{}
}

type InsertItemRet struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InsertItemRet) Reset()         { *m = InsertItemRet{} }
func (m *InsertItemRet) String() string { return proto.CompactTextString(m) }
func (*InsertItemRet) ProtoMessage()    {}
func (*InsertItemRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{4}
}
func (m *InsertItemRet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InsertItemRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InsertItemRet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InsertItemRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InsertItemRet.Merge(m, src)
}
func (m *InsertItemRet) XXX_Size() int {
	return m.Size()
}
func (m *InsertItemRet) XXX_DiscardUnknown() {
	xxx_messageInfo_InsertItemRet.DiscardUnknown(m)
}

var xxx_messageInfo_InsertItemRet proto.InternalMessageInfo

type UpdateItemArgs struct {
	Header               ShardOpHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Item                 Item          `protobuf:"bytes,2,opt,name=item,proto3" json:"item"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *UpdateItemArgs) Reset()         { *m = UpdateItemArgs{} }
func (m *UpdateItemArgs) String() string { return proto.CompactTextString(m) }
func (*UpdateItemArgs) ProtoMessage()    {}
func (*UpdateItemArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{5}
}
func (m *UpdateItemArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateItemArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateItemArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateItemArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateItemArgs.Merge(m, src)
}
func (m *UpdateItemArgs) XXX_Size() int {
	return m.Size()
}
func (m *UpdateItemArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateItemArgs.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateItemArgs proto.InternalMessageInfo

func (m *UpdateItemArgs) GetHeader() ShardOpHeader {
	if m != nil {
		return m.Header
	}
	return ShardOpHeader{}
}

func (m *UpdateItemArgs) GetItem() Item {
	if m != nil {
		return m.Item
	}
	return Item{}
}

type UpdateItemRet struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateItemRet) Reset()         { *m = UpdateItemRet{} }
func (m *UpdateItemRet) String() string { return proto.CompactTextString(m) }
func (*UpdateItemRet) ProtoMessage()    {}
func (*UpdateItemRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{6}
}
func (m *UpdateItemRet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateItemRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateItemRet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateItemRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateItemRet.Merge(m, src)
}
func (m *UpdateItemRet) XXX_Size() int {
	return m.Size()
}
func (m *UpdateItemRet) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateItemRet.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateItemRet proto.InternalMessageInfo

type DeleteItemArgs struct {
	Header               ShardOpHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	ID                   string        `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *DeleteItemArgs) Reset()         { *m = DeleteItemArgs{} }
func (m *DeleteItemArgs) String() string { return proto.CompactTextString(m) }
func (*DeleteItemArgs) ProtoMessage()    {}
func (*DeleteItemArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{7}
}
func (m *DeleteItemArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteItemArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteItemArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteItemArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteItemArgs.Merge(m, src)
}
func (m *DeleteItemArgs) XXX_Size() int {
	return m.Size()
}
func (m *DeleteItemArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteItemArgs.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteItemArgs proto.InternalMessageInfo

func (m *DeleteItemArgs) GetHeader() ShardOpHeader {
	if m != nil {
		return m.Header
	}
	return ShardOpHeader{}
}

func (m *DeleteItemArgs) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

type DeleteItemRet struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteItemRet) Reset()         { *m = DeleteItemRet{} }
func (m *DeleteItemRet) String() string { return proto.CompactTextString(m) }
func (*DeleteItemRet) ProtoMessage()    {}
func (*DeleteItemRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{8}
}
func (m *DeleteItemRet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteItemRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteItemRet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteItemRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteItemRet.Merge(m, src)
}
func (m *DeleteItemRet) XXX_Size() int {
	return m.Size()
}
func (m *DeleteItemRet) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteItemRet.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteItemRet proto.InternalMessageInfo

type GetItemArgs struct {
	Header               ShardOpHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	ID                   string        `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *GetItemArgs) Reset()         { *m = GetItemArgs{} }
func (m *GetItemArgs) String() string { return proto.CompactTextString(m) }
func (*GetItemArgs) ProtoMessage()    {}
func (*GetItemArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{9}
}
func (m *GetItemArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetItemArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetItemArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetItemArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetItemArgs.Merge(m, src)
}
func (m *GetItemArgs) XXX_Size() int {
	return m.Size()
}
func (m *GetItemArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_GetItemArgs.DiscardUnknown(m)
}

var xxx_messageInfo_GetItemArgs proto.InternalMessageInfo

func (m *GetItemArgs) GetHeader() ShardOpHeader {
	if m != nil {
		return m.Header
	}
	return ShardOpHeader{}
}

func (m *GetItemArgs) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

type GetItemRet struct {
	Item                 Item     `protobuf:"bytes,1,opt,name=item,proto3" json:"item"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetItemRet) Reset()         { *m = GetItemRet{} }
func (m *GetItemRet) String() string { return proto.CompactTextString(m) }
func (*GetItemRet) ProtoMessage()    {}
func (*GetItemRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{10}
}
func (m *GetItemRet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetItemRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetItemRet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetItemRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetItemRet.Merge(m, src)
}
func (m *GetItemRet) XXX_Size() int {
	return m.Size()
}
func (m *GetItemRet) XXX_DiscardUnknown() {
	xxx_messageInfo_GetItemRet.DiscardUnknown(m)
}

var xxx_messageInfo_GetItemRet proto.InternalMessageInfo

func (m *GetItemRet) GetItem() Item {
	if m != nil {
		return m.Item
	}
	return Item{}
}

type ListItemArgs struct {
	Header               ShardOpHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Prefix               string        `protobuf:"bytes,2,opt,name=prefix,proto3" json:"prefix,omitempty"`
	Marker               string        `protobuf:"bytes,3,opt,name=marker,proto3" json:"marker,omitempty"`
	Count                uint64        `protobuf:"varint,4,opt,name=count,proto3" json:"count,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ListItemArgs) Reset()         { *m = ListItemArgs{} }
func (m *ListItemArgs) String() string { return proto.CompactTextString(m) }
func (*ListItemArgs) ProtoMessage()    {}
func (*ListItemArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{11}
}
func (m *ListItemArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListItemArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListItemArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListItemArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListItemArgs.Merge(m, src)
}
func (m *ListItemArgs) XXX_Size() int {
	return m.Size()
}
func (m *ListItemArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_ListItemArgs.DiscardUnknown(m)
}

var xxx_messageInfo_ListItemArgs proto.InternalMessageInfo

func (m *ListItemArgs) GetHeader() ShardOpHeader {
	if m != nil {
		return m.Header
	}
	return ShardOpHeader{}
}

func (m *ListItemArgs) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

func (m *ListItemArgs) GetMarker() string {
	if m != nil {
		return m.Marker
	}
	return ""
}

func (m *ListItemArgs) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

type ListItemRet struct {
	Items                []Item   `protobuf:"bytes,1,rep,name=items,proto3" json:"items"`
	NextMarker           string   `protobuf:"bytes,2,opt,name=nextMarker,proto3" json:"nextMarker,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListItemRet) Reset()         { *m = ListItemRet{} }
func (m *ListItemRet) String() string { return proto.CompactTextString(m) }
func (*ListItemRet) ProtoMessage()    {}
func (*ListItemRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{12}
}
func (m *ListItemRet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListItemRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListItemRet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListItemRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListItemRet.Merge(m, src)
}
func (m *ListItemRet) XXX_Size() int {
	return m.Size()
}
func (m *ListItemRet) XXX_DiscardUnknown() {
	xxx_messageInfo_ListItemRet.DiscardUnknown(m)
}

var xxx_messageInfo_ListItemRet proto.InternalMessageInfo

func (m *ListItemRet) GetItems() []Item {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *ListItemRet) GetNextMarker() string {
	if m != nil {
		return m.NextMarker
	}
	return ""
}

type AddShardArgs struct {
	DiskID               github_com_cubefs_cubefs_blobstore_common_proto.DiskID       `protobuf:"varint,1,opt,name=disk_id,json=diskId,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.DiskID" json:"disk_id,omitempty"`
	Suid                 github_com_cubefs_cubefs_blobstore_common_proto.Suid         `protobuf:"varint,2,opt,name=suid,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.Suid" json:"suid,omitempty"`
	Range                sharding.Range                                               `protobuf:"bytes,3,opt,name=range,proto3" json:"range"`
	Units                []clustermgr.ShardUnit                                       `protobuf:"bytes,4,rep,name=units,proto3" json:"units"`
	RouteVersion         github_com_cubefs_cubefs_blobstore_common_proto.RouteVersion `protobuf:"varint,5,opt,name=route_version,json=routeVersion,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.RouteVersion" json:"route_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                     `json:"-"`
	XXX_unrecognized     []byte                                                       `json:"-"`
	XXX_sizecache        int32                                                        `json:"-"`
}

func (m *AddShardArgs) Reset()         { *m = AddShardArgs{} }
func (m *AddShardArgs) String() string { return proto.CompactTextString(m) }
func (*AddShardArgs) ProtoMessage()    {}
func (*AddShardArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{13}
}
func (m *AddShardArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddShardArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddShardArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddShardArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddShardArgs.Merge(m, src)
}
func (m *AddShardArgs) XXX_Size() int {
	return m.Size()
}
func (m *AddShardArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_AddShardArgs.DiscardUnknown(m)
}

var xxx_messageInfo_AddShardArgs proto.InternalMessageInfo

func (m *AddShardArgs) GetDiskID() github_com_cubefs_cubefs_blobstore_common_proto.DiskID {
	if m != nil {
		return m.DiskID
	}
	return 0
}

func (m *AddShardArgs) GetSuid() github_com_cubefs_cubefs_blobstore_common_proto.Suid {
	if m != nil {
		return m.Suid
	}
	return 0
}

func (m *AddShardArgs) GetRange() sharding.Range {
	if m != nil {
		return m.Range
	}
	return sharding.Range{}
}

func (m *AddShardArgs) GetUnits() []clustermgr.ShardUnit {
	if m != nil {
		return m.Units
	}
	return nil
}

func (m *AddShardArgs) GetRouteVersion() github_com_cubefs_cubefs_blobstore_common_proto.RouteVersion {
	if m != nil {
		return m.RouteVersion
	}
	return 0
}

type AddShardRet struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddShardRet) Reset()         { *m = AddShardRet{} }
func (m *AddShardRet) String() string { return proto.CompactTextString(m) }
func (*AddShardRet) ProtoMessage()    {}
func (*AddShardRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{14}
}
func (m *AddShardRet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddShardRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddShardRet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddShardRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddShardRet.Merge(m, src)
}
func (m *AddShardRet) XXX_Size() int {
	return m.Size()
}
func (m *AddShardRet) XXX_DiscardUnknown() {
	xxx_messageInfo_AddShardRet.DiscardUnknown(m)
}

var xxx_messageInfo_AddShardRet proto.InternalMessageInfo

type UpdateShardArgs struct {
	DiskID               github_com_cubefs_cubefs_blobstore_common_proto.DiskID          `protobuf:"varint,1,opt,name=disk_id,json=diskId,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.DiskID" json:"disk_id,omitempty"`
	Suid                 github_com_cubefs_cubefs_blobstore_common_proto.Suid            `protobuf:"varint,2,opt,name=suid,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.Suid" json:"suid,omitempty"`
	ShardUpdateType      github_com_cubefs_cubefs_blobstore_common_proto.ShardUpdateType `protobuf:"varint,3,opt,name=ShardUpdateType,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.ShardUpdateType" json:"ShardUpdateType,omitempty"`
	Unit                 clustermgr.ShardUnit                                            `protobuf:"bytes,4,opt,name=unit,proto3" json:"unit"`
	XXX_NoUnkeyedLiteral struct{}                                                        `json:"-"`
	XXX_unrecognized     []byte                                                          `json:"-"`
	XXX_sizecache        int32                                                           `json:"-"`
}

func (m *UpdateShardArgs) Reset()         { *m = UpdateShardArgs{} }
func (m *UpdateShardArgs) String() string { return proto.CompactTextString(m) }
func (*UpdateShardArgs) ProtoMessage()    {}
func (*UpdateShardArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{15}
}
func (m *UpdateShardArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateShardArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateShardArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateShardArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateShardArgs.Merge(m, src)
}
func (m *UpdateShardArgs) XXX_Size() int {
	return m.Size()
}
func (m *UpdateShardArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateShardArgs.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateShardArgs proto.InternalMessageInfo

func (m *UpdateShardArgs) GetDiskID() github_com_cubefs_cubefs_blobstore_common_proto.DiskID {
	if m != nil {
		return m.DiskID
	}
	return 0
}

func (m *UpdateShardArgs) GetSuid() github_com_cubefs_cubefs_blobstore_common_proto.Suid {
	if m != nil {
		return m.Suid
	}
	return 0
}

func (m *UpdateShardArgs) GetShardUpdateType() github_com_cubefs_cubefs_blobstore_common_proto.ShardUpdateType {
	if m != nil {
		return m.ShardUpdateType
	}
	return 0
}

func (m *UpdateShardArgs) GetUnit() clustermgr.ShardUnit {
	if m != nil {
		return m.Unit
	}
	return clustermgr.ShardUnit{}
}

type UpdateShardRet struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateShardRet) Reset()         { *m = UpdateShardRet{} }
func (m *UpdateShardRet) String() string { return proto.CompactTextString(m) }
func (*UpdateShardRet) ProtoMessage()    {}
func (*UpdateShardRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{16}
}
func (m *UpdateShardRet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateShardRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateShardRet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateShardRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateShardRet.Merge(m, src)
}
func (m *UpdateShardRet) XXX_Size() int {
	return m.Size()
}
func (m *UpdateShardRet) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateShardRet.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateShardRet proto.InternalMessageInfo

type TransferShardLeaderArgs struct {
	DiskID               github_com_cubefs_cubefs_blobstore_common_proto.DiskID `protobuf:"varint,1,opt,name=disk_id,json=diskId,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.DiskID" json:"disk_id,omitempty"`
	Suid                 github_com_cubefs_cubefs_blobstore_common_proto.Suid   `protobuf:"varint,2,opt,name=suid,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.Suid" json:"suid,omitempty"`
	DestDiskID           github_com_cubefs_cubefs_blobstore_common_proto.DiskID `protobuf:"varint,3,opt,name=dest_disk_id,json=destDiskId,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.DiskID" json:"dest_disk_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                               `json:"-"`
	XXX_unrecognized     []byte                                                 `json:"-"`
	XXX_sizecache        int32                                                  `json:"-"`
}

func (m *TransferShardLeaderArgs) Reset()         { *m = TransferShardLeaderArgs{} }
func (m *TransferShardLeaderArgs) String() string { return proto.CompactTextString(m) }
func (*TransferShardLeaderArgs) ProtoMessage()    {}
func (*TransferShardLeaderArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{17}
}
func (m *TransferShardLeaderArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransferShardLeaderArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransferShardLeaderArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransferShardLeaderArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransferShardLeaderArgs.Merge(m, src)
}
func (m *TransferShardLeaderArgs) XXX_Size() int {
	return m.Size()
}
func (m *TransferShardLeaderArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_TransferShardLeaderArgs.DiscardUnknown(m)
}

var xxx_messageInfo_TransferShardLeaderArgs proto.InternalMessageInfo

func (m *TransferShardLeaderArgs) GetDiskID() github_com_cubefs_cubefs_blobstore_common_proto.DiskID {
	if m != nil {
		return m.DiskID
	}
	return 0
}

func (m *TransferShardLeaderArgs) GetSuid() github_com_cubefs_cubefs_blobstore_common_proto.Suid {
	if m != nil {
		return m.Suid
	}
	return 0
}

func (m *TransferShardLeaderArgs) GetDestDiskID() github_com_cubefs_cubefs_blobstore_common_proto.DiskID {
	if m != nil {
		return m.DestDiskID
	}
	return 0
}

type TransferShardLeaderRet struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TransferShardLeaderRet) Reset()         { *m = TransferShardLeaderRet{} }
func (m *TransferShardLeaderRet) String() string { return proto.CompactTextString(m) }
func (*TransferShardLeaderRet) ProtoMessage()    {}
func (*TransferShardLeaderRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{18}
}
func (m *TransferShardLeaderRet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransferShardLeaderRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransferShardLeaderRet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransferShardLeaderRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransferShardLeaderRet.Merge(m, src)
}
func (m *TransferShardLeaderRet) XXX_Size() int {
	return m.Size()
}
func (m *TransferShardLeaderRet) XXX_DiscardUnknown() {
	xxx_messageInfo_TransferShardLeaderRet.DiscardUnknown(m)
}

var xxx_messageInfo_TransferShardLeaderRet proto.InternalMessageInfo

type GetShardArgs struct {
	DiskID               github_com_cubefs_cubefs_blobstore_common_proto.DiskID `protobuf:"varint,1,opt,name=disk_id,json=diskId,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.DiskID" json:"disk_id,omitempty"`
	Suid                 github_com_cubefs_cubefs_blobstore_common_proto.Suid   `protobuf:"varint,2,opt,name=suid,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.Suid" json:"suid,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                               `json:"-"`
	XXX_unrecognized     []byte                                                 `json:"-"`
	XXX_sizecache        int32                                                  `json:"-"`
}

func (m *GetShardArgs) Reset()         { *m = GetShardArgs{} }
func (m *GetShardArgs) String() string { return proto.CompactTextString(m) }
func (*GetShardArgs) ProtoMessage()    {}
func (*GetShardArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{19}
}
func (m *GetShardArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetShardArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetShardArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetShardArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetShardArgs.Merge(m, src)
}
func (m *GetShardArgs) XXX_Size() int {
	return m.Size()
}
func (m *GetShardArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_GetShardArgs.DiscardUnknown(m)
}

var xxx_messageInfo_GetShardArgs proto.InternalMessageInfo

func (m *GetShardArgs) GetDiskID() github_com_cubefs_cubefs_blobstore_common_proto.DiskID {
	if m != nil {
		return m.DiskID
	}
	return 0
}

func (m *GetShardArgs) GetSuid() github_com_cubefs_cubefs_blobstore_common_proto.Suid {
	if m != nil {
		return m.Suid
	}
	return 0
}

type GetShardRet struct {
	Shard                clustermgr.ShardUnitInfo `protobuf:"bytes,1,opt,name=shard,proto3" json:"shard"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *GetShardRet) Reset()         { *m = GetShardRet{} }
func (m *GetShardRet) String() string { return proto.CompactTextString(m) }
func (*GetShardRet) ProtoMessage()    {}
func (*GetShardRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{20}
}
func (m *GetShardRet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetShardRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetShardRet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetShardRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetShardRet.Merge(m, src)
}
func (m *GetShardRet) XXX_Size() int {
	return m.Size()
}
func (m *GetShardRet) XXX_DiscardUnknown() {
	xxx_messageInfo_GetShardRet.DiscardUnknown(m)
}

var xxx_messageInfo_GetShardRet proto.InternalMessageInfo

func (m *GetShardRet) GetShard() clustermgr.ShardUnitInfo {
	if m != nil {
		return m.Shard
	}
	return clustermgr.ShardUnitInfo{}
}

type CreateBlobArgs struct {
	Header               ShardOpHeader                                               `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Name                 string                                                      `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	CodeMode             github_com_cubefs_cubefs_blobstore_common_codemode.CodeMode `protobuf:"varint,3,opt,name=codemode,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/codemode.CodeMode" json:"codemode,omitempty"`
	Size_                uint64                                                      `protobuf:"varint,4,opt,name=size,proto3" json:"size,omitempty"`
	SliceSize            uint32                                                      `protobuf:"varint,5,opt,name=slice_size,json=sliceSize,proto3" json:"slice_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                    `json:"-"`
	XXX_unrecognized     []byte                                                      `json:"-"`
	XXX_sizecache        int32                                                       `json:"-"`
}

func (m *CreateBlobArgs) Reset()         { *m = CreateBlobArgs{} }
func (m *CreateBlobArgs) String() string { return proto.CompactTextString(m) }
func (*CreateBlobArgs) ProtoMessage()    {}
func (*CreateBlobArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{21}
}
func (m *CreateBlobArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateBlobArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateBlobArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateBlobArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateBlobArgs.Merge(m, src)
}
func (m *CreateBlobArgs) XXX_Size() int {
	return m.Size()
}
func (m *CreateBlobArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateBlobArgs.DiscardUnknown(m)
}

var xxx_messageInfo_CreateBlobArgs proto.InternalMessageInfo

func (m *CreateBlobArgs) GetHeader() ShardOpHeader {
	if m != nil {
		return m.Header
	}
	return ShardOpHeader{}
}

func (m *CreateBlobArgs) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CreateBlobArgs) GetCodeMode() github_com_cubefs_cubefs_blobstore_common_codemode.CodeMode {
	if m != nil {
		return m.CodeMode
	}
	return 0
}

func (m *CreateBlobArgs) GetSize_() uint64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *CreateBlobArgs) GetSliceSize() uint32 {
	if m != nil {
		return m.SliceSize
	}
	return 0
}

type CreateBlobRet struct {
	Blob                 proto1.Blob `protobuf:"bytes,1,opt,name=blob,proto3" json:"blob"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *CreateBlobRet) Reset()         { *m = CreateBlobRet{} }
func (m *CreateBlobRet) String() string { return proto.CompactTextString(m) }
func (*CreateBlobRet) ProtoMessage()    {}
func (*CreateBlobRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{22}
}
func (m *CreateBlobRet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateBlobRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateBlobRet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateBlobRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateBlobRet.Merge(m, src)
}
func (m *CreateBlobRet) XXX_Size() int {
	return m.Size()
}
func (m *CreateBlobRet) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateBlobRet.DiscardUnknown(m)
}

var xxx_messageInfo_CreateBlobRet proto.InternalMessageInfo

func (m *CreateBlobRet) GetBlob() proto1.Blob {
	if m != nil {
		return m.Blob
	}
	return proto1.Blob{}
}

type GetBlobArgs struct {
	Header               ShardOpHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Name                 string        `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *GetBlobArgs) Reset()         { *m = GetBlobArgs{} }
func (m *GetBlobArgs) String() string { return proto.CompactTextString(m) }
func (*GetBlobArgs) ProtoMessage()    {}
func (*GetBlobArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{23}
}
func (m *GetBlobArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetBlobArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetBlobArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetBlobArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetBlobArgs.Merge(m, src)
}
func (m *GetBlobArgs) XXX_Size() int {
	return m.Size()
}
func (m *GetBlobArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_GetBlobArgs.DiscardUnknown(m)
}

var xxx_messageInfo_GetBlobArgs proto.InternalMessageInfo

func (m *GetBlobArgs) GetHeader() ShardOpHeader {
	if m != nil {
		return m.Header
	}
	return ShardOpHeader{}
}

func (m *GetBlobArgs) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type GetBlobRet struct {
	Blob                 proto1.Blob `protobuf:"bytes,1,opt,name=blob,proto3" json:"blob"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *GetBlobRet) Reset()         { *m = GetBlobRet{} }
func (m *GetBlobRet) String() string { return proto.CompactTextString(m) }
func (*GetBlobRet) ProtoMessage()    {}
func (*GetBlobRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{24}
}
func (m *GetBlobRet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetBlobRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetBlobRet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetBlobRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetBlobRet.Merge(m, src)
}
func (m *GetBlobRet) XXX_Size() int {
	return m.Size()
}
func (m *GetBlobRet) XXX_DiscardUnknown() {
	xxx_messageInfo_GetBlobRet.DiscardUnknown(m)
}

var xxx_messageInfo_GetBlobRet proto.InternalMessageInfo

func (m *GetBlobRet) GetBlob() proto1.Blob {
	if m != nil {
		return m.Blob
	}
	return proto1.Blob{}
}

type ListBlobArgs struct {
	Header               ShardOpHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Prefix               string        `protobuf:"bytes,2,opt,name=prefix,proto3" json:"prefix,omitempty"`
	Marker               string        `protobuf:"bytes,3,opt,name=marker,proto3" json:"marker,omitempty"`
	Count                uint64        `protobuf:"varint,4,opt,name=count,proto3" json:"count,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ListBlobArgs) Reset()         { *m = ListBlobArgs{} }
func (m *ListBlobArgs) String() string { return proto.CompactTextString(m) }
func (*ListBlobArgs) ProtoMessage()    {}
func (*ListBlobArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{25}
}
func (m *ListBlobArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListBlobArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListBlobArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListBlobArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListBlobArgs.Merge(m, src)
}
func (m *ListBlobArgs) XXX_Size() int {
	return m.Size()
}
func (m *ListBlobArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_ListBlobArgs.DiscardUnknown(m)
}

var xxx_messageInfo_ListBlobArgs proto.InternalMessageInfo

func (m *ListBlobArgs) GetHeader() ShardOpHeader {
	if m != nil {
		return m.Header
	}
	return ShardOpHeader{}
}

func (m *ListBlobArgs) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

func (m *ListBlobArgs) GetMarker() string {
	if m != nil {
		return m.Marker
	}
	return ""
}

func (m *ListBlobArgs) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

type ListBlobRet struct {
	Blobs                []proto1.Blob `protobuf:"bytes,1,rep,name=blobs,proto3" json:"blobs"`
	NextMarker           string        `protobuf:"bytes,2,opt,name=nextMarker,proto3" json:"nextMarker,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ListBlobRet) Reset()         { *m = ListBlobRet{} }
func (m *ListBlobRet) String() string { return proto.CompactTextString(m) }
func (*ListBlobRet) ProtoMessage()    {}
func (*ListBlobRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{26}
}
func (m *ListBlobRet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListBlobRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListBlobRet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListBlobRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListBlobRet.Merge(m, src)
}
func (m *ListBlobRet) XXX_Size() int {
	return m.Size()
}
func (m *ListBlobRet) XXX_DiscardUnknown() {
	xxx_messageInfo_ListBlobRet.DiscardUnknown(m)
}

var xxx_messageInfo_ListBlobRet proto.InternalMessageInfo

func (m *ListBlobRet) GetBlobs() []proto1.Blob {
	if m != nil {
		return m.Blobs
	}
	return nil
}

func (m *ListBlobRet) GetNextMarker() string {
	if m != nil {
		return m.NextMarker
	}
	return ""
}

type DeleteBlobArgs struct {
	Header               ShardOpHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Name                 string        `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *DeleteBlobArgs) Reset()         { *m = DeleteBlobArgs{} }
func (m *DeleteBlobArgs) String() string { return proto.CompactTextString(m) }
func (*DeleteBlobArgs) ProtoMessage()    {}
func (*DeleteBlobArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{27}
}
func (m *DeleteBlobArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteBlobArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteBlobArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteBlobArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteBlobArgs.Merge(m, src)
}
func (m *DeleteBlobArgs) XXX_Size() int {
	return m.Size()
}
func (m *DeleteBlobArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteBlobArgs.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteBlobArgs proto.InternalMessageInfo

func (m *DeleteBlobArgs) GetHeader() ShardOpHeader {
	if m != nil {
		return m.Header
	}
	return ShardOpHeader{}
}

func (m *DeleteBlobArgs) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type DeleteBlobRet struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteBlobRet) Reset()         { *m = DeleteBlobRet{} }
func (m *DeleteBlobRet) String() string { return proto.CompactTextString(m) }
func (*DeleteBlobRet) ProtoMessage()    {}
func (*DeleteBlobRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{28}
}
func (m *DeleteBlobRet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteBlobRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteBlobRet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteBlobRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteBlobRet.Merge(m, src)
}
func (m *DeleteBlobRet) XXX_Size() int {
	return m.Size()
}
func (m *DeleteBlobRet) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteBlobRet.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteBlobRet proto.InternalMessageInfo

type RetainBlobArgs struct {
	Header               ShardOpHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Name                 string        `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Lease                uint64        `protobuf:"varint,3,opt,name=lease,proto3" json:"lease,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *RetainBlobArgs) Reset()         { *m = RetainBlobArgs{} }
func (m *RetainBlobArgs) String() string { return proto.CompactTextString(m) }
func (*RetainBlobArgs) ProtoMessage()    {}
func (*RetainBlobArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{29}
}
func (m *RetainBlobArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RetainBlobArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RetainBlobArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RetainBlobArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RetainBlobArgs.Merge(m, src)
}
func (m *RetainBlobArgs) XXX_Size() int {
	return m.Size()
}
func (m *RetainBlobArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_RetainBlobArgs.DiscardUnknown(m)
}

var xxx_messageInfo_RetainBlobArgs proto.InternalMessageInfo

func (m *RetainBlobArgs) GetHeader() ShardOpHeader {
	if m != nil {
		return m.Header
	}
	return ShardOpHeader{}
}

func (m *RetainBlobArgs) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RetainBlobArgs) GetLease() uint64 {
	if m != nil {
		return m.Lease
	}
	return 0
}

type RetainBlobRet struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RetainBlobRet) Reset()         { *m = RetainBlobRet{} }
func (m *RetainBlobRet) String() string { return proto.CompactTextString(m) }
func (*RetainBlobRet) ProtoMessage()    {}
func (*RetainBlobRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{30}
}
func (m *RetainBlobRet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RetainBlobRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RetainBlobRet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RetainBlobRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RetainBlobRet.Merge(m, src)
}
func (m *RetainBlobRet) XXX_Size() int {
	return m.Size()
}
func (m *RetainBlobRet) XXX_DiscardUnknown() {
	xxx_messageInfo_RetainBlobRet.DiscardUnknown(m)
}

var xxx_messageInfo_RetainBlobRet proto.InternalMessageInfo

type SealBlobArgs struct {
	Header               ShardOpHeader  `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Size_                uint64         `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`
	Name                 string         `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Slices               []proto1.Slice `protobuf:"bytes,4,rep,name=slices,proto3" json:"slices"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *SealBlobArgs) Reset()         { *m = SealBlobArgs{} }
func (m *SealBlobArgs) String() string { return proto.CompactTextString(m) }
func (*SealBlobArgs) ProtoMessage()    {}
func (*SealBlobArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{31}
}
func (m *SealBlobArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SealBlobArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SealBlobArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SealBlobArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SealBlobArgs.Merge(m, src)
}
func (m *SealBlobArgs) XXX_Size() int {
	return m.Size()
}
func (m *SealBlobArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_SealBlobArgs.DiscardUnknown(m)
}

var xxx_messageInfo_SealBlobArgs proto.InternalMessageInfo

func (m *SealBlobArgs) GetHeader() ShardOpHeader {
	if m != nil {
		return m.Header
	}
	return ShardOpHeader{}
}

func (m *SealBlobArgs) GetSize_() uint64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *SealBlobArgs) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SealBlobArgs) GetSlices() []proto1.Slice {
	if m != nil {
		return m.Slices
	}
	return nil
}

type SealBlobRet struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SealBlobRet) Reset()         { *m = SealBlobRet{} }
func (m *SealBlobRet) String() string { return proto.CompactTextString(m) }
func (*SealBlobRet) ProtoMessage()    {}
func (*SealBlobRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{32}
}
func (m *SealBlobRet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SealBlobRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SealBlobRet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SealBlobRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SealBlobRet.Merge(m, src)
}
func (m *SealBlobRet) XXX_Size() int {
	return m.Size()
}
func (m *SealBlobRet) XXX_DiscardUnknown() {
	xxx_messageInfo_SealBlobRet.DiscardUnknown(m)
}

var xxx_messageInfo_SealBlobRet proto.InternalMessageInfo

type AllocSliceArgs struct {
	Header               ShardOpHeader                                               `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Name                 string                                                      `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	CodeMode             github_com_cubefs_cubefs_blobstore_common_codemode.CodeMode `protobuf:"varint,3,opt,name=codemode,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/codemode.CodeMode" json:"codemode,omitempty"`
	Size_                uint64                                                      `protobuf:"varint,4,opt,name=size,proto3" json:"size,omitempty"`
	FailedSlice          proto1.Slice                                                `protobuf:"bytes,5,opt,name=failed_slice,json=failedSlice,proto3" json:"failed_slice"`
	XXX_NoUnkeyedLiteral struct{}                                                    `json:"-"`
	XXX_unrecognized     []byte                                                      `json:"-"`
	XXX_sizecache        int32                                                       `json:"-"`
}

func (m *AllocSliceArgs) Reset()         { *m = AllocSliceArgs{} }
func (m *AllocSliceArgs) String() string { return proto.CompactTextString(m) }
func (*AllocSliceArgs) ProtoMessage()    {}
func (*AllocSliceArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{33}
}
func (m *AllocSliceArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllocSliceArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AllocSliceArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AllocSliceArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllocSliceArgs.Merge(m, src)
}
func (m *AllocSliceArgs) XXX_Size() int {
	return m.Size()
}
func (m *AllocSliceArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_AllocSliceArgs.DiscardUnknown(m)
}

var xxx_messageInfo_AllocSliceArgs proto.InternalMessageInfo

func (m *AllocSliceArgs) GetHeader() ShardOpHeader {
	if m != nil {
		return m.Header
	}
	return ShardOpHeader{}
}

func (m *AllocSliceArgs) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AllocSliceArgs) GetCodeMode() github_com_cubefs_cubefs_blobstore_common_codemode.CodeMode {
	if m != nil {
		return m.CodeMode
	}
	return 0
}

func (m *AllocSliceArgs) GetSize_() uint64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *AllocSliceArgs) GetFailedSlice() proto1.Slice {
	if m != nil {
		return m.FailedSlice
	}
	return proto1.Slice{}
}

type AllocSliceRet struct {
	Slices               []proto1.Slice `protobuf:"bytes,1,rep,name=slices,proto3" json:"slices"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *AllocSliceRet) Reset()         { *m = AllocSliceRet{} }
func (m *AllocSliceRet) String() string { return proto.CompactTextString(m) }
func (*AllocSliceRet) ProtoMessage()    {}
func (*AllocSliceRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{34}
}
func (m *AllocSliceRet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllocSliceRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AllocSliceRet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AllocSliceRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllocSliceRet.Merge(m, src)
}
func (m *AllocSliceRet) XXX_Size() int {
	return m.Size()
}
func (m *AllocSliceRet) XXX_DiscardUnknown() {
	xxx_messageInfo_AllocSliceRet.DiscardUnknown(m)
}

var xxx_messageInfo_AllocSliceRet proto.InternalMessageInfo

func (m *AllocSliceRet) GetSlices() []proto1.Slice {
	if m != nil {
		return m.Slices
	}
	return nil
}

type ShardStats struct {
	Suid                 github_com_cubefs_cubefs_blobstore_common_proto.Suid         `protobuf:"varint,1,opt,name=suid,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.Suid" json:"suid,omitempty"`
	AppliedIndex         uint64                                                       `protobuf:"varint,2,opt,name=applied_index,json=appliedIndex,proto3" json:"applied_index,omitempty"`
	LeaderHost           string                                                       `protobuf:"bytes,3,opt,name=leader_host,json=leaderHost,proto3" json:"leader_host,omitempty"`
	LeaderDiskID         github_com_cubefs_cubefs_blobstore_common_proto.DiskID       `protobuf:"varint,4,opt,name=leader_disk_id,json=leaderDiskId,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.DiskID" json:"leader_disk_id,omitempty"`
	LeaderSuid           github_com_cubefs_cubefs_blobstore_common_proto.Suid         `protobuf:"varint,5,opt,name=leader_suid,json=leaderSuid,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.Suid" json:"leader_suid,omitempty"`
	Learner              bool                                                         `protobuf:"varint,6,opt,name=learner,proto3" json:"learner,omitempty"`
	RouteVersion         github_com_cubefs_cubefs_blobstore_common_proto.RouteVersion `protobuf:"varint,7,opt,name=route_version,json=routeVersion,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.RouteVersion" json:"route_version,omitempty"`
	Range                sharding.Range                                               `protobuf:"bytes,8,opt,name=range,proto3" json:"range"`
	Units                []clustermgr.ShardUnit                                       `protobuf:"bytes,9,rep,name=units,proto3" json:"units"`
	RaftStat             raft.Stat                                                    `protobuf:"bytes,10,opt,name=raftStat,proto3" json:"raftStat"`
	XXX_NoUnkeyedLiteral struct{}                                                     `json:"-"`
	XXX_unrecognized     []byte                                                       `json:"-"`
	XXX_sizecache        int32                                                        `json:"-"`
}

func (m *ShardStats) Reset()         { *m = ShardStats{} }
func (m *ShardStats) String() string { return proto.CompactTextString(m) }
func (*ShardStats) ProtoMessage()    {}
func (*ShardStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{35}
}
func (m *ShardStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardStats.Merge(m, src)
}
func (m *ShardStats) XXX_Size() int {
	return m.Size()
}
func (m *ShardStats) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardStats.DiscardUnknown(m)
}

var xxx_messageInfo_ShardStats proto.InternalMessageInfo

func (m *ShardStats) GetSuid() github_com_cubefs_cubefs_blobstore_common_proto.Suid {
	if m != nil {
		return m.Suid
	}
	return 0
}

func (m *ShardStats) GetAppliedIndex() uint64 {
	if m != nil {
		return m.AppliedIndex
	}
	return 0
}

func (m *ShardStats) GetLeaderHost() string {
	if m != nil {
		return m.LeaderHost
	}
	return ""
}

func (m *ShardStats) GetLeaderDiskID() github_com_cubefs_cubefs_blobstore_common_proto.DiskID {
	if m != nil {
		return m.LeaderDiskID
	}
	return 0
}

func (m *ShardStats) GetLeaderSuid() github_com_cubefs_cubefs_blobstore_common_proto.Suid {
	if m != nil {
		return m.LeaderSuid
	}
	return 0
}

func (m *ShardStats) GetLearner() bool {
	if m != nil {
		return m.Learner
	}
	return false
}

func (m *ShardStats) GetRouteVersion() github_com_cubefs_cubefs_blobstore_common_proto.RouteVersion {
	if m != nil {
		return m.RouteVersion
	}
	return 0
}

func (m *ShardStats) GetRange() sharding.Range {
	if m != nil {
		return m.Range
	}
	return sharding.Range{}
}

func (m *ShardStats) GetUnits() []clustermgr.ShardUnit {
	if m != nil {
		return m.Units
	}
	return nil
}

func (m *ShardStats) GetRaftStat() raft.Stat {
	if m != nil {
		return m.RaftStat
	}
	return raft.Stat{}
}

type ListVolumeArgs struct {
	CodeMode             github_com_cubefs_cubefs_blobstore_common_codemode.CodeMode `protobuf:"varint,1,opt,name=codemode,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/codemode.CodeMode" json:"codemode,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                    `json:"-"`
	XXX_unrecognized     []byte                                                      `json:"-"`
	XXX_sizecache        int32                                                       `json:"-"`
}

func (m *ListVolumeArgs) Reset()         { *m = ListVolumeArgs{} }
func (m *ListVolumeArgs) String() string { return proto.CompactTextString(m) }
func (*ListVolumeArgs) ProtoMessage()    {}
func (*ListVolumeArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{36}
}
func (m *ListVolumeArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListVolumeArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListVolumeArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListVolumeArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListVolumeArgs.Merge(m, src)
}
func (m *ListVolumeArgs) XXX_Size() int {
	return m.Size()
}
func (m *ListVolumeArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_ListVolumeArgs.DiscardUnknown(m)
}

var xxx_messageInfo_ListVolumeArgs proto.InternalMessageInfo

func (m *ListVolumeArgs) GetCodeMode() github_com_cubefs_cubefs_blobstore_common_codemode.CodeMode {
	if m != nil {
		return m.CodeMode
	}
	return 0
}

type ListVolumeRet struct {
	Vids                 []github_com_cubefs_cubefs_blobstore_common_proto.Vid `protobuf:"varint,1,rep,packed,name=vids,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.Vid" json:"vids,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                              `json:"-"`
	XXX_unrecognized     []byte                                                `json:"-"`
	XXX_sizecache        int32                                                 `json:"-"`
}

func (m *ListVolumeRet) Reset()         { *m = ListVolumeRet{} }
func (m *ListVolumeRet) String() string { return proto.CompactTextString(m) }
func (*ListVolumeRet) ProtoMessage()    {}
func (*ListVolumeRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{37}
}
func (m *ListVolumeRet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListVolumeRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListVolumeRet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListVolumeRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListVolumeRet.Merge(m, src)
}
func (m *ListVolumeRet) XXX_Size() int {
	return m.Size()
}
func (m *ListVolumeRet) XXX_DiscardUnknown() {
	xxx_messageInfo_ListVolumeRet.DiscardUnknown(m)
}

var xxx_messageInfo_ListVolumeRet proto.InternalMessageInfo

func (m *ListVolumeRet) GetVids() []github_com_cubefs_cubefs_blobstore_common_proto.Vid {
	if m != nil {
		return m.Vids
	}
	return nil
}

type ListShardArgs struct {
	DiskID               github_com_cubefs_cubefs_blobstore_common_proto.DiskID  `protobuf:"varint,1,opt,name=disk_id,json=diskId,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.DiskID" json:"disk_id,omitempty"`
	ShardID              github_com_cubefs_cubefs_blobstore_common_proto.ShardID `protobuf:"varint,2,opt,name=shard_id,json=shardId,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.ShardID" json:"shard_id,omitempty"`
	Count                uint64                                                  `protobuf:"varint,3,opt,name=count,proto3" json:"count,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                `json:"-"`
	XXX_unrecognized     []byte                                                  `json:"-"`
	XXX_sizecache        int32                                                   `json:"-"`
}

func (m *ListShardArgs) Reset()         { *m = ListShardArgs{} }
func (m *ListShardArgs) String() string { return proto.CompactTextString(m) }
func (*ListShardArgs) ProtoMessage()    {}
func (*ListShardArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{38}
}
func (m *ListShardArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListShardArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListShardArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListShardArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListShardArgs.Merge(m, src)
}
func (m *ListShardArgs) XXX_Size() int {
	return m.Size()
}
func (m *ListShardArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_ListShardArgs.DiscardUnknown(m)
}

var xxx_messageInfo_ListShardArgs proto.InternalMessageInfo

func (m *ListShardArgs) GetDiskID() github_com_cubefs_cubefs_blobstore_common_proto.DiskID {
	if m != nil {
		return m.DiskID
	}
	return 0
}

func (m *ListShardArgs) GetShardID() github_com_cubefs_cubefs_blobstore_common_proto.ShardID {
	if m != nil {
		return m.ShardID
	}
	return 0
}

func (m *ListShardArgs) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

type ListShardBaseInfo struct {
	DiskID               github_com_cubefs_cubefs_blobstore_common_proto.DiskID  `protobuf:"varint,1,opt,name=disk_id,json=diskId,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.DiskID" json:"disk_id,omitempty"`
	ShardID              github_com_cubefs_cubefs_blobstore_common_proto.ShardID `protobuf:"varint,2,opt,name=shard_id,json=shardId,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.ShardID" json:"shard_id,omitempty"`
	Suid                 github_com_cubefs_cubefs_blobstore_common_proto.Suid    `protobuf:"varint,3,opt,name=suid,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.Suid" json:"suid,omitempty"`
	Index                uint32                                                  `protobuf:"varint,4,opt,name=index,proto3" json:"index,omitempty"`
	Epoch                uint32                                                  `protobuf:"varint,5,opt,name=epoch,proto3" json:"epoch,omitempty"`
	Units                []clustermgr.ShardUnit                                  `protobuf:"bytes,6,rep,name=units,proto3" json:"units"`
	XXX_NoUnkeyedLiteral struct{}                                                `json:"-"`
	XXX_unrecognized     []byte                                                  `json:"-"`
	XXX_sizecache        int32                                                   `json:"-"`
}

func (m *ListShardBaseInfo) Reset()         { *m = ListShardBaseInfo{} }
func (m *ListShardBaseInfo) String() string { return proto.CompactTextString(m) }
func (*ListShardBaseInfo) ProtoMessage()    {}
func (*ListShardBaseInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{39}
}
func (m *ListShardBaseInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListShardBaseInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListShardBaseInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListShardBaseInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListShardBaseInfo.Merge(m, src)
}
func (m *ListShardBaseInfo) XXX_Size() int {
	return m.Size()
}
func (m *ListShardBaseInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ListShardBaseInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ListShardBaseInfo proto.InternalMessageInfo

func (m *ListShardBaseInfo) GetDiskID() github_com_cubefs_cubefs_blobstore_common_proto.DiskID {
	if m != nil {
		return m.DiskID
	}
	return 0
}

func (m *ListShardBaseInfo) GetShardID() github_com_cubefs_cubefs_blobstore_common_proto.ShardID {
	if m != nil {
		return m.ShardID
	}
	return 0
}

func (m *ListShardBaseInfo) GetSuid() github_com_cubefs_cubefs_blobstore_common_proto.Suid {
	if m != nil {
		return m.Suid
	}
	return 0
}

func (m *ListShardBaseInfo) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *ListShardBaseInfo) GetEpoch() uint32 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *ListShardBaseInfo) GetUnits() []clustermgr.ShardUnit {
	if m != nil {
		return m.Units
	}
	return nil
}

type ListShardRet struct {
	Shards               []ListShardBaseInfo `protobuf:"bytes,1,rep,name=shards,proto3" json:"shards"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *ListShardRet) Reset()         { *m = ListShardRet{} }
func (m *ListShardRet) String() string { return proto.CompactTextString(m) }
func (*ListShardRet) ProtoMessage()    {}
func (*ListShardRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{40}
}
func (m *ListShardRet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListShardRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListShardRet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListShardRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListShardRet.Merge(m, src)
}
func (m *ListShardRet) XXX_Size() int {
	return m.Size()
}
func (m *ListShardRet) XXX_DiscardUnknown() {
	xxx_messageInfo_ListShardRet.DiscardUnknown(m)
}

var xxx_messageInfo_ListShardRet proto.InternalMessageInfo

func (m *ListShardRet) GetShards() []ListShardBaseInfo {
	if m != nil {
		return m.Shards
	}
	return nil
}

type TCMallocArgs struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TCMallocArgs) Reset()         { *m = TCMallocArgs{} }
func (m *TCMallocArgs) String() string { return proto.CompactTextString(m) }
func (*TCMallocArgs) ProtoMessage()    {}
func (*TCMallocArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{41}
}
func (m *TCMallocArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TCMallocArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TCMallocArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TCMallocArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TCMallocArgs.Merge(m, src)
}
func (m *TCMallocArgs) XXX_Size() int {
	return m.Size()
}
func (m *TCMallocArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_TCMallocArgs.DiscardUnknown(m)
}

var xxx_messageInfo_TCMallocArgs proto.InternalMessageInfo

type TCMallocRet struct {
	Stats                string   `protobuf:"bytes,1,opt,name=stats,proto3" json:"stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TCMallocRet) Reset()         { *m = TCMallocRet{} }
func (m *TCMallocRet) String() string { return proto.CompactTextString(m) }
func (*TCMallocRet) ProtoMessage()    {}
func (*TCMallocRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{42}
}
func (m *TCMallocRet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TCMallocRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TCMallocRet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TCMallocRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TCMallocRet.Merge(m, src)
}
func (m *TCMallocRet) XXX_Size() int {
	return m.Size()
}
func (m *TCMallocRet) XXX_DiscardUnknown() {
	xxx_messageInfo_TCMallocRet.DiscardUnknown(m)
}

var xxx_messageInfo_TCMallocRet proto.InternalMessageInfo

func (m *TCMallocRet) GetStats() string {
	if m != nil {
		return m.Stats
	}
	return ""
}

type DBStatsArgs struct {
	DiskID               github_com_cubefs_cubefs_blobstore_common_proto.DiskID `protobuf:"varint,1,opt,name=disk_id,json=diskId,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.DiskID" json:"disk_id,omitempty"`
	DBName               string                                                 `protobuf:"bytes,2,opt,name=db_name,json=dbName,proto3" json:"db_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                               `json:"-"`
	XXX_unrecognized     []byte                                                 `json:"-"`
	XXX_sizecache        int32                                                  `json:"-"`
}

func (m *DBStatsArgs) Reset()         { *m = DBStatsArgs{} }
func (m *DBStatsArgs) String() string { return proto.CompactTextString(m) }
func (*DBStatsArgs) ProtoMessage()    {}
func (*DBStatsArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{43}
}
func (m *DBStatsArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DBStatsArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DBStatsArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DBStatsArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DBStatsArgs.Merge(m, src)
}
func (m *DBStatsArgs) XXX_Size() int {
	return m.Size()
}
func (m *DBStatsArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_DBStatsArgs.DiscardUnknown(m)
}

var xxx_messageInfo_DBStatsArgs proto.InternalMessageInfo

func (m *DBStatsArgs) GetDiskID() github_com_cubefs_cubefs_blobstore_common_proto.DiskID {
	if m != nil {
		return m.DiskID
	}
	return 0
}

func (m *DBStatsArgs) GetDBName() string {
	if m != nil {
		return m.DBName
	}
	return ""
}

type DBStatsRet struct {
	Used                 uint64   `protobuf:"varint,1,opt,name=used,proto3" json:"used,omitempty"`
	BlobCacheUsage       uint64   `protobuf:"varint,2,opt,name=blob_cache_usage,json=blobCacheUsage,proto3" json:"blob_cache_usage,omitempty"`
	IndexAndFilterUsage  uint64   `protobuf:"varint,3,opt,name=index_and_filter_usage,json=indexAndFilterUsage,proto3" json:"index_and_filter_usage,omitempty"`
	MemtableUsage        uint64   `protobuf:"varint,4,opt,name=memtable_usage,json=memtableUsage,proto3" json:"memtable_usage,omitempty"`
	BlockPinnedUsage     uint64   `protobuf:"varint,5,opt,name=block_pinned_usage,json=blockPinnedUsage,proto3" json:"block_pinned_usage,omitempty"`
	TotalMemoryUsage     uint64   `protobuf:"varint,6,opt,name=total_memory_usage,json=totalMemoryUsage,proto3" json:"total_memory_usage,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DBStatsRet) Reset()         { *m = DBStatsRet{} }
func (m *DBStatsRet) String() string { return proto.CompactTextString(m) }
func (*DBStatsRet) ProtoMessage()    {}
func (*DBStatsRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{44}
}
func (m *DBStatsRet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DBStatsRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DBStatsRet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DBStatsRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DBStatsRet.Merge(m, src)
}
func (m *DBStatsRet) XXX_Size() int {
	return m.Size()
}
func (m *DBStatsRet) XXX_DiscardUnknown() {
	xxx_messageInfo_DBStatsRet.DiscardUnknown(m)
}

var xxx_messageInfo_DBStatsRet proto.InternalMessageInfo

func (m *DBStatsRet) GetUsed() uint64 {
	if m != nil {
		return m.Used
	}
	return 0
}

func (m *DBStatsRet) GetBlobCacheUsage() uint64 {
	if m != nil {
		return m.BlobCacheUsage
	}
	return 0
}

func (m *DBStatsRet) GetIndexAndFilterUsage() uint64 {
	if m != nil {
		return m.IndexAndFilterUsage
	}
	return 0
}

func (m *DBStatsRet) GetMemtableUsage() uint64 {
	if m != nil {
		return m.MemtableUsage
	}
	return 0
}

func (m *DBStatsRet) GetBlockPinnedUsage() uint64 {
	if m != nil {
		return m.BlockPinnedUsage
	}
	return 0
}

func (m *DBStatsRet) GetTotalMemoryUsage() uint64 {
	if m != nil {
		return m.TotalMemoryUsage
	}
	return 0
}

type DeleteBlobRawArgs struct {
	Header               ShardOpHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Slice                proto1.Slice  `protobuf:"bytes,2,opt,name=slice,proto3" json:"slice"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *DeleteBlobRawArgs) Reset()         { *m = DeleteBlobRawArgs{} }
func (m *DeleteBlobRawArgs) String() string { return proto.CompactTextString(m) }
func (*DeleteBlobRawArgs) ProtoMessage()    {}
func (*DeleteBlobRawArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{45}
}
func (m *DeleteBlobRawArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteBlobRawArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteBlobRawArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteBlobRawArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteBlobRawArgs.Merge(m, src)
}
func (m *DeleteBlobRawArgs) XXX_Size() int {
	return m.Size()
}
func (m *DeleteBlobRawArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteBlobRawArgs.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteBlobRawArgs proto.InternalMessageInfo

func (m *DeleteBlobRawArgs) GetHeader() ShardOpHeader {
	if m != nil {
		return m.Header
	}
	return ShardOpHeader{}
}

func (m *DeleteBlobRawArgs) GetSlice() proto1.Slice {
	if m != nil {
		return m.Slice
	}
	return proto1.Slice{}
}

type DeleteBlobRawRet struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteBlobRawRet) Reset()         { *m = DeleteBlobRawRet{} }
func (m *DeleteBlobRawRet) String() string { return proto.CompactTextString(m) }
func (*DeleteBlobRawRet) ProtoMessage()    {}
func (*DeleteBlobRawRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{46}
}
func (m *DeleteBlobRawRet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteBlobRawRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteBlobRawRet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteBlobRawRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteBlobRawRet.Merge(m, src)
}
func (m *DeleteBlobRawRet) XXX_Size() int {
	return m.Size()
}
func (m *DeleteBlobRawRet) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteBlobRawRet.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteBlobRawRet proto.InternalMessageInfo

type DeleteBlobStatsArgs struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteBlobStatsArgs) Reset()         { *m = DeleteBlobStatsArgs{} }
func (m *DeleteBlobStatsArgs) String() string { return proto.CompactTextString(m) }
func (*DeleteBlobStatsArgs) ProtoMessage()    {}
func (*DeleteBlobStatsArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{47}
}
func (m *DeleteBlobStatsArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteBlobStatsArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteBlobStatsArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteBlobStatsArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteBlobStatsArgs.Merge(m, src)
}
func (m *DeleteBlobStatsArgs) XXX_Size() int {
	return m.Size()
}
func (m *DeleteBlobStatsArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteBlobStatsArgs.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteBlobStatsArgs proto.InternalMessageInfo

type DeleteBlobStatsRet struct {
	Enable               bool     `protobuf:"varint,1,opt,name=enable,proto3" json:"enable,omitempty"`
	SuccessPerMin        string   `protobuf:"bytes,2,opt,name=success_per_min,json=successPerMin,proto3" json:"success_per_min,omitempty"`
	FailedPerMin         string   `protobuf:"bytes,3,opt,name=failed_per_min,json=failedPerMin,proto3" json:"failed_per_min,omitempty"`
	TotalErrCnt          uint64   `protobuf:"varint,4,opt,name=total_err_cnt,json=totalErrCnt,proto3" json:"total_err_cnt,omitempty"`
	ErrStats             []string `protobuf:"bytes,5,rep,name=err_stats,json=errStats,proto3" json:"err_stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteBlobStatsRet) Reset()         { *m = DeleteBlobStatsRet{} }
func (m *DeleteBlobStatsRet) String() string { return proto.CompactTextString(m) }
func (*DeleteBlobStatsRet) ProtoMessage()    {}
func (*DeleteBlobStatsRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{48}
}
func (m *DeleteBlobStatsRet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteBlobStatsRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteBlobStatsRet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteBlobStatsRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteBlobStatsRet.Merge(m, src)
}
func (m *DeleteBlobStatsRet) XXX_Size() int {
	return m.Size()
}
func (m *DeleteBlobStatsRet) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteBlobStatsRet.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteBlobStatsRet proto.InternalMessageInfo

func (m *DeleteBlobStatsRet) GetEnable() bool {
	if m != nil {
		return m.Enable
	}
	return false
}

func (m *DeleteBlobStatsRet) GetSuccessPerMin() string {
	if m != nil {
		return m.SuccessPerMin
	}
	return ""
}

func (m *DeleteBlobStatsRet) GetFailedPerMin() string {
	if m != nil {
		return m.FailedPerMin
	}
	return ""
}

func (m *DeleteBlobStatsRet) GetTotalErrCnt() uint64 {
	if m != nil {
		return m.TotalErrCnt
	}
	return 0
}

func (m *DeleteBlobStatsRet) GetErrStats() []string {
	if m != nil {
		return m.ErrStats
	}
	return nil
}

func init() {
	proto.RegisterType((*Item)(nil), "cubefs.blobstore.api.shardnode.Item")
	proto.RegisterType((*Field)(nil), "cubefs.blobstore.api.shardnode.Field")
	proto.RegisterType((*ShardOpHeader)(nil), "cubefs.blobstore.api.shardnode.ShardOpHeader")
	proto.RegisterType((*InsertItemArgs)(nil), "cubefs.blobstore.api.shardnode.InsertItemArgs")
	proto.RegisterType((*InsertItemRet)(nil), "cubefs.blobstore.api.shardnode.InsertItemRet")
	proto.RegisterType((*UpdateItemArgs)(nil), "cubefs.blobstore.api.shardnode.UpdateItemArgs")
	proto.RegisterType((*UpdateItemRet)(nil), "cubefs.blobstore.api.shardnode.UpdateItemRet")
	proto.RegisterType((*DeleteItemArgs)(nil), "cubefs.blobstore.api.shardnode.DeleteItemArgs")
	proto.RegisterType((*DeleteItemRet)(nil), "cubefs.blobstore.api.shardnode.DeleteItemRet")
	proto.RegisterType((*GetItemArgs)(nil), "cubefs.blobstore.api.shardnode.GetItemArgs")
	proto.RegisterType((*GetItemRet)(nil), "cubefs.blobstore.api.shardnode.GetItemRet")
	proto.RegisterType((*ListItemArgs)(nil), "cubefs.blobstore.api.shardnode.ListItemArgs")
	proto.RegisterType((*ListItemRet)(nil), "cubefs.blobstore.api.shardnode.ListItemRet")
	proto.RegisterType((*AddShardArgs)(nil), "cubefs.blobstore.api.shardnode.AddShardArgs")
	proto.RegisterType((*AddShardRet)(nil), "cubefs.blobstore.api.shardnode.AddShardRet")
	proto.RegisterType((*UpdateShardArgs)(nil), "cubefs.blobstore.api.shardnode.UpdateShardArgs")
	proto.RegisterType((*UpdateShardRet)(nil), "cubefs.blobstore.api.shardnode.UpdateShardRet")
	proto.RegisterType((*TransferShardLeaderArgs)(nil), "cubefs.blobstore.api.shardnode.TransferShardLeaderArgs")
	proto.RegisterType((*TransferShardLeaderRet)(nil), "cubefs.blobstore.api.shardnode.TransferShardLeaderRet")
	proto.RegisterType((*GetShardArgs)(nil), "cubefs.blobstore.api.shardnode.GetShardArgs")
	proto.RegisterType((*GetShardRet)(nil), "cubefs.blobstore.api.shardnode.GetShardRet")
	proto.RegisterType((*CreateBlobArgs)(nil), "cubefs.blobstore.api.shardnode.CreateBlobArgs")
	proto.RegisterType((*CreateBlobRet)(nil), "cubefs.blobstore.api.shardnode.CreateBlobRet")
	proto.RegisterType((*GetBlobArgs)(nil), "cubefs.blobstore.api.shardnode.GetBlobArgs")
	proto.RegisterType((*GetBlobRet)(nil), "cubefs.blobstore.api.shardnode.GetBlobRet")
	proto.RegisterType((*ListBlobArgs)(nil), "cubefs.blobstore.api.shardnode.ListBlobArgs")
	proto.RegisterType((*ListBlobRet)(nil), "cubefs.blobstore.api.shardnode.ListBlobRet")
	proto.RegisterType((*DeleteBlobArgs)(nil), "cubefs.blobstore.api.shardnode.DeleteBlobArgs")
	proto.RegisterType((*DeleteBlobRet)(nil), "cubefs.blobstore.api.shardnode.DeleteBlobRet")
	proto.RegisterType((*RetainBlobArgs)(nil), "cubefs.blobstore.api.shardnode.RetainBlobArgs")
	proto.RegisterType((*RetainBlobRet)(nil), "cubefs.blobstore.api.shardnode.RetainBlobRet")
	proto.RegisterType((*SealBlobArgs)(nil), "cubefs.blobstore.api.shardnode.SealBlobArgs")
	proto.RegisterType((*SealBlobRet)(nil), "cubefs.blobstore.api.shardnode.SealBlobRet")
	proto.RegisterType((*AllocSliceArgs)(nil), "cubefs.blobstore.api.shardnode.AllocSliceArgs")
	proto.RegisterType((*AllocSliceRet)(nil), "cubefs.blobstore.api.shardnode.AllocSliceRet")
	proto.RegisterType((*ShardStats)(nil), "cubefs.blobstore.api.shardnode.ShardStats")
	proto.RegisterType((*ListVolumeArgs)(nil), "cubefs.blobstore.api.shardnode.ListVolumeArgs")
	proto.RegisterType((*ListVolumeRet)(nil), "cubefs.blobstore.api.shardnode.ListVolumeRet")
	proto.RegisterType((*ListShardArgs)(nil), "cubefs.blobstore.api.shardnode.ListShardArgs")
	proto.RegisterType((*ListShardBaseInfo)(nil), "cubefs.blobstore.api.shardnode.ListShardBaseInfo")
	proto.RegisterType((*ListShardRet)(nil), "cubefs.blobstore.api.shardnode.ListShardRet")
	proto.RegisterType((*TCMallocArgs)(nil), "cubefs.blobstore.api.shardnode.TCMallocArgs")
	proto.RegisterType((*TCMallocRet)(nil), "cubefs.blobstore.api.shardnode.TCMallocRet")
	proto.RegisterType((*DBStatsArgs)(nil), "cubefs.blobstore.api.shardnode.DBStatsArgs")
	proto.RegisterType((*DBStatsRet)(nil), "cubefs.blobstore.api.shardnode.DBStatsRet")
	proto.RegisterType((*DeleteBlobRawArgs)(nil), "cubefs.blobstore.api.shardnode.DeleteBlobRawArgs")
	proto.RegisterType((*DeleteBlobRawRet)(nil), "cubefs.blobstore.api.shardnode.DeleteBlobRawRet")
	proto.RegisterType((*DeleteBlobStatsArgs)(nil), "cubefs.blobstore.api.shardnode.DeleteBlobStatsArgs")
	proto.RegisterType((*DeleteBlobStatsRet)(nil), "cubefs.blobstore.api.shardnode.DeleteBlobStatsRet")
}

func init() { proto.RegisterFile("shardnode.proto", fileDescriptor_9d3815ca0e5f30f0) }

var fileDescriptor_9d3815ca0e5f30f0 = []byte{
	// 1803 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x59, 0xcd, 0x6f, 0x1c, 0x49,
	0x15, 0xa7, 0xe7, 0xcb, 0xe3, 0x37, 0x1f, 0xce, 0xf6, 0x9a, 0x30, 0x0a, 0xc2, 0x63, 0x75, 0xb2,
	0xac, 0x05, 0xcb, 0x58, 0x24, 0x08, 0x0e, 0x0b, 0x24, 0x1e, 0x0f, 0xd9, 0xcc, 0x26, 0xde, 0x5d,
	0x7a, 0x12, 0x4b, 0x20, 0xa1, 0x56, 0x4d, 0x57, 0xcd, 0xb8, 0x49, 0x7f, 0x0c, 0x55, 0x35, 0x21,
	0xd9, 0x13, 0xe2, 0xc2, 0x09, 0x21, 0xfe, 0x00, 0x84, 0xe0, 0x4f, 0xe0, 0x82, 0x04, 0xe2, 0xc4,
	0x81, 0x3d, 0x72, 0xe3, 0x36, 0x42, 0x73, 0xe1, 0x7f, 0xf0, 0x09, 0xd5, 0xab, 0xea, 0xee, 0x49,
	0xb2, 0x5e, 0x67, 0xec, 0xb1, 0x45, 0xd8, 0x4b, 0x32, 0xf5, 0xfa, 0x7d, 0xfc, 0xde, 0x7b, 0xf5,
	0x3e, 0xba, 0x0d, 0x1b, 0xe2, 0x88, 0x70, 0x1a, 0x27, 0x94, 0x75, 0x26, 0x3c, 0x91, 0x89, 0xbd,
	0xe5, 0x4f, 0x87, 0x6c, 0x24, 0x3a, 0xc3, 0x30, 0x19, 0x0a, 0x99, 0x70, 0xd6, 0x21, 0x93, 0xa0,
	0x93, 0x71, 0x5d, 0xdb, 0x1c, 0x27, 0xe3, 0x04, 0x59, 0x77, 0xd5, 0x2f, 0x2d, 0x75, 0xed, 0x1d,
	0x2d, 0xb5, 0x9b, 0x49, 0xed, 0xfa, 0x49, 0x14, 0x25, 0xf1, 0x2e, 0x0a, 0x06, 0xf1, 0x78, 0x97,
	0x93, 0x78, 0x6c, 0x6c, 0x5c, 0xfb, 0xfa, 0x4b, 0xdc, 0x64, 0x12, 0xec, 0xfa, 0xe1, 0x54, 0x48,
	0xc6, 0xa3, 0x31, 0xd7, 0x52, 0x86, 0x79, 0xe7, 0x24, 0xd5, 0x1a, 0x84, 0x22, 0x1b, 0xce, 0xb7,
	0x4f, 0xe2, 0xe4, 0x64, 0x24, 0xf1, 0x1f, 0xcd, 0xe8, 0xf8, 0x50, 0xea, 0x4b, 0x16, 0xd9, 0x57,
	0xa1, 0x10, 0xd0, 0x96, 0xb5, 0x6d, 0xed, 0xac, 0x77, 0x2b, 0xf3, 0x59, 0xbb, 0xd0, 0xef, 0xb9,
	0x85, 0x80, 0xda, 0xfb, 0x50, 0x19, 0x05, 0x2c, 0xa4, 0xa2, 0x55, 0xd8, 0x2e, 0xee, 0xd4, 0x6e,
	0xbe, 0xd5, 0xf9, 0xec, 0xa0, 0x74, 0xee, 0x2a, 0xee, 0x6e, 0xe9, 0x93, 0x59, 0xfb, 0x0b, 0xae,
	0x11, 0x75, 0x26, 0x50, 0x46, 0xb2, 0xfd, 0xc3, 0xcc, 0x4a, 0xa3, 0xbb, 0xa7, 0xad, 0x1c, 0xcf,
	0xda, 0xdf, 0x19, 0x07, 0xf2, 0x68, 0x3a, 0xec, 0xf8, 0x49, 0xb4, 0x6b, 0x70, 0x7f, 0xa6, 0xa3,
	0xda, 0x86, 0x01, 0xb8, 0x09, 0xe5, 0x27, 0x24, 0x9c, 0xb2, 0x56, 0x61, 0xdb, 0xda, 0xa9, 0xbb,
	0xfa, 0xe0, 0xfc, 0xa9, 0x08, 0x8d, 0x81, 0xc2, 0xf4, 0xe1, 0xe4, 0x1e, 0x23, 0x94, 0x71, 0x9b,
	0x40, 0x55, 0x4c, 0x88, 0xcf, 0x3c, 0x03, 0xa0, 0xd4, 0xbd, 0x3b, 0x9f, 0xb5, 0xd7, 0x06, 0x8a,
	0x76, 0x36, 0x14, 0x46, 0xd4, 0x5d, 0x43, 0xbd, 0x7d, 0x6a, 0xff, 0x04, 0xd6, 0x68, 0x20, 0x1e,
	0x2b, 0x0b, 0x05, 0x74, 0xb1, 0x37, 0x9f, 0xb5, 0x2b, 0xbd, 0x40, 0x3c, 0x46, 0x03, 0xdf, 0x5e,
	0xd6, 0x80, 0x96, 0x74, 0x2b, 0x4a, 0x69, 0x9f, 0xda, 0x0f, 0xa1, 0x24, 0xa6, 0x01, 0x6d, 0x15,
	0x51, 0xf7, 0x9d, 0xf9, 0xac, 0x5d, 0x1a, 0x4c, 0x03, 0x7a, 0x3c, 0x6b, 0x7f, 0x6b, 0x69, 0xe8,
	0xd3, 0x80, 0xba, 0xa8, 0xcd, 0x76, 0xa0, 0x8e, 0xf8, 0x0f, 0x19, 0x17, 0x41, 0x12, 0xb7, 0x4a,
	0x2a, 0x36, 0xee, 0x73, 0x34, 0x9b, 0x41, 0x83, 0x27, 0x53, 0xc9, 0xbc, 0x27, 0x86, 0xa9, 0x8c,
	0x01, 0xbc, 0x73, 0x3c, 0x6b, 0x7f, 0x77, 0x59, 0xd3, 0xae, 0x52, 0x64, 0x14, 0xbb, 0x75, 0xbe,
	0x70, 0x72, 0x7e, 0x67, 0x41, 0xb3, 0x1f, 0x0b, 0xc6, 0xa5, 0xba, 0x92, 0x7b, 0x7c, 0x2c, 0xec,
	0xfb, 0x50, 0x39, 0xc2, 0xfc, 0x61, 0xce, 0x6a, 0x37, 0xbf, 0x71, 0xda, 0xf5, 0x7b, 0x2e, 0xe9,
	0xe9, 0x35, 0xd4, 0x2a, 0xec, 0xef, 0x43, 0x29, 0x90, 0x2c, 0xc2, 0xe4, 0xd4, 0x6e, 0xde, 0x38,
	0x4d, 0x95, 0x02, 0x61, 0x34, 0xa0, 0x9c, 0xb3, 0x01, 0x8d, 0x1c, 0x9e, 0xcb, 0x24, 0x02, 0x7e,
	0x34, 0xa1, 0x44, 0xb2, 0xff, 0x59, 0xc0, 0x39, 0x3c, 0x05, 0x78, 0x0a, 0xcd, 0x1e, 0x0b, 0xd9,
	0x45, 0xe1, 0xd5, 0x4d, 0xa4, 0xf0, 0x62, 0x13, 0x51, 0x38, 0x72, 0xb3, 0x0a, 0x07, 0x87, 0xda,
	0x7b, 0x4c, 0x5e, 0x2e, 0x88, 0x07, 0x00, 0xc6, 0xa6, 0xcb, 0x64, 0x16, 0x5a, 0xeb, 0x8c, 0xa1,
	0xfd, 0x83, 0x05, 0xf5, 0x07, 0x81, 0xb8, 0x30, 0x1f, 0x2a, 0x13, 0xce, 0x46, 0xc1, 0x53, 0xed,
	0x87, 0x6b, 0x4e, 0x8a, 0x1e, 0x11, 0xfe, 0x98, 0x71, 0x6c, 0x02, 0xeb, 0xae, 0x39, 0xa9, 0x26,
	0xe8, 0x27, 0xd3, 0x58, 0x9a, 0xea, 0xd5, 0x07, 0x27, 0x81, 0x5a, 0x0a, 0x51, 0xb9, 0x7c, 0x07,
	0xca, 0x0a, 0xba, 0x68, 0x59, 0xd8, 0xc9, 0x97, 0xf1, 0x59, 0x0b, 0xda, 0x5b, 0x00, 0x31, 0x7b,
	0x2a, 0x0f, 0x34, 0x04, 0x0d, 0x6d, 0x81, 0xe2, 0xfc, 0xb9, 0x08, 0xf5, 0x3d, 0x4a, 0xd1, 0x33,
	0x0c, 0xca, 0x42, 0x47, 0xb4, 0x2e, 0xb0, 0x23, 0x16, 0x74, 0x3b, 0x5a, 0x51, 0x47, 0xdc, 0x87,
	0x32, 0x4e, 0x68, 0x8c, 0x71, 0xed, 0xe6, 0xdb, 0x2f, 0xc7, 0x49, 0x4b, 0x76, 0xd2, 0x81, 0xde,
	0x71, 0x15, 0x7b, 0x1a, 0x2a, 0x94, 0xb5, 0xef, 0x42, 0x79, 0x1a, 0x07, 0x52, 0xb4, 0x4a, 0x18,
	0xec, 0xaf, 0x7d, 0x7a, 0xb0, 0xf3, 0x39, 0xaf, 0xaf, 0xc3, 0xa3, 0x38, 0x90, 0xa9, 0x1e, 0x14,
	0xbf, 0xac, 0xd6, 0xdb, 0x80, 0x5a, 0x9a, 0x38, 0x55, 0x9f, 0xbf, 0x29, 0xc2, 0x86, 0xee, 0x1c,
	0xaf, 0x79, 0x2e, 0x7f, 0x61, 0xc1, 0x86, 0x8e, 0x2c, 0x7a, 0xf3, 0xf0, 0xd9, 0x84, 0x99, 0xf9,
	0x79, 0x38, 0x9f, 0xb5, 0x5f, 0x7c, 0x74, 0x3c, 0x6b, 0xdf, 0x5e, 0xda, 0xd8, 0xf3, 0x2a, 0xdc,
	0x17, 0x75, 0xda, 0x3d, 0x28, 0xa9, 0x54, 0x62, 0x69, 0x9e, 0xe5, 0x22, 0xa0, 0xb4, 0x73, 0x25,
	0x9d, 0x34, 0x59, 0x8e, 0xfe, 0x52, 0x80, 0x2f, 0x3d, 0xe4, 0x24, 0x16, 0x23, 0xc6, 0x91, 0xf8,
	0x00, 0x7b, 0xc7, 0xeb, 0x9b, 0xab, 0x9f, 0x42, 0x9d, 0x32, 0x21, 0xbd, 0x14, 0xb9, 0xce, 0xd3,
	0xbd, 0xf9, 0xac, 0x0d, 0x3d, 0x26, 0xe4, 0xb9, 0xd1, 0x03, 0x4d, 0xb5, 0x50, 0xa7, 0x05, 0x57,
	0x3f, 0x25, 0x76, 0x2a, 0xac, 0x7f, 0xb7, 0xa0, 0xfe, 0x1e, 0x93, 0xaf, 0xf7, 0xbd, 0x77, 0x7e,
	0x84, 0x03, 0x36, 0xbd, 0x2b, 0xf6, 0xfb, 0x50, 0xc6, 0x66, 0x65, 0x66, 0x53, 0xe7, 0xd5, 0x2f,
	0x61, 0x3f, 0x1e, 0x25, 0x69, 0x47, 0x42, 0x15, 0xce, 0xaf, 0x0b, 0xd0, 0xdc, 0xe7, 0x8c, 0x48,
	0xd6, 0x0d, 0x93, 0xe1, 0xea, 0x67, 0x9f, 0x0d, 0xa5, 0x98, 0x44, 0xcc, 0x8c, 0x17, 0xfc, 0x6d,
	0x8f, 0xa1, 0xea, 0x27, 0x94, 0x45, 0x09, 0x4d, 0xcb, 0xf7, 0xfe, 0x7c, 0xd6, 0xae, 0xee, 0x27,
	0x94, 0x1d, 0x24, 0x54, 0xd5, 0xed, 0xbb, 0xaf, 0x1e, 0xac, 0x54, 0x53, 0x27, 0x15, 0x77, 0x33,
	0xe5, 0xca, 0xb8, 0x08, 0x3e, 0x66, 0x66, 0x8e, 0xe2, 0x6f, 0xfb, 0x2b, 0x00, 0x22, 0x0c, 0x7c,
	0xe6, 0xe1, 0x13, 0xd5, 0x7f, 0x1b, 0xee, 0x3a, 0x52, 0x06, 0xc1, 0xc7, 0xcc, 0xf9, 0x00, 0x1a,
	0x79, 0x38, 0x54, 0xb0, 0xbf, 0x07, 0x25, 0x65, 0xd3, 0xc4, 0xe2, 0xfa, 0x89, 0xe3, 0x43, 0x27,
	0x4d, 0x49, 0xa5, 0x95, 0xae, 0x58, 0x9c, 0x18, 0x53, 0x77, 0x69, 0xb1, 0x75, 0xee, 0xe3, 0x5e,
	0xb4, 0x22, 0xf0, 0xe9, 0x5a, 0x74, 0x31, 0xf0, 0x57, 0xb3, 0x16, 0xc5, 0x7a, 0x2d, 0x4a, 0x3d,
	0xbe, 0x0d, 0x65, 0xc4, 0x62, 0xd6, 0xa2, 0x25, 0x5c, 0xd6, 0x72, 0xa7, 0x6e, 0x45, 0x3f, 0x4b,
	0x97, 0xee, 0xcb, 0xcb, 0x69, 0xb6, 0x70, 0x1b, 0x27, 0x9d, 0x5f, 0x59, 0xd0, 0x74, 0x99, 0x24,
	0x41, 0x7c, 0x79, 0x45, 0xbb, 0x09, 0xe5, 0x90, 0x11, 0xa1, 0x2b, 0xb6, 0xe4, 0xea, 0x83, 0x82,
	0x96, 0x03, 0x51, 0xd0, 0xfe, 0x61, 0x41, 0x7d, 0xc0, 0x48, 0x78, 0x61, 0xc0, 0xb0, 0x6c, 0x0b,
	0x0b, 0x05, 0x9d, 0x82, 0x2d, 0x2e, 0x80, 0xed, 0x42, 0x05, 0x4b, 0x3a, 0x5d, 0xd8, 0x6e, 0x9c,
	0x72, 0x0d, 0x06, 0x8a, 0x39, 0xb5, 0xa5, 0x25, 0xd5, 0x12, 0x95, 0x3a, 0xa2, 0x1c, 0xfb, 0x5b,
	0x01, 0x9a, 0x7b, 0x61, 0x98, 0xf8, 0xc8, 0xfb, 0x39, 0x68, 0x94, 0x07, 0x50, 0x1f, 0x91, 0x20,
	0x64, 0xd4, 0xc3, 0x80, 0x60, 0xab, 0x5c, 0x2e, 0x92, 0x35, 0x2d, 0x8f, 0x24, 0x67, 0x00, 0x8d,
	0x3c, 0x7c, 0xaa, 0x52, 0xf3, 0x1c, 0x59, 0x67, 0xce, 0xd1, 0xbf, 0xca, 0x00, 0x18, 0xd4, 0x81,
	0x24, 0x52, 0x64, 0xd3, 0xd7, 0x5a, 0xe9, 0x26, 0x73, 0x1d, 0x1a, 0x64, 0x32, 0x09, 0x03, 0x46,
	0xbd, 0x20, 0xa6, 0xec, 0xa9, 0xb9, 0x7d, 0x75, 0x43, 0xec, 0x2b, 0x9a, 0xdd, 0x86, 0x5a, 0x88,
	0x89, 0xf4, 0x8e, 0x12, 0x21, 0xcd, 0x65, 0x04, 0x4d, 0xba, 0x97, 0x08, 0x69, 0x4f, 0xa0, 0x69,
	0x18, 0xd2, 0xfd, 0xa3, 0x84, 0x19, 0x7d, 0x7f, 0x3e, 0x6b, 0xd7, 0xf5, 0xc2, 0x72, 0xee, 0x2d,
	0xa4, 0x1e, 0xe6, 0x7a, 0xa8, 0x3d, 0xce, 0x20, 0x61, 0x50, 0xca, 0xd9, 0x67, 0x32, 0xd0, 0xe6,
	0xce, 0x15, 0x1a, 0xe3, 0x9a, 0xfa, 0x6d, 0xb7, 0x60, 0x2d, 0x64, 0x84, 0xc7, 0x8c, 0xb7, 0x2a,
	0xdb, 0xd6, 0x4e, 0xd5, 0x4d, 0x8f, 0x2f, 0xbf, 0xef, 0xac, 0x5d, 0xc4, 0xfb, 0x4e, 0xfe, 0x8e,
	0x57, 0x5d, 0xc5, 0x3b, 0xde, 0xfa, 0xf9, 0xde, 0xf1, 0x7a, 0x50, 0xe5, 0x64, 0x24, 0xd5, 0x8d,
	0x6c, 0x01, 0xe2, 0x71, 0x4e, 0xc4, 0x83, 0x9f, 0x6e, 0x15, 0xa7, 0x51, 0x91, 0x49, 0x3a, 0xcf,
	0xa0, 0xa9, 0xc6, 0xda, 0x61, 0x12, 0x4e, 0x23, 0xdd, 0x6d, 0x16, 0x9b, 0x81, 0x75, 0x81, 0xcd,
	0xc0, 0xa1, 0xd0, 0xc8, 0x4d, 0xab, 0x4a, 0x1d, 0x40, 0xe9, 0x49, 0x40, 0x75, 0x9d, 0x36, 0xba,
	0xb7, 0x55, 0x59, 0x1d, 0x06, 0x54, 0x1c, 0xcf, 0xda, 0xb7, 0x96, 0x4d, 0xe2, 0xa1, 0xaa, 0x2a,
	0xa5, 0xcc, 0xf9, 0x8f, 0xa5, 0xcd, 0x5c, 0xda, 0x6a, 0x4e, 0xa0, 0x8a, 0xe9, 0xcf, 0x3f, 0xe8,
	0xea, 0x4f, 0xc6, 0x8a, 0x76, 0xc6, 0x4f, 0xc6, 0x5a, 0xd4, 0x5d, 0x43, 0xbd, 0x7d, 0x9a, 0x6f,
	0x28, 0xc5, 0xc5, 0x0d, 0xe5, 0xf7, 0x45, 0x78, 0x23, 0xf3, 0xb4, 0x4b, 0x04, 0x53, 0x5b, 0xf8,
	0xff, 0x81, 0xb7, 0x8b, 0x5f, 0xb0, 0x57, 0xd7, 0x6d, 0x37, 0xa1, 0xac, 0xbb, 0x2c, 0xb6, 0x47,
	0x57, 0x1f, 0x14, 0x95, 0x4d, 0x12, 0xff, 0xc8, 0x2c, 0xec, 0xfa, 0x90, 0x97, 0x6c, 0xe5, 0x5c,
	0x25, 0xeb, 0x78, 0x7a, 0xcd, 0xcd, 0x5e, 0xb0, 0x3e, 0x84, 0x0a, 0x3a, 0x99, 0x8e, 0xa6, 0x6f,
	0x9e, 0x36, 0xd8, 0x5f, 0x4a, 0x6f, 0x36, 0xa7, 0x50, 0x8d, 0xd3, 0x84, 0xfa, 0xc3, 0xfd, 0x03,
	0xa2, 0xe6, 0x9f, 0xba, 0xea, 0xce, 0x75, 0xa8, 0xa5, 0x67, 0x65, 0x6f, 0x13, 0xca, 0x42, 0x0d,
	0x30, 0xfd, 0x17, 0x1b, 0x57, 0x1f, 0x9c, 0xdf, 0x5a, 0x50, 0xeb, 0x75, 0x71, 0xb2, 0x5d, 0x46,
	0x7d, 0x5c, 0x87, 0x35, 0x3a, 0xf4, 0xf2, 0x1d, 0xa4, 0x0b, 0xa8, 0xbe, 0xfb, 0x01, 0x89, 0x98,
	0x5b, 0xa1, 0x43, 0xf5, 0xbf, 0xf3, 0xcb, 0x02, 0x80, 0xc1, 0xa4, 0x80, 0xdb, 0x50, 0x9a, 0x0a,
	0x66, 0x06, 0xae, 0x8b, 0xbf, 0xed, 0x1d, 0xb8, 0xa2, 0x0c, 0x7a, 0x3e, 0xf1, 0x8f, 0x98, 0x37,
	0x15, 0x64, 0x9c, 0xee, 0x6b, 0x4d, 0x45, 0xdf, 0x57, 0xe4, 0x47, 0x8a, 0x6a, 0xdf, 0x82, 0xab,
	0x98, 0x5d, 0x8f, 0xc4, 0xd4, 0x1b, 0x05, 0xa1, 0x64, 0xdc, 0xf0, 0xeb, 0xfa, 0x79, 0x13, 0x9f,
	0xee, 0xc5, 0xf4, 0x2e, 0x3e, 0xd3, 0x42, 0x6f, 0x41, 0x33, 0x62, 0x91, 0x24, 0xc3, 0x30, 0x55,
	0xae, 0x97, 0x96, 0x46, 0x4a, 0xd5, 0x6c, 0xef, 0x80, 0x3d, 0x0c, 0x13, 0xff, 0xb1, 0x37, 0x09,
	0xe2, 0x98, 0x51, 0xc3, 0x8a, 0x33, 0xd0, 0xbd, 0x82, 0x4f, 0x3e, 0xc2, 0x07, 0x19, 0xb7, 0x4c,
	0x24, 0x09, 0xbd, 0x88, 0x45, 0x09, 0x7f, 0x66, 0xb8, 0x2b, 0x9a, 0x1b, 0x9f, 0x1c, 0xe0, 0x03,
	0xe4, 0x76, 0xfe, 0x68, 0xc1, 0x1b, 0x0b, 0x0b, 0x39, 0xf9, 0xf9, 0xea, 0xb7, 0xc1, 0x3b, 0x50,
	0xd6, 0x5b, 0x57, 0x61, 0xe9, 0xad, 0x4b, 0x0b, 0x3a, 0x36, 0x5c, 0x79, 0x0e, 0xa3, 0xda, 0x61,
	0xbf, 0x08, 0x6f, 0xe6, 0xb4, 0xec, 0x62, 0x39, 0x7f, 0xb5, 0xc0, 0x7e, 0x81, 0xae, 0x92, 0x7b,
	0x15, 0x2a, 0x2c, 0x56, 0x11, 0x45, 0x87, 0xaa, 0xae, 0x39, 0xd9, 0x5f, 0x85, 0x0d, 0x31, 0xf5,
	0x7d, 0x26, 0x84, 0x37, 0x61, 0xdc, 0x8b, 0x82, 0xd8, 0x2c, 0xad, 0x0d, 0x43, 0xfe, 0x88, 0xf1,
	0x83, 0x20, 0xb6, 0x6f, 0x40, 0xd3, 0x2c, 0x90, 0x29, 0x9b, 0xde, 0x8a, 0xcc, 0x5a, 0x69, 0xb8,
	0x1c, 0x68, 0xe8, 0xd0, 0x33, 0xce, 0x3d, 0x3f, 0x7b, 0xbb, 0xab, 0x21, 0xf1, 0x07, 0x9c, 0xef,
	0xc7, 0xd2, 0xfe, 0x32, 0xac, 0xab, 0xa7, 0xba, 0x46, 0xca, 0xdb, 0xc5, 0x9d, 0x75, 0xb7, 0xca,
	0x38, 0x47, 0xa4, 0xdd, 0x6b, 0x9f, 0xcc, 0xb7, 0xac, 0x7f, 0xce, 0xb7, 0xac, 0x7f, 0xcf, 0xb7,
	0xac, 0x1f, 0xd7, 0x3b, 0xbb, 0xef, 0x66, 0x21, 0x1e, 0x56, 0x30, 0x3c, 0xb7, 0xfe, 0x1b, 0x00,
	0x00, 0xff, 0xff, 0x0e, 0xd2, 0xb9, 0xdf, 0x0d, 0x1e, 0x00, 0x00,
}

func (m *Item) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Item) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Item) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Fields[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintShardnode(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintShardnode(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Field) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Field) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Field) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintShardnode(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if m.ID != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ShardOpHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardOpHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShardOpHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RouteVersion != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.RouteVersion))
		i--
		dAtA[i] = 0x28
	}
	if m.SpaceVersion != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.SpaceVersion))
		i--
		dAtA[i] = 0x20
	}
	if m.Suid != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.Suid))
		i--
		dAtA[i] = 0x18
	}
	if m.DiskID != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.DiskID))
		i--
		dAtA[i] = 0x10
	}
	if m.SpaceID != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.SpaceID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *InsertItemArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InsertItemArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InsertItemArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *InsertItemRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InsertItemRet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InsertItemRet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *UpdateItemArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateItemArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateItemArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *UpdateItemRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateItemRet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateItemRet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *DeleteItemArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteItemArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteItemArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintShardnode(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DeleteItemRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteItemRet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteItemRet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *GetItemArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetItemArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetItemArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintShardnode(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *GetItemRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetItemRet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetItemRet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ListItemArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListItemArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListItemArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Count != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Marker) > 0 {
		i -= len(m.Marker)
		copy(dAtA[i:], m.Marker)
		i = encodeVarintShardnode(dAtA, i, uint64(len(m.Marker)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Prefix) > 0 {
		i -= len(m.Prefix)
		copy(dAtA[i:], m.Prefix)
		i = encodeVarintShardnode(dAtA, i, uint64(len(m.Prefix)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ListItemRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListItemRet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListItemRet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NextMarker) > 0 {
		i -= len(m.NextMarker)
		copy(dAtA[i:], m.NextMarker)
		i = encodeVarintShardnode(dAtA, i, uint64(len(m.NextMarker)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintShardnode(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AddShardArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddShardArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddShardArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RouteVersion != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.RouteVersion))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Units) > 0 {
		for iNdEx := len(m.Units) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Units[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintShardnode(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	{
		size, err := m.Range.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.Suid != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.Suid))
		i--
		dAtA[i] = 0x10
	}
	if m.DiskID != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.DiskID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AddShardRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddShardRet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddShardRet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *UpdateShardArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateShardArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateShardArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Unit.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.ShardUpdateType != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.ShardUpdateType))
		i--
		dAtA[i] = 0x18
	}
	if m.Suid != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.Suid))
		i--
		dAtA[i] = 0x10
	}
	if m.DiskID != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.DiskID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateShardRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateShardRet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateShardRet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *TransferShardLeaderArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransferShardLeaderArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransferShardLeaderArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DestDiskID != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.DestDiskID))
		i--
		dAtA[i] = 0x18
	}
	if m.Suid != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.Suid))
		i--
		dAtA[i] = 0x10
	}
	if m.DiskID != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.DiskID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TransferShardLeaderRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransferShardLeaderRet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransferShardLeaderRet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *GetShardArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetShardArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetShardArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Suid != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.Suid))
		i--
		dAtA[i] = 0x10
	}
	if m.DiskID != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.DiskID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetShardRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetShardRet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetShardRet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Shard.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CreateBlobArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateBlobArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateBlobArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SliceSize != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.SliceSize))
		i--
		dAtA[i] = 0x28
	}
	if m.Size_ != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x20
	}
	if m.CodeMode != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.CodeMode))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintShardnode(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CreateBlobRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateBlobRet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateBlobRet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Blob.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *GetBlobArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetBlobArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetBlobArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintShardnode(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *GetBlobRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetBlobRet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetBlobRet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Blob.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ListBlobArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListBlobArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListBlobArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Count != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Marker) > 0 {
		i -= len(m.Marker)
		copy(dAtA[i:], m.Marker)
		i = encodeVarintShardnode(dAtA, i, uint64(len(m.Marker)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Prefix) > 0 {
		i -= len(m.Prefix)
		copy(dAtA[i:], m.Prefix)
		i = encodeVarintShardnode(dAtA, i, uint64(len(m.Prefix)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ListBlobRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListBlobRet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListBlobRet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NextMarker) > 0 {
		i -= len(m.NextMarker)
		copy(dAtA[i:], m.NextMarker)
		i = encodeVarintShardnode(dAtA, i, uint64(len(m.NextMarker)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Blobs) > 0 {
		for iNdEx := len(m.Blobs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Blobs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintShardnode(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DeleteBlobArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteBlobArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteBlobArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintShardnode(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DeleteBlobRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteBlobRet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteBlobRet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *RetainBlobArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RetainBlobArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RetainBlobArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Lease != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.Lease))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintShardnode(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RetainBlobRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RetainBlobRet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RetainBlobRet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *SealBlobArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SealBlobArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SealBlobArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Slices) > 0 {
		for iNdEx := len(m.Slices) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Slices[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintShardnode(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintShardnode(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Size_ != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SealBlobRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SealBlobRet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SealBlobRet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *AllocSliceArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllocSliceArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AllocSliceArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.FailedSlice.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.Size_ != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x20
	}
	if m.CodeMode != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.CodeMode))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintShardnode(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AllocSliceRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllocSliceRet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AllocSliceRet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Slices) > 0 {
		for iNdEx := len(m.Slices) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Slices[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintShardnode(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ShardStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShardStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.RaftStat.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	if len(m.Units) > 0 {
		for iNdEx := len(m.Units) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Units[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintShardnode(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	{
		size, err := m.Range.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	if m.RouteVersion != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.RouteVersion))
		i--
		dAtA[i] = 0x38
	}
	if m.Learner {
		i--
		if m.Learner {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.LeaderSuid != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.LeaderSuid))
		i--
		dAtA[i] = 0x28
	}
	if m.LeaderDiskID != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.LeaderDiskID))
		i--
		dAtA[i] = 0x20
	}
	if len(m.LeaderHost) > 0 {
		i -= len(m.LeaderHost)
		copy(dAtA[i:], m.LeaderHost)
		i = encodeVarintShardnode(dAtA, i, uint64(len(m.LeaderHost)))
		i--
		dAtA[i] = 0x1a
	}
	if m.AppliedIndex != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.AppliedIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.Suid != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.Suid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListVolumeArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListVolumeArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListVolumeArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CodeMode != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.CodeMode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListVolumeRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListVolumeRet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListVolumeRet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Vids) > 0 {
		dAtA25 := make([]byte, len(m.Vids)*10)
		var j24 int
		for _, num := range m.Vids {
			for num >= 1<<7 {
				dAtA25[j24] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j24++
			}
			dAtA25[j24] = uint8(num)
			j24++
		}
		i -= j24
		copy(dAtA[i:], dAtA25[:j24])
		i = encodeVarintShardnode(dAtA, i, uint64(j24))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListShardArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListShardArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListShardArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Count != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x18
	}
	if m.ShardID != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.ShardID))
		i--
		dAtA[i] = 0x10
	}
	if m.DiskID != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.DiskID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListShardBaseInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListShardBaseInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListShardBaseInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Units) > 0 {
		for iNdEx := len(m.Units) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Units[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintShardnode(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Epoch != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x28
	}
	if m.Index != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x20
	}
	if m.Suid != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.Suid))
		i--
		dAtA[i] = 0x18
	}
	if m.ShardID != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.ShardID))
		i--
		dAtA[i] = 0x10
	}
	if m.DiskID != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.DiskID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListShardRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListShardRet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListShardRet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Shards) > 0 {
		for iNdEx := len(m.Shards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Shards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintShardnode(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TCMallocArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TCMallocArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TCMallocArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *TCMallocRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TCMallocRet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TCMallocRet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Stats) > 0 {
		i -= len(m.Stats)
		copy(dAtA[i:], m.Stats)
		i = encodeVarintShardnode(dAtA, i, uint64(len(m.Stats)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DBStatsArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DBStatsArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DBStatsArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DBName) > 0 {
		i -= len(m.DBName)
		copy(dAtA[i:], m.DBName)
		i = encodeVarintShardnode(dAtA, i, uint64(len(m.DBName)))
		i--
		dAtA[i] = 0x12
	}
	if m.DiskID != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.DiskID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DBStatsRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DBStatsRet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DBStatsRet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TotalMemoryUsage != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.TotalMemoryUsage))
		i--
		dAtA[i] = 0x30
	}
	if m.BlockPinnedUsage != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.BlockPinnedUsage))
		i--
		dAtA[i] = 0x28
	}
	if m.MemtableUsage != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.MemtableUsage))
		i--
		dAtA[i] = 0x20
	}
	if m.IndexAndFilterUsage != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.IndexAndFilterUsage))
		i--
		dAtA[i] = 0x18
	}
	if m.BlobCacheUsage != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.BlobCacheUsage))
		i--
		dAtA[i] = 0x10
	}
	if m.Used != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.Used))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeleteBlobRawArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteBlobRawArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteBlobRawArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Slice.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DeleteBlobRawRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteBlobRawRet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteBlobRawRet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *DeleteBlobStatsArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteBlobStatsArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteBlobStatsArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *DeleteBlobStatsRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteBlobStatsRet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteBlobStatsRet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ErrStats) > 0 {
		for iNdEx := len(m.ErrStats) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ErrStats[iNdEx])
			copy(dAtA[i:], m.ErrStats[iNdEx])
			i = encodeVarintShardnode(dAtA, i, uint64(len(m.ErrStats[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.TotalErrCnt != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.TotalErrCnt))
		i--
		dAtA[i] = 0x20
	}
	if len(m.FailedPerMin) > 0 {
		i -= len(m.FailedPerMin)
		copy(dAtA[i:], m.FailedPerMin)
		i = encodeVarintShardnode(dAtA, i, uint64(len(m.FailedPerMin)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SuccessPerMin) > 0 {
		i -= len(m.SuccessPerMin)
		copy(dAtA[i:], m.SuccessPerMin)
		i = encodeVarintShardnode(dAtA, i, uint64(len(m.SuccessPerMin)))
		i--
		dAtA[i] = 0x12
	}
	if m.Enable {
		i--
		if m.Enable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintShardnode(dAtA []byte, offset int, v uint64) int {
	offset -= sovShardnode(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Item) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovShardnode(uint64(l))
	}
	if len(m.Fields) > 0 {
		for _, e := range m.Fields {
			l = e.Size()
			n += 1 + l + sovShardnode(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Field) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovShardnode(uint64(m.ID))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovShardnode(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShardOpHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SpaceID != 0 {
		n += 1 + sovShardnode(uint64(m.SpaceID))
	}
	if m.DiskID != 0 {
		n += 1 + sovShardnode(uint64(m.DiskID))
	}
	if m.Suid != 0 {
		n += 1 + sovShardnode(uint64(m.Suid))
	}
	if m.SpaceVersion != 0 {
		n += 1 + sovShardnode(uint64(m.SpaceVersion))
	}
	if m.RouteVersion != 0 {
		n += 1 + sovShardnode(uint64(m.RouteVersion))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InsertItemArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovShardnode(uint64(l))
	l = m.Item.Size()
	n += 1 + l + sovShardnode(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InsertItemRet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateItemArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovShardnode(uint64(l))
	l = m.Item.Size()
	n += 1 + l + sovShardnode(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateItemRet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteItemArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovShardnode(uint64(l))
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovShardnode(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteItemRet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetItemArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovShardnode(uint64(l))
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovShardnode(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetItemRet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Item.Size()
	n += 1 + l + sovShardnode(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListItemArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovShardnode(uint64(l))
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovShardnode(uint64(l))
	}
	l = len(m.Marker)
	if l > 0 {
		n += 1 + l + sovShardnode(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovShardnode(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListItemRet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovShardnode(uint64(l))
		}
	}
	l = len(m.NextMarker)
	if l > 0 {
		n += 1 + l + sovShardnode(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddShardArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DiskID != 0 {
		n += 1 + sovShardnode(uint64(m.DiskID))
	}
	if m.Suid != 0 {
		n += 1 + sovShardnode(uint64(m.Suid))
	}
	l = m.Range.Size()
	n += 1 + l + sovShardnode(uint64(l))
	if len(m.Units) > 0 {
		for _, e := range m.Units {
			l = e.Size()
			n += 1 + l + sovShardnode(uint64(l))
		}
	}
	if m.RouteVersion != 0 {
		n += 1 + sovShardnode(uint64(m.RouteVersion))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddShardRet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateShardArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DiskID != 0 {
		n += 1 + sovShardnode(uint64(m.DiskID))
	}
	if m.Suid != 0 {
		n += 1 + sovShardnode(uint64(m.Suid))
	}
	if m.ShardUpdateType != 0 {
		n += 1 + sovShardnode(uint64(m.ShardUpdateType))
	}
	l = m.Unit.Size()
	n += 1 + l + sovShardnode(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateShardRet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransferShardLeaderArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DiskID != 0 {
		n += 1 + sovShardnode(uint64(m.DiskID))
	}
	if m.Suid != 0 {
		n += 1 + sovShardnode(uint64(m.Suid))
	}
	if m.DestDiskID != 0 {
		n += 1 + sovShardnode(uint64(m.DestDiskID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransferShardLeaderRet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetShardArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DiskID != 0 {
		n += 1 + sovShardnode(uint64(m.DiskID))
	}
	if m.Suid != 0 {
		n += 1 + sovShardnode(uint64(m.Suid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetShardRet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Shard.Size()
	n += 1 + l + sovShardnode(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateBlobArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovShardnode(uint64(l))
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovShardnode(uint64(l))
	}
	if m.CodeMode != 0 {
		n += 1 + sovShardnode(uint64(m.CodeMode))
	}
	if m.Size_ != 0 {
		n += 1 + sovShardnode(uint64(m.Size_))
	}
	if m.SliceSize != 0 {
		n += 1 + sovShardnode(uint64(m.SliceSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateBlobRet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Blob.Size()
	n += 1 + l + sovShardnode(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetBlobArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovShardnode(uint64(l))
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovShardnode(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetBlobRet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Blob.Size()
	n += 1 + l + sovShardnode(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListBlobArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovShardnode(uint64(l))
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovShardnode(uint64(l))
	}
	l = len(m.Marker)
	if l > 0 {
		n += 1 + l + sovShardnode(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovShardnode(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListBlobRet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Blobs) > 0 {
		for _, e := range m.Blobs {
			l = e.Size()
			n += 1 + l + sovShardnode(uint64(l))
		}
	}
	l = len(m.NextMarker)
	if l > 0 {
		n += 1 + l + sovShardnode(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteBlobArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovShardnode(uint64(l))
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovShardnode(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteBlobRet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RetainBlobArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovShardnode(uint64(l))
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovShardnode(uint64(l))
	}
	if m.Lease != 0 {
		n += 1 + sovShardnode(uint64(m.Lease))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RetainBlobRet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SealBlobArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovShardnode(uint64(l))
	if m.Size_ != 0 {
		n += 1 + sovShardnode(uint64(m.Size_))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovShardnode(uint64(l))
	}
	if len(m.Slices) > 0 {
		for _, e := range m.Slices {
			l = e.Size()
			n += 1 + l + sovShardnode(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SealBlobRet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AllocSliceArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovShardnode(uint64(l))
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovShardnode(uint64(l))
	}
	if m.CodeMode != 0 {
		n += 1 + sovShardnode(uint64(m.CodeMode))
	}
	if m.Size_ != 0 {
		n += 1 + sovShardnode(uint64(m.Size_))
	}
	l = m.FailedSlice.Size()
	n += 1 + l + sovShardnode(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AllocSliceRet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Slices) > 0 {
		for _, e := range m.Slices {
			l = e.Size()
			n += 1 + l + sovShardnode(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShardStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Suid != 0 {
		n += 1 + sovShardnode(uint64(m.Suid))
	}
	if m.AppliedIndex != 0 {
		n += 1 + sovShardnode(uint64(m.AppliedIndex))
	}
	l = len(m.LeaderHost)
	if l > 0 {
		n += 1 + l + sovShardnode(uint64(l))
	}
	if m.LeaderDiskID != 0 {
		n += 1 + sovShardnode(uint64(m.LeaderDiskID))
	}
	if m.LeaderSuid != 0 {
		n += 1 + sovShardnode(uint64(m.LeaderSuid))
	}
	if m.Learner {
		n += 2
	}
	if m.RouteVersion != 0 {
		n += 1 + sovShardnode(uint64(m.RouteVersion))
	}
	l = m.Range.Size()
	n += 1 + l + sovShardnode(uint64(l))
	if len(m.Units) > 0 {
		for _, e := range m.Units {
			l = e.Size()
			n += 1 + l + sovShardnode(uint64(l))
		}
	}
	l = m.RaftStat.Size()
	n += 1 + l + sovShardnode(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListVolumeArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CodeMode != 0 {
		n += 1 + sovShardnode(uint64(m.CodeMode))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListVolumeRet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Vids) > 0 {
		l = 0
		for _, e := range m.Vids {
			l += sovShardnode(uint64(e))
		}
		n += 1 + sovShardnode(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListShardArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DiskID != 0 {
		n += 1 + sovShardnode(uint64(m.DiskID))
	}
	if m.ShardID != 0 {
		n += 1 + sovShardnode(uint64(m.ShardID))
	}
	if m.Count != 0 {
		n += 1 + sovShardnode(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListShardBaseInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DiskID != 0 {
		n += 1 + sovShardnode(uint64(m.DiskID))
	}
	if m.ShardID != 0 {
		n += 1 + sovShardnode(uint64(m.ShardID))
	}
	if m.Suid != 0 {
		n += 1 + sovShardnode(uint64(m.Suid))
	}
	if m.Index != 0 {
		n += 1 + sovShardnode(uint64(m.Index))
	}
	if m.Epoch != 0 {
		n += 1 + sovShardnode(uint64(m.Epoch))
	}
	if len(m.Units) > 0 {
		for _, e := range m.Units {
			l = e.Size()
			n += 1 + l + sovShardnode(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListShardRet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Shards) > 0 {
		for _, e := range m.Shards {
			l = e.Size()
			n += 1 + l + sovShardnode(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TCMallocArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TCMallocRet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Stats)
	if l > 0 {
		n += 1 + l + sovShardnode(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DBStatsArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DiskID != 0 {
		n += 1 + sovShardnode(uint64(m.DiskID))
	}
	l = len(m.DBName)
	if l > 0 {
		n += 1 + l + sovShardnode(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DBStatsRet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Used != 0 {
		n += 1 + sovShardnode(uint64(m.Used))
	}
	if m.BlobCacheUsage != 0 {
		n += 1 + sovShardnode(uint64(m.BlobCacheUsage))
	}
	if m.IndexAndFilterUsage != 0 {
		n += 1 + sovShardnode(uint64(m.IndexAndFilterUsage))
	}
	if m.MemtableUsage != 0 {
		n += 1 + sovShardnode(uint64(m.MemtableUsage))
	}
	if m.BlockPinnedUsage != 0 {
		n += 1 + sovShardnode(uint64(m.BlockPinnedUsage))
	}
	if m.TotalMemoryUsage != 0 {
		n += 1 + sovShardnode(uint64(m.TotalMemoryUsage))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteBlobRawArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovShardnode(uint64(l))
	l = m.Slice.Size()
	n += 1 + l + sovShardnode(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteBlobRawRet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteBlobStatsArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteBlobStatsRet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enable {
		n += 2
	}
	l = len(m.SuccessPerMin)
	if l > 0 {
		n += 1 + l + sovShardnode(uint64(l))
	}
	l = len(m.FailedPerMin)
	if l > 0 {
		n += 1 + l + sovShardnode(uint64(l))
	}
	if m.TotalErrCnt != 0 {
		n += 1 + sovShardnode(uint64(m.TotalErrCnt))
	}
	if len(m.ErrStats) > 0 {
		for _, s := range m.ErrStats {
			l = len(s)
			n += 1 + l + sovShardnode(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovShardnode(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozShardnode(x uint64) (n int) {
	return sovShardnode(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Item) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Item: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Item: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, Field{})
			if err := m.Fields[len(m.Fields)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Field) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Field: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Field: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= github_com_cubefs_cubefs_blobstore_common_proto.FieldID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardOpHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardOpHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardOpHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceID", wireType)
			}
			m.SpaceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpaceID |= github_com_cubefs_cubefs_blobstore_common_proto.SpaceID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskID", wireType)
			}
			m.DiskID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskID |= github_com_cubefs_cubefs_blobstore_common_proto.DiskID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Suid", wireType)
			}
			m.Suid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Suid |= github_com_cubefs_cubefs_blobstore_common_proto.Suid(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceVersion", wireType)
			}
			m.SpaceVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpaceVersion |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteVersion", wireType)
			}
			m.RouteVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouteVersion |= github_com_cubefs_cubefs_blobstore_common_proto.RouteVersion(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InsertItemArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InsertItemArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InsertItemArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InsertItemRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InsertItemRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InsertItemRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateItemArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateItemArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateItemArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateItemRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateItemRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateItemRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteItemArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteItemArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteItemArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteItemRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteItemRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteItemRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetItemArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetItemArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetItemArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetItemRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetItemRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetItemRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListItemArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListItemArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListItemArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Marker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Marker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListItemRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListItemRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListItemRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, Item{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextMarker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextMarker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddShardArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddShardArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddShardArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskID", wireType)
			}
			m.DiskID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskID |= github_com_cubefs_cubefs_blobstore_common_proto.DiskID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Suid", wireType)
			}
			m.Suid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Suid |= github_com_cubefs_cubefs_blobstore_common_proto.Suid(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Units", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Units = append(m.Units, clustermgr.ShardUnit{})
			if err := m.Units[len(m.Units)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteVersion", wireType)
			}
			m.RouteVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouteVersion |= github_com_cubefs_cubefs_blobstore_common_proto.RouteVersion(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddShardRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddShardRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddShardRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateShardArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateShardArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateShardArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskID", wireType)
			}
			m.DiskID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskID |= github_com_cubefs_cubefs_blobstore_common_proto.DiskID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Suid", wireType)
			}
			m.Suid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Suid |= github_com_cubefs_cubefs_blobstore_common_proto.Suid(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardUpdateType", wireType)
			}
			m.ShardUpdateType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardUpdateType |= github_com_cubefs_cubefs_blobstore_common_proto.ShardUpdateType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Unit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateShardRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateShardRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateShardRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransferShardLeaderArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransferShardLeaderArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransferShardLeaderArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskID", wireType)
			}
			m.DiskID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskID |= github_com_cubefs_cubefs_blobstore_common_proto.DiskID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Suid", wireType)
			}
			m.Suid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Suid |= github_com_cubefs_cubefs_blobstore_common_proto.Suid(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestDiskID", wireType)
			}
			m.DestDiskID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestDiskID |= github_com_cubefs_cubefs_blobstore_common_proto.DiskID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransferShardLeaderRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransferShardLeaderRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransferShardLeaderRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetShardArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetShardArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetShardArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskID", wireType)
			}
			m.DiskID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskID |= github_com_cubefs_cubefs_blobstore_common_proto.DiskID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Suid", wireType)
			}
			m.Suid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Suid |= github_com_cubefs_cubefs_blobstore_common_proto.Suid(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetShardRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetShardRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetShardRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Shard.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateBlobArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateBlobArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateBlobArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CodeMode", wireType)
			}
			m.CodeMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CodeMode |= github_com_cubefs_cubefs_blobstore_common_codemode.CodeMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SliceSize", wireType)
			}
			m.SliceSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SliceSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateBlobRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateBlobRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateBlobRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blob", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Blob.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetBlobArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetBlobArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetBlobArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetBlobRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetBlobRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetBlobRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blob", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Blob.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListBlobArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListBlobArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListBlobArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Marker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Marker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListBlobRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListBlobRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListBlobRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blobs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Blobs = append(m.Blobs, proto1.Blob{})
			if err := m.Blobs[len(m.Blobs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextMarker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextMarker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteBlobArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteBlobArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteBlobArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteBlobRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteBlobRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteBlobRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RetainBlobArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RetainBlobArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RetainBlobArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lease", wireType)
			}
			m.Lease = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lease |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RetainBlobRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RetainBlobRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RetainBlobRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SealBlobArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SealBlobArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SealBlobArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Slices = append(m.Slices, proto1.Slice{})
			if err := m.Slices[len(m.Slices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SealBlobRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SealBlobRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SealBlobRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllocSliceArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllocSliceArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllocSliceArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CodeMode", wireType)
			}
			m.CodeMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CodeMode |= github_com_cubefs_cubefs_blobstore_common_codemode.CodeMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailedSlice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FailedSlice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllocSliceRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllocSliceRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllocSliceRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Slices = append(m.Slices, proto1.Slice{})
			if err := m.Slices[len(m.Slices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Suid", wireType)
			}
			m.Suid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Suid |= github_com_cubefs_cubefs_blobstore_common_proto.Suid(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppliedIndex", wireType)
			}
			m.AppliedIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppliedIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderHost", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeaderHost = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderDiskID", wireType)
			}
			m.LeaderDiskID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeaderDiskID |= github_com_cubefs_cubefs_blobstore_common_proto.DiskID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderSuid", wireType)
			}
			m.LeaderSuid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeaderSuid |= github_com_cubefs_cubefs_blobstore_common_proto.Suid(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Learner", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Learner = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteVersion", wireType)
			}
			m.RouteVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouteVersion |= github_com_cubefs_cubefs_blobstore_common_proto.RouteVersion(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Units", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Units = append(m.Units, clustermgr.ShardUnit{})
			if err := m.Units[len(m.Units)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RaftStat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListVolumeArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListVolumeArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListVolumeArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CodeMode", wireType)
			}
			m.CodeMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CodeMode |= github_com_cubefs_cubefs_blobstore_common_codemode.CodeMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListVolumeRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListVolumeRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListVolumeRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v github_com_cubefs_cubefs_blobstore_common_proto.Vid
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowShardnode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cubefs_cubefs_blobstore_common_proto.Vid(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Vids = append(m.Vids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowShardnode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthShardnode
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthShardnode
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Vids) == 0 {
					m.Vids = make([]github_com_cubefs_cubefs_blobstore_common_proto.Vid, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cubefs_cubefs_blobstore_common_proto.Vid
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowShardnode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cubefs_cubefs_blobstore_common_proto.Vid(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Vids = append(m.Vids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Vids", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListShardArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListShardArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListShardArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskID", wireType)
			}
			m.DiskID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskID |= github_com_cubefs_cubefs_blobstore_common_proto.DiskID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardID", wireType)
			}
			m.ShardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardID |= github_com_cubefs_cubefs_blobstore_common_proto.ShardID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListShardBaseInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListShardBaseInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListShardBaseInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskID", wireType)
			}
			m.DiskID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskID |= github_com_cubefs_cubefs_blobstore_common_proto.DiskID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardID", wireType)
			}
			m.ShardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardID |= github_com_cubefs_cubefs_blobstore_common_proto.ShardID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Suid", wireType)
			}
			m.Suid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Suid |= github_com_cubefs_cubefs_blobstore_common_proto.Suid(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Units", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Units = append(m.Units, clustermgr.ShardUnit{})
			if err := m.Units[len(m.Units)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListShardRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListShardRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListShardRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shards = append(m.Shards, ListShardBaseInfo{})
			if err := m.Shards[len(m.Shards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TCMallocArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TCMallocArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TCMallocArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TCMallocRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TCMallocRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TCMallocRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stats = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DBStatsArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DBStatsArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DBStatsArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskID", wireType)
			}
			m.DiskID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskID |= github_com_cubefs_cubefs_blobstore_common_proto.DiskID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DBName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DBName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DBStatsRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DBStatsRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DBStatsRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Used", wireType)
			}
			m.Used = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Used |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlobCacheUsage", wireType)
			}
			m.BlobCacheUsage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlobCacheUsage |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexAndFilterUsage", wireType)
			}
			m.IndexAndFilterUsage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexAndFilterUsage |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemtableUsage", wireType)
			}
			m.MemtableUsage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemtableUsage |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockPinnedUsage", wireType)
			}
			m.BlockPinnedUsage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockPinnedUsage |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalMemoryUsage", wireType)
			}
			m.TotalMemoryUsage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalMemoryUsage |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteBlobRawArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteBlobRawArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteBlobRawArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Slice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteBlobRawRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteBlobRawRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteBlobRawRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteBlobStatsArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteBlobStatsArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteBlobStatsArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteBlobStatsRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteBlobStatsRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteBlobStatsRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enable = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuccessPerMin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SuccessPerMin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailedPerMin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailedPerMin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalErrCnt", wireType)
			}
			m.TotalErrCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalErrCnt |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrStats", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrStats = append(m.ErrStats, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipShardnode(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthShardnode
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupShardnode
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthShardnode
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthShardnode        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowShardnode          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupShardnode = fmt.Errorf("proto: unexpected end of group")
)
