// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: shardnode.proto

package shardnode

import (
	fmt "fmt"
	clustermgr "github.com/cubefs/cubefs/blobstore/api/clustermgr"
	github_com_cubefs_cubefs_blobstore_common_codemode "github.com/cubefs/cubefs/blobstore/common/codemode"
	github_com_cubefs_cubefs_blobstore_common_proto "github.com/cubefs/cubefs/blobstore/common/proto"
	proto1 "github.com/cubefs/cubefs/blobstore/common/proto"
	raft "github.com/cubefs/cubefs/blobstore/common/raft"
	sharding "github.com/cubefs/cubefs/blobstore/common/sharding"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Item struct {
	ID                   []byte   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Fields               []Field  `protobuf:"bytes,2,rep,name=fields,proto3" json:"fields"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Item) Reset()         { *m = Item{} }
func (m *Item) String() string { return proto.CompactTextString(m) }
func (*Item) ProtoMessage()    {}
func (*Item) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{0}
}
func (m *Item) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Item) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Item.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Item) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Item.Merge(m, src)
}
func (m *Item) XXX_Size() int {
	return m.Size()
}
func (m *Item) XXX_DiscardUnknown() {
	xxx_messageInfo_Item.DiscardUnknown(m)
}

var xxx_messageInfo_Item proto.InternalMessageInfo

func (m *Item) GetID() []byte {
	if m != nil {
		return m.ID
	}
	return nil
}

func (m *Item) GetFields() []Field {
	if m != nil {
		return m.Fields
	}
	return nil
}

type Field struct {
	ID                   github_com_cubefs_cubefs_blobstore_common_proto.FieldID `protobuf:"varint,1,opt,name=id,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.FieldID" json:"id,omitempty"`
	Value                []byte                                                  `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                `json:"-"`
	XXX_unrecognized     []byte                                                  `json:"-"`
	XXX_sizecache        int32                                                   `json:"-"`
}

func (m *Field) Reset()         { *m = Field{} }
func (m *Field) String() string { return proto.CompactTextString(m) }
func (*Field) ProtoMessage()    {}
func (*Field) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{1}
}
func (m *Field) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Field) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Field.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Field) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Field.Merge(m, src)
}
func (m *Field) XXX_Size() int {
	return m.Size()
}
func (m *Field) XXX_DiscardUnknown() {
	xxx_messageInfo_Field.DiscardUnknown(m)
}

var xxx_messageInfo_Field proto.InternalMessageInfo

func (m *Field) GetID() github_com_cubefs_cubefs_blobstore_common_proto.FieldID {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Field) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type ShardOpHeader struct {
	SpaceID              github_com_cubefs_cubefs_blobstore_common_proto.SpaceID      `protobuf:"varint,1,opt,name=space_id,json=spaceId,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.SpaceID" json:"space_id,omitempty"`
	DiskID               github_com_cubefs_cubefs_blobstore_common_proto.DiskID       `protobuf:"varint,2,opt,name=disk_id,json=diskId,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.DiskID" json:"disk_id,omitempty"`
	Suid                 github_com_cubefs_cubefs_blobstore_common_proto.Suid         `protobuf:"varint,3,opt,name=suid,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.Suid" json:"suid,omitempty"`
	SpaceVersion         uint64                                                       `protobuf:"varint,4,opt,name=spaceVersion,proto3" json:"spaceVersion,omitempty"`
	RouteVersion         github_com_cubefs_cubefs_blobstore_common_proto.RouteVersion `protobuf:"varint,5,opt,name=route_version,json=routeVersion,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.RouteVersion" json:"route_version,omitempty"`
	ShardKeys            [][]byte                                                     `protobuf:"bytes,6,rep,name=shard_keys,json=shardKeys,proto3" json:"shard_keys,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                     `json:"-"`
	XXX_unrecognized     []byte                                                       `json:"-"`
	XXX_sizecache        int32                                                        `json:"-"`
}

func (m *ShardOpHeader) Reset()         { *m = ShardOpHeader{} }
func (m *ShardOpHeader) String() string { return proto.CompactTextString(m) }
func (*ShardOpHeader) ProtoMessage()    {}
func (*ShardOpHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{2}
}
func (m *ShardOpHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardOpHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardOpHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardOpHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardOpHeader.Merge(m, src)
}
func (m *ShardOpHeader) XXX_Size() int {
	return m.Size()
}
func (m *ShardOpHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardOpHeader.DiscardUnknown(m)
}

var xxx_messageInfo_ShardOpHeader proto.InternalMessageInfo

func (m *ShardOpHeader) GetSpaceID() github_com_cubefs_cubefs_blobstore_common_proto.SpaceID {
	if m != nil {
		return m.SpaceID
	}
	return 0
}

func (m *ShardOpHeader) GetDiskID() github_com_cubefs_cubefs_blobstore_common_proto.DiskID {
	if m != nil {
		return m.DiskID
	}
	return 0
}

func (m *ShardOpHeader) GetSuid() github_com_cubefs_cubefs_blobstore_common_proto.Suid {
	if m != nil {
		return m.Suid
	}
	return 0
}

func (m *ShardOpHeader) GetSpaceVersion() uint64 {
	if m != nil {
		return m.SpaceVersion
	}
	return 0
}

func (m *ShardOpHeader) GetRouteVersion() github_com_cubefs_cubefs_blobstore_common_proto.RouteVersion {
	if m != nil {
		return m.RouteVersion
	}
	return 0
}

func (m *ShardOpHeader) GetShardKeys() [][]byte {
	if m != nil {
		return m.ShardKeys
	}
	return nil
}

type InsertItemArgs struct {
	Header               ShardOpHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Item                 Item          `protobuf:"bytes,2,opt,name=item,proto3" json:"item"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *InsertItemArgs) Reset()         { *m = InsertItemArgs{} }
func (m *InsertItemArgs) String() string { return proto.CompactTextString(m) }
func (*InsertItemArgs) ProtoMessage()    {}
func (*InsertItemArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{3}
}
func (m *InsertItemArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InsertItemArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InsertItemArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InsertItemArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InsertItemArgs.Merge(m, src)
}
func (m *InsertItemArgs) XXX_Size() int {
	return m.Size()
}
func (m *InsertItemArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_InsertItemArgs.DiscardUnknown(m)
}

var xxx_messageInfo_InsertItemArgs proto.InternalMessageInfo

func (m *InsertItemArgs) GetHeader() ShardOpHeader {
	if m != nil {
		return m.Header
	}
	return ShardOpHeader{}
}

func (m *InsertItemArgs) GetItem() Item {
	if m != nil {
		return m.Item
	}
	return Item{}
}

type InsertItemRet struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InsertItemRet) Reset()         { *m = InsertItemRet{} }
func (m *InsertItemRet) String() string { return proto.CompactTextString(m) }
func (*InsertItemRet) ProtoMessage()    {}
func (*InsertItemRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{4}
}
func (m *InsertItemRet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InsertItemRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InsertItemRet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InsertItemRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InsertItemRet.Merge(m, src)
}
func (m *InsertItemRet) XXX_Size() int {
	return m.Size()
}
func (m *InsertItemRet) XXX_DiscardUnknown() {
	xxx_messageInfo_InsertItemRet.DiscardUnknown(m)
}

var xxx_messageInfo_InsertItemRet proto.InternalMessageInfo

type UpdateItemArgs struct {
	Header               ShardOpHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Item                 Item          `protobuf:"bytes,2,opt,name=item,proto3" json:"item"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *UpdateItemArgs) Reset()         { *m = UpdateItemArgs{} }
func (m *UpdateItemArgs) String() string { return proto.CompactTextString(m) }
func (*UpdateItemArgs) ProtoMessage()    {}
func (*UpdateItemArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{5}
}
func (m *UpdateItemArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateItemArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateItemArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateItemArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateItemArgs.Merge(m, src)
}
func (m *UpdateItemArgs) XXX_Size() int {
	return m.Size()
}
func (m *UpdateItemArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateItemArgs.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateItemArgs proto.InternalMessageInfo

func (m *UpdateItemArgs) GetHeader() ShardOpHeader {
	if m != nil {
		return m.Header
	}
	return ShardOpHeader{}
}

func (m *UpdateItemArgs) GetItem() Item {
	if m != nil {
		return m.Item
	}
	return Item{}
}

type UpdateItemRet struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateItemRet) Reset()         { *m = UpdateItemRet{} }
func (m *UpdateItemRet) String() string { return proto.CompactTextString(m) }
func (*UpdateItemRet) ProtoMessage()    {}
func (*UpdateItemRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{6}
}
func (m *UpdateItemRet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateItemRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateItemRet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateItemRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateItemRet.Merge(m, src)
}
func (m *UpdateItemRet) XXX_Size() int {
	return m.Size()
}
func (m *UpdateItemRet) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateItemRet.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateItemRet proto.InternalMessageInfo

type DeleteItemArgs struct {
	Header               ShardOpHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	ID                   []byte        `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *DeleteItemArgs) Reset()         { *m = DeleteItemArgs{} }
func (m *DeleteItemArgs) String() string { return proto.CompactTextString(m) }
func (*DeleteItemArgs) ProtoMessage()    {}
func (*DeleteItemArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{7}
}
func (m *DeleteItemArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteItemArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteItemArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteItemArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteItemArgs.Merge(m, src)
}
func (m *DeleteItemArgs) XXX_Size() int {
	return m.Size()
}
func (m *DeleteItemArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteItemArgs.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteItemArgs proto.InternalMessageInfo

func (m *DeleteItemArgs) GetHeader() ShardOpHeader {
	if m != nil {
		return m.Header
	}
	return ShardOpHeader{}
}

func (m *DeleteItemArgs) GetID() []byte {
	if m != nil {
		return m.ID
	}
	return nil
}

type DeleteItemRet struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteItemRet) Reset()         { *m = DeleteItemRet{} }
func (m *DeleteItemRet) String() string { return proto.CompactTextString(m) }
func (*DeleteItemRet) ProtoMessage()    {}
func (*DeleteItemRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{8}
}
func (m *DeleteItemRet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteItemRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteItemRet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteItemRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteItemRet.Merge(m, src)
}
func (m *DeleteItemRet) XXX_Size() int {
	return m.Size()
}
func (m *DeleteItemRet) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteItemRet.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteItemRet proto.InternalMessageInfo

type GetItemArgs struct {
	Header               ShardOpHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	ID                   []byte        `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *GetItemArgs) Reset()         { *m = GetItemArgs{} }
func (m *GetItemArgs) String() string { return proto.CompactTextString(m) }
func (*GetItemArgs) ProtoMessage()    {}
func (*GetItemArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{9}
}
func (m *GetItemArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetItemArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetItemArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetItemArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetItemArgs.Merge(m, src)
}
func (m *GetItemArgs) XXX_Size() int {
	return m.Size()
}
func (m *GetItemArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_GetItemArgs.DiscardUnknown(m)
}

var xxx_messageInfo_GetItemArgs proto.InternalMessageInfo

func (m *GetItemArgs) GetHeader() ShardOpHeader {
	if m != nil {
		return m.Header
	}
	return ShardOpHeader{}
}

func (m *GetItemArgs) GetID() []byte {
	if m != nil {
		return m.ID
	}
	return nil
}

type GetItemRet struct {
	Item                 Item     `protobuf:"bytes,1,opt,name=item,proto3" json:"item"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetItemRet) Reset()         { *m = GetItemRet{} }
func (m *GetItemRet) String() string { return proto.CompactTextString(m) }
func (*GetItemRet) ProtoMessage()    {}
func (*GetItemRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{10}
}
func (m *GetItemRet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetItemRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetItemRet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetItemRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetItemRet.Merge(m, src)
}
func (m *GetItemRet) XXX_Size() int {
	return m.Size()
}
func (m *GetItemRet) XXX_DiscardUnknown() {
	xxx_messageInfo_GetItemRet.DiscardUnknown(m)
}

var xxx_messageInfo_GetItemRet proto.InternalMessageInfo

func (m *GetItemRet) GetItem() Item {
	if m != nil {
		return m.Item
	}
	return Item{}
}

type ListItemArgs struct {
	Header               ShardOpHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Prefix               []byte        `protobuf:"bytes,2,opt,name=prefix,proto3" json:"prefix,omitempty"`
	Marker               []byte        `protobuf:"bytes,3,opt,name=marker,proto3" json:"marker,omitempty"`
	Count                uint64        `protobuf:"varint,4,opt,name=count,proto3" json:"count,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ListItemArgs) Reset()         { *m = ListItemArgs{} }
func (m *ListItemArgs) String() string { return proto.CompactTextString(m) }
func (*ListItemArgs) ProtoMessage()    {}
func (*ListItemArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{11}
}
func (m *ListItemArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListItemArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListItemArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListItemArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListItemArgs.Merge(m, src)
}
func (m *ListItemArgs) XXX_Size() int {
	return m.Size()
}
func (m *ListItemArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_ListItemArgs.DiscardUnknown(m)
}

var xxx_messageInfo_ListItemArgs proto.InternalMessageInfo

func (m *ListItemArgs) GetHeader() ShardOpHeader {
	if m != nil {
		return m.Header
	}
	return ShardOpHeader{}
}

func (m *ListItemArgs) GetPrefix() []byte {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func (m *ListItemArgs) GetMarker() []byte {
	if m != nil {
		return m.Marker
	}
	return nil
}

func (m *ListItemArgs) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

type ListItemRet struct {
	Items                []Item   `protobuf:"bytes,1,rep,name=items,proto3" json:"items"`
	NextMarker           []byte   `protobuf:"bytes,2,opt,name=nextMarker,proto3" json:"nextMarker,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListItemRet) Reset()         { *m = ListItemRet{} }
func (m *ListItemRet) String() string { return proto.CompactTextString(m) }
func (*ListItemRet) ProtoMessage()    {}
func (*ListItemRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{12}
}
func (m *ListItemRet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListItemRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListItemRet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListItemRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListItemRet.Merge(m, src)
}
func (m *ListItemRet) XXX_Size() int {
	return m.Size()
}
func (m *ListItemRet) XXX_DiscardUnknown() {
	xxx_messageInfo_ListItemRet.DiscardUnknown(m)
}

var xxx_messageInfo_ListItemRet proto.InternalMessageInfo

func (m *ListItemRet) GetItems() []Item {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *ListItemRet) GetNextMarker() []byte {
	if m != nil {
		return m.NextMarker
	}
	return nil
}

type AddShardArgs struct {
	DiskID               github_com_cubefs_cubefs_blobstore_common_proto.DiskID       `protobuf:"varint,1,opt,name=disk_id,json=diskId,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.DiskID" json:"disk_id,omitempty"`
	Suid                 github_com_cubefs_cubefs_blobstore_common_proto.Suid         `protobuf:"varint,2,opt,name=suid,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.Suid" json:"suid,omitempty"`
	Range                sharding.Range                                               `protobuf:"bytes,3,opt,name=range,proto3" json:"range"`
	Units                []clustermgr.ShardUnit                                       `protobuf:"bytes,4,rep,name=units,proto3" json:"units"`
	RouteVersion         github_com_cubefs_cubefs_blobstore_common_proto.RouteVersion `protobuf:"varint,5,opt,name=route_version,json=routeVersion,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.RouteVersion" json:"route_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                     `json:"-"`
	XXX_unrecognized     []byte                                                       `json:"-"`
	XXX_sizecache        int32                                                        `json:"-"`
}

func (m *AddShardArgs) Reset()         { *m = AddShardArgs{} }
func (m *AddShardArgs) String() string { return proto.CompactTextString(m) }
func (*AddShardArgs) ProtoMessage()    {}
func (*AddShardArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{13}
}
func (m *AddShardArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddShardArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddShardArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddShardArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddShardArgs.Merge(m, src)
}
func (m *AddShardArgs) XXX_Size() int {
	return m.Size()
}
func (m *AddShardArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_AddShardArgs.DiscardUnknown(m)
}

var xxx_messageInfo_AddShardArgs proto.InternalMessageInfo

func (m *AddShardArgs) GetDiskID() github_com_cubefs_cubefs_blobstore_common_proto.DiskID {
	if m != nil {
		return m.DiskID
	}
	return 0
}

func (m *AddShardArgs) GetSuid() github_com_cubefs_cubefs_blobstore_common_proto.Suid {
	if m != nil {
		return m.Suid
	}
	return 0
}

func (m *AddShardArgs) GetRange() sharding.Range {
	if m != nil {
		return m.Range
	}
	return sharding.Range{}
}

func (m *AddShardArgs) GetUnits() []clustermgr.ShardUnit {
	if m != nil {
		return m.Units
	}
	return nil
}

func (m *AddShardArgs) GetRouteVersion() github_com_cubefs_cubefs_blobstore_common_proto.RouteVersion {
	if m != nil {
		return m.RouteVersion
	}
	return 0
}

type AddShardRet struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddShardRet) Reset()         { *m = AddShardRet{} }
func (m *AddShardRet) String() string { return proto.CompactTextString(m) }
func (*AddShardRet) ProtoMessage()    {}
func (*AddShardRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{14}
}
func (m *AddShardRet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddShardRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddShardRet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddShardRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddShardRet.Merge(m, src)
}
func (m *AddShardRet) XXX_Size() int {
	return m.Size()
}
func (m *AddShardRet) XXX_DiscardUnknown() {
	xxx_messageInfo_AddShardRet.DiscardUnknown(m)
}

var xxx_messageInfo_AddShardRet proto.InternalMessageInfo

type UpdateShardArgs struct {
	DiskID               github_com_cubefs_cubefs_blobstore_common_proto.DiskID          `protobuf:"varint,1,opt,name=disk_id,json=diskId,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.DiskID" json:"disk_id,omitempty"`
	Suid                 github_com_cubefs_cubefs_blobstore_common_proto.Suid            `protobuf:"varint,2,opt,name=suid,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.Suid" json:"suid,omitempty"`
	ShardUpdateType      github_com_cubefs_cubefs_blobstore_common_proto.ShardUpdateType `protobuf:"varint,3,opt,name=ShardUpdateType,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.ShardUpdateType" json:"ShardUpdateType,omitempty"`
	Unit                 clustermgr.ShardUnit                                            `protobuf:"bytes,4,opt,name=unit,proto3" json:"unit"`
	XXX_NoUnkeyedLiteral struct{}                                                        `json:"-"`
	XXX_unrecognized     []byte                                                          `json:"-"`
	XXX_sizecache        int32                                                           `json:"-"`
}

func (m *UpdateShardArgs) Reset()         { *m = UpdateShardArgs{} }
func (m *UpdateShardArgs) String() string { return proto.CompactTextString(m) }
func (*UpdateShardArgs) ProtoMessage()    {}
func (*UpdateShardArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{15}
}
func (m *UpdateShardArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateShardArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateShardArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateShardArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateShardArgs.Merge(m, src)
}
func (m *UpdateShardArgs) XXX_Size() int {
	return m.Size()
}
func (m *UpdateShardArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateShardArgs.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateShardArgs proto.InternalMessageInfo

func (m *UpdateShardArgs) GetDiskID() github_com_cubefs_cubefs_blobstore_common_proto.DiskID {
	if m != nil {
		return m.DiskID
	}
	return 0
}

func (m *UpdateShardArgs) GetSuid() github_com_cubefs_cubefs_blobstore_common_proto.Suid {
	if m != nil {
		return m.Suid
	}
	return 0
}

func (m *UpdateShardArgs) GetShardUpdateType() github_com_cubefs_cubefs_blobstore_common_proto.ShardUpdateType {
	if m != nil {
		return m.ShardUpdateType
	}
	return 0
}

func (m *UpdateShardArgs) GetUnit() clustermgr.ShardUnit {
	if m != nil {
		return m.Unit
	}
	return clustermgr.ShardUnit{}
}

type UpdateShardRet struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateShardRet) Reset()         { *m = UpdateShardRet{} }
func (m *UpdateShardRet) String() string { return proto.CompactTextString(m) }
func (*UpdateShardRet) ProtoMessage()    {}
func (*UpdateShardRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{16}
}
func (m *UpdateShardRet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateShardRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateShardRet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateShardRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateShardRet.Merge(m, src)
}
func (m *UpdateShardRet) XXX_Size() int {
	return m.Size()
}
func (m *UpdateShardRet) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateShardRet.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateShardRet proto.InternalMessageInfo

type GetShardArgs struct {
	DiskID               github_com_cubefs_cubefs_blobstore_common_proto.DiskID `protobuf:"varint,1,opt,name=disk_id,json=diskId,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.DiskID" json:"disk_id,omitempty"`
	Suid                 github_com_cubefs_cubefs_blobstore_common_proto.Suid   `protobuf:"varint,2,opt,name=suid,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.Suid" json:"suid,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                               `json:"-"`
	XXX_unrecognized     []byte                                                 `json:"-"`
	XXX_sizecache        int32                                                  `json:"-"`
}

func (m *GetShardArgs) Reset()         { *m = GetShardArgs{} }
func (m *GetShardArgs) String() string { return proto.CompactTextString(m) }
func (*GetShardArgs) ProtoMessage()    {}
func (*GetShardArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{17}
}
func (m *GetShardArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetShardArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetShardArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetShardArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetShardArgs.Merge(m, src)
}
func (m *GetShardArgs) XXX_Size() int {
	return m.Size()
}
func (m *GetShardArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_GetShardArgs.DiscardUnknown(m)
}

var xxx_messageInfo_GetShardArgs proto.InternalMessageInfo

func (m *GetShardArgs) GetDiskID() github_com_cubefs_cubefs_blobstore_common_proto.DiskID {
	if m != nil {
		return m.DiskID
	}
	return 0
}

func (m *GetShardArgs) GetSuid() github_com_cubefs_cubefs_blobstore_common_proto.Suid {
	if m != nil {
		return m.Suid
	}
	return 0
}

type GetShardRet struct {
	Shard                clustermgr.ShardUnitInfo `protobuf:"bytes,1,opt,name=shard,proto3" json:"shard"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *GetShardRet) Reset()         { *m = GetShardRet{} }
func (m *GetShardRet) String() string { return proto.CompactTextString(m) }
func (*GetShardRet) ProtoMessage()    {}
func (*GetShardRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{18}
}
func (m *GetShardRet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetShardRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetShardRet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetShardRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetShardRet.Merge(m, src)
}
func (m *GetShardRet) XXX_Size() int {
	return m.Size()
}
func (m *GetShardRet) XXX_DiscardUnknown() {
	xxx_messageInfo_GetShardRet.DiscardUnknown(m)
}

var xxx_messageInfo_GetShardRet proto.InternalMessageInfo

func (m *GetShardRet) GetShard() clustermgr.ShardUnitInfo {
	if m != nil {
		return m.Shard
	}
	return clustermgr.ShardUnitInfo{}
}

type CreateBlobArgs struct {
	Header               ShardOpHeader                                               `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Name                 []byte                                                      `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	CodeMode             github_com_cubefs_cubefs_blobstore_common_codemode.CodeMode `protobuf:"varint,3,opt,name=codemode,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/codemode.CodeMode" json:"codemode,omitempty"`
	Size_                uint64                                                      `protobuf:"varint,4,opt,name=size,proto3" json:"size,omitempty"`
	SliceSize            uint32                                                      `protobuf:"varint,5,opt,name=slice_size,json=sliceSize,proto3" json:"slice_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                    `json:"-"`
	XXX_unrecognized     []byte                                                      `json:"-"`
	XXX_sizecache        int32                                                       `json:"-"`
}

func (m *CreateBlobArgs) Reset()         { *m = CreateBlobArgs{} }
func (m *CreateBlobArgs) String() string { return proto.CompactTextString(m) }
func (*CreateBlobArgs) ProtoMessage()    {}
func (*CreateBlobArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{19}
}
func (m *CreateBlobArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateBlobArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateBlobArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateBlobArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateBlobArgs.Merge(m, src)
}
func (m *CreateBlobArgs) XXX_Size() int {
	return m.Size()
}
func (m *CreateBlobArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateBlobArgs.DiscardUnknown(m)
}

var xxx_messageInfo_CreateBlobArgs proto.InternalMessageInfo

func (m *CreateBlobArgs) GetHeader() ShardOpHeader {
	if m != nil {
		return m.Header
	}
	return ShardOpHeader{}
}

func (m *CreateBlobArgs) GetName() []byte {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *CreateBlobArgs) GetCodeMode() github_com_cubefs_cubefs_blobstore_common_codemode.CodeMode {
	if m != nil {
		return m.CodeMode
	}
	return 0
}

func (m *CreateBlobArgs) GetSize_() uint64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *CreateBlobArgs) GetSliceSize() uint32 {
	if m != nil {
		return m.SliceSize
	}
	return 0
}

type CreateBlobRet struct {
	Blob                 proto1.Blob `protobuf:"bytes,1,opt,name=blob,proto3" json:"blob"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *CreateBlobRet) Reset()         { *m = CreateBlobRet{} }
func (m *CreateBlobRet) String() string { return proto.CompactTextString(m) }
func (*CreateBlobRet) ProtoMessage()    {}
func (*CreateBlobRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{20}
}
func (m *CreateBlobRet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateBlobRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateBlobRet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateBlobRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateBlobRet.Merge(m, src)
}
func (m *CreateBlobRet) XXX_Size() int {
	return m.Size()
}
func (m *CreateBlobRet) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateBlobRet.DiscardUnknown(m)
}

var xxx_messageInfo_CreateBlobRet proto.InternalMessageInfo

func (m *CreateBlobRet) GetBlob() proto1.Blob {
	if m != nil {
		return m.Blob
	}
	return proto1.Blob{}
}

type GetBlobArgs struct {
	Header               ShardOpHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Name                 []byte        `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *GetBlobArgs) Reset()         { *m = GetBlobArgs{} }
func (m *GetBlobArgs) String() string { return proto.CompactTextString(m) }
func (*GetBlobArgs) ProtoMessage()    {}
func (*GetBlobArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{21}
}
func (m *GetBlobArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetBlobArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetBlobArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetBlobArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetBlobArgs.Merge(m, src)
}
func (m *GetBlobArgs) XXX_Size() int {
	return m.Size()
}
func (m *GetBlobArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_GetBlobArgs.DiscardUnknown(m)
}

var xxx_messageInfo_GetBlobArgs proto.InternalMessageInfo

func (m *GetBlobArgs) GetHeader() ShardOpHeader {
	if m != nil {
		return m.Header
	}
	return ShardOpHeader{}
}

func (m *GetBlobArgs) GetName() []byte {
	if m != nil {
		return m.Name
	}
	return nil
}

type GetBlobRet struct {
	Blob                 proto1.Blob `protobuf:"bytes,1,opt,name=blob,proto3" json:"blob"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *GetBlobRet) Reset()         { *m = GetBlobRet{} }
func (m *GetBlobRet) String() string { return proto.CompactTextString(m) }
func (*GetBlobRet) ProtoMessage()    {}
func (*GetBlobRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{22}
}
func (m *GetBlobRet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetBlobRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetBlobRet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetBlobRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetBlobRet.Merge(m, src)
}
func (m *GetBlobRet) XXX_Size() int {
	return m.Size()
}
func (m *GetBlobRet) XXX_DiscardUnknown() {
	xxx_messageInfo_GetBlobRet.DiscardUnknown(m)
}

var xxx_messageInfo_GetBlobRet proto.InternalMessageInfo

func (m *GetBlobRet) GetBlob() proto1.Blob {
	if m != nil {
		return m.Blob
	}
	return proto1.Blob{}
}

type ListBlobArgs struct {
	Header               ShardOpHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Prefix               []byte        `protobuf:"bytes,2,opt,name=prefix,proto3" json:"prefix,omitempty"`
	Marker               []byte        `protobuf:"bytes,3,opt,name=marker,proto3" json:"marker,omitempty"`
	Count                uint64        `protobuf:"varint,4,opt,name=count,proto3" json:"count,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ListBlobArgs) Reset()         { *m = ListBlobArgs{} }
func (m *ListBlobArgs) String() string { return proto.CompactTextString(m) }
func (*ListBlobArgs) ProtoMessage()    {}
func (*ListBlobArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{23}
}
func (m *ListBlobArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListBlobArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListBlobArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListBlobArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListBlobArgs.Merge(m, src)
}
func (m *ListBlobArgs) XXX_Size() int {
	return m.Size()
}
func (m *ListBlobArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_ListBlobArgs.DiscardUnknown(m)
}

var xxx_messageInfo_ListBlobArgs proto.InternalMessageInfo

func (m *ListBlobArgs) GetHeader() ShardOpHeader {
	if m != nil {
		return m.Header
	}
	return ShardOpHeader{}
}

func (m *ListBlobArgs) GetPrefix() []byte {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func (m *ListBlobArgs) GetMarker() []byte {
	if m != nil {
		return m.Marker
	}
	return nil
}

func (m *ListBlobArgs) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

type ListBlobRet struct {
	Blobs                []proto1.Blob `protobuf:"bytes,1,rep,name=blobs,proto3" json:"blobs"`
	NextMarker           []byte        `protobuf:"bytes,2,opt,name=nextMarker,proto3" json:"nextMarker,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ListBlobRet) Reset()         { *m = ListBlobRet{} }
func (m *ListBlobRet) String() string { return proto.CompactTextString(m) }
func (*ListBlobRet) ProtoMessage()    {}
func (*ListBlobRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{24}
}
func (m *ListBlobRet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListBlobRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListBlobRet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListBlobRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListBlobRet.Merge(m, src)
}
func (m *ListBlobRet) XXX_Size() int {
	return m.Size()
}
func (m *ListBlobRet) XXX_DiscardUnknown() {
	xxx_messageInfo_ListBlobRet.DiscardUnknown(m)
}

var xxx_messageInfo_ListBlobRet proto.InternalMessageInfo

func (m *ListBlobRet) GetBlobs() []proto1.Blob {
	if m != nil {
		return m.Blobs
	}
	return nil
}

func (m *ListBlobRet) GetNextMarker() []byte {
	if m != nil {
		return m.NextMarker
	}
	return nil
}

type DeleteBlobArgs struct {
	Header               ShardOpHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Name                 []byte        `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *DeleteBlobArgs) Reset()         { *m = DeleteBlobArgs{} }
func (m *DeleteBlobArgs) String() string { return proto.CompactTextString(m) }
func (*DeleteBlobArgs) ProtoMessage()    {}
func (*DeleteBlobArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{25}
}
func (m *DeleteBlobArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteBlobArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteBlobArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteBlobArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteBlobArgs.Merge(m, src)
}
func (m *DeleteBlobArgs) XXX_Size() int {
	return m.Size()
}
func (m *DeleteBlobArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteBlobArgs.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteBlobArgs proto.InternalMessageInfo

func (m *DeleteBlobArgs) GetHeader() ShardOpHeader {
	if m != nil {
		return m.Header
	}
	return ShardOpHeader{}
}

func (m *DeleteBlobArgs) GetName() []byte {
	if m != nil {
		return m.Name
	}
	return nil
}

type DeleteBlobRet struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteBlobRet) Reset()         { *m = DeleteBlobRet{} }
func (m *DeleteBlobRet) String() string { return proto.CompactTextString(m) }
func (*DeleteBlobRet) ProtoMessage()    {}
func (*DeleteBlobRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{26}
}
func (m *DeleteBlobRet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteBlobRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteBlobRet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteBlobRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteBlobRet.Merge(m, src)
}
func (m *DeleteBlobRet) XXX_Size() int {
	return m.Size()
}
func (m *DeleteBlobRet) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteBlobRet.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteBlobRet proto.InternalMessageInfo

type RetainBlobArgs struct {
	Header               ShardOpHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Name                 []byte        `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Lease                uint64        `protobuf:"varint,3,opt,name=lease,proto3" json:"lease,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *RetainBlobArgs) Reset()         { *m = RetainBlobArgs{} }
func (m *RetainBlobArgs) String() string { return proto.CompactTextString(m) }
func (*RetainBlobArgs) ProtoMessage()    {}
func (*RetainBlobArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{27}
}
func (m *RetainBlobArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RetainBlobArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RetainBlobArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RetainBlobArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RetainBlobArgs.Merge(m, src)
}
func (m *RetainBlobArgs) XXX_Size() int {
	return m.Size()
}
func (m *RetainBlobArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_RetainBlobArgs.DiscardUnknown(m)
}

var xxx_messageInfo_RetainBlobArgs proto.InternalMessageInfo

func (m *RetainBlobArgs) GetHeader() ShardOpHeader {
	if m != nil {
		return m.Header
	}
	return ShardOpHeader{}
}

func (m *RetainBlobArgs) GetName() []byte {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *RetainBlobArgs) GetLease() uint64 {
	if m != nil {
		return m.Lease
	}
	return 0
}

type RetainBlobRet struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RetainBlobRet) Reset()         { *m = RetainBlobRet{} }
func (m *RetainBlobRet) String() string { return proto.CompactTextString(m) }
func (*RetainBlobRet) ProtoMessage()    {}
func (*RetainBlobRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{28}
}
func (m *RetainBlobRet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RetainBlobRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RetainBlobRet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RetainBlobRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RetainBlobRet.Merge(m, src)
}
func (m *RetainBlobRet) XXX_Size() int {
	return m.Size()
}
func (m *RetainBlobRet) XXX_DiscardUnknown() {
	xxx_messageInfo_RetainBlobRet.DiscardUnknown(m)
}

var xxx_messageInfo_RetainBlobRet proto.InternalMessageInfo

type SealBlobArgs struct {
	Header               ShardOpHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Size_                uint64        `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`
	Name                 []byte        `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *SealBlobArgs) Reset()         { *m = SealBlobArgs{} }
func (m *SealBlobArgs) String() string { return proto.CompactTextString(m) }
func (*SealBlobArgs) ProtoMessage()    {}
func (*SealBlobArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{29}
}
func (m *SealBlobArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SealBlobArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SealBlobArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SealBlobArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SealBlobArgs.Merge(m, src)
}
func (m *SealBlobArgs) XXX_Size() int {
	return m.Size()
}
func (m *SealBlobArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_SealBlobArgs.DiscardUnknown(m)
}

var xxx_messageInfo_SealBlobArgs proto.InternalMessageInfo

func (m *SealBlobArgs) GetHeader() ShardOpHeader {
	if m != nil {
		return m.Header
	}
	return ShardOpHeader{}
}

func (m *SealBlobArgs) GetSize_() uint64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *SealBlobArgs) GetName() []byte {
	if m != nil {
		return m.Name
	}
	return nil
}

type SealBlobRet struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SealBlobRet) Reset()         { *m = SealBlobRet{} }
func (m *SealBlobRet) String() string { return proto.CompactTextString(m) }
func (*SealBlobRet) ProtoMessage()    {}
func (*SealBlobRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{30}
}
func (m *SealBlobRet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SealBlobRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SealBlobRet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SealBlobRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SealBlobRet.Merge(m, src)
}
func (m *SealBlobRet) XXX_Size() int {
	return m.Size()
}
func (m *SealBlobRet) XXX_DiscardUnknown() {
	xxx_messageInfo_SealBlobRet.DiscardUnknown(m)
}

var xxx_messageInfo_SealBlobRet proto.InternalMessageInfo

type ShardStats struct {
	Suid                 github_com_cubefs_cubefs_blobstore_common_proto.Suid         `protobuf:"varint,1,opt,name=suid,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.Suid" json:"suid,omitempty"`
	AppliedIndex         uint64                                                       `protobuf:"varint,2,opt,name=applied_index,json=appliedIndex,proto3" json:"applied_index,omitempty"`
	LeaderIdx            uint32                                                       `protobuf:"varint,3,opt,name=leader_idx,json=leaderIdx,proto3" json:"leader_idx,omitempty"`
	RouteVersion         github_com_cubefs_cubefs_blobstore_common_proto.RouteVersion `protobuf:"varint,4,opt,name=route_version,json=routeVersion,proto3,casttype=github.com/cubefs/cubefs/blobstore/common/proto.RouteVersion" json:"route_version,omitempty"`
	Range                sharding.Range                                               `protobuf:"bytes,5,opt,name=range,proto3" json:"range"`
	Units                []clustermgr.ShardUnit                                       `protobuf:"bytes,6,rep,name=units,proto3" json:"units"`
	Learner              bool                                                         `protobuf:"varint,7,opt,name=learner,proto3" json:"learner,omitempty"`
	RaftStat             raft.Stat                                                    `protobuf:"bytes,8,opt,name=raftStat,proto3" json:"raftStat"`
	XXX_NoUnkeyedLiteral struct{}                                                     `json:"-"`
	XXX_unrecognized     []byte                                                       `json:"-"`
	XXX_sizecache        int32                                                        `json:"-"`
}

func (m *ShardStats) Reset()         { *m = ShardStats{} }
func (m *ShardStats) String() string { return proto.CompactTextString(m) }
func (*ShardStats) ProtoMessage()    {}
func (*ShardStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d3815ca0e5f30f0, []int{31}
}
func (m *ShardStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardStats.Merge(m, src)
}
func (m *ShardStats) XXX_Size() int {
	return m.Size()
}
func (m *ShardStats) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardStats.DiscardUnknown(m)
}

var xxx_messageInfo_ShardStats proto.InternalMessageInfo

func (m *ShardStats) GetSuid() github_com_cubefs_cubefs_blobstore_common_proto.Suid {
	if m != nil {
		return m.Suid
	}
	return 0
}

func (m *ShardStats) GetAppliedIndex() uint64 {
	if m != nil {
		return m.AppliedIndex
	}
	return 0
}

func (m *ShardStats) GetLeaderIdx() uint32 {
	if m != nil {
		return m.LeaderIdx
	}
	return 0
}

func (m *ShardStats) GetRouteVersion() github_com_cubefs_cubefs_blobstore_common_proto.RouteVersion {
	if m != nil {
		return m.RouteVersion
	}
	return 0
}

func (m *ShardStats) GetRange() sharding.Range {
	if m != nil {
		return m.Range
	}
	return sharding.Range{}
}

func (m *ShardStats) GetUnits() []clustermgr.ShardUnit {
	if m != nil {
		return m.Units
	}
	return nil
}

func (m *ShardStats) GetLearner() bool {
	if m != nil {
		return m.Learner
	}
	return false
}

func (m *ShardStats) GetRaftStat() raft.Stat {
	if m != nil {
		return m.RaftStat
	}
	return raft.Stat{}
}

func init() {
	proto.RegisterType((*Item)(nil), "cubefs.blobstore.api.shardnode.Item")
	proto.RegisterType((*Field)(nil), "cubefs.blobstore.api.shardnode.Field")
	proto.RegisterType((*ShardOpHeader)(nil), "cubefs.blobstore.api.shardnode.ShardOpHeader")
	proto.RegisterType((*InsertItemArgs)(nil), "cubefs.blobstore.api.shardnode.InsertItemArgs")
	proto.RegisterType((*InsertItemRet)(nil), "cubefs.blobstore.api.shardnode.InsertItemRet")
	proto.RegisterType((*UpdateItemArgs)(nil), "cubefs.blobstore.api.shardnode.UpdateItemArgs")
	proto.RegisterType((*UpdateItemRet)(nil), "cubefs.blobstore.api.shardnode.UpdateItemRet")
	proto.RegisterType((*DeleteItemArgs)(nil), "cubefs.blobstore.api.shardnode.DeleteItemArgs")
	proto.RegisterType((*DeleteItemRet)(nil), "cubefs.blobstore.api.shardnode.DeleteItemRet")
	proto.RegisterType((*GetItemArgs)(nil), "cubefs.blobstore.api.shardnode.GetItemArgs")
	proto.RegisterType((*GetItemRet)(nil), "cubefs.blobstore.api.shardnode.GetItemRet")
	proto.RegisterType((*ListItemArgs)(nil), "cubefs.blobstore.api.shardnode.ListItemArgs")
	proto.RegisterType((*ListItemRet)(nil), "cubefs.blobstore.api.shardnode.ListItemRet")
	proto.RegisterType((*AddShardArgs)(nil), "cubefs.blobstore.api.shardnode.AddShardArgs")
	proto.RegisterType((*AddShardRet)(nil), "cubefs.blobstore.api.shardnode.AddShardRet")
	proto.RegisterType((*UpdateShardArgs)(nil), "cubefs.blobstore.api.shardnode.UpdateShardArgs")
	proto.RegisterType((*UpdateShardRet)(nil), "cubefs.blobstore.api.shardnode.UpdateShardRet")
	proto.RegisterType((*GetShardArgs)(nil), "cubefs.blobstore.api.shardnode.GetShardArgs")
	proto.RegisterType((*GetShardRet)(nil), "cubefs.blobstore.api.shardnode.GetShardRet")
	proto.RegisterType((*CreateBlobArgs)(nil), "cubefs.blobstore.api.shardnode.CreateBlobArgs")
	proto.RegisterType((*CreateBlobRet)(nil), "cubefs.blobstore.api.shardnode.CreateBlobRet")
	proto.RegisterType((*GetBlobArgs)(nil), "cubefs.blobstore.api.shardnode.GetBlobArgs")
	proto.RegisterType((*GetBlobRet)(nil), "cubefs.blobstore.api.shardnode.GetBlobRet")
	proto.RegisterType((*ListBlobArgs)(nil), "cubefs.blobstore.api.shardnode.ListBlobArgs")
	proto.RegisterType((*ListBlobRet)(nil), "cubefs.blobstore.api.shardnode.ListBlobRet")
	proto.RegisterType((*DeleteBlobArgs)(nil), "cubefs.blobstore.api.shardnode.DeleteBlobArgs")
	proto.RegisterType((*DeleteBlobRet)(nil), "cubefs.blobstore.api.shardnode.DeleteBlobRet")
	proto.RegisterType((*RetainBlobArgs)(nil), "cubefs.blobstore.api.shardnode.RetainBlobArgs")
	proto.RegisterType((*RetainBlobRet)(nil), "cubefs.blobstore.api.shardnode.RetainBlobRet")
	proto.RegisterType((*SealBlobArgs)(nil), "cubefs.blobstore.api.shardnode.SealBlobArgs")
	proto.RegisterType((*SealBlobRet)(nil), "cubefs.blobstore.api.shardnode.SealBlobRet")
	proto.RegisterType((*ShardStats)(nil), "cubefs.blobstore.api.shardnode.ShardStats")
}

func init() { proto.RegisterFile("shardnode.proto", fileDescriptor_9d3815ca0e5f30f0) }

var fileDescriptor_9d3815ca0e5f30f0 = []byte{
	// 1178 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x58, 0xdd, 0x6e, 0x1b, 0x45,
	0x14, 0x66, 0xed, 0xb5, 0xe3, 0x1e, 0xdb, 0x09, 0x5a, 0x45, 0xc8, 0x8a, 0x44, 0x36, 0xda, 0x82,
	0x1a, 0xf1, 0xb3, 0x96, 0x02, 0x82, 0x8b, 0x02, 0x4d, 0x1c, 0x2b, 0xc5, 0xa4, 0x05, 0xb1, 0x6e,
	0x2b, 0x81, 0x84, 0xac, 0xb5, 0x67, 0xec, 0x8c, 0xb2, 0xde, 0x5d, 0x76, 0x67, 0xab, 0xa4, 0x57,
	0x48, 0x5c, 0x70, 0x85, 0x78, 0x02, 0x2e, 0x78, 0x0a, 0x1e, 0x80, 0x9b, 0x5e, 0xc2, 0x0b, 0xac,
	0x90, 0x1f, 0x23, 0x57, 0x68, 0xce, 0xcc, 0xae, 0xf3, 0x43, 0x9a, 0x3a, 0xd8, 0x11, 0xbd, 0xa9,
	0x76, 0x8e, 0xcf, 0xcf, 0x77, 0x7e, 0xe6, 0x3b, 0xd3, 0xc0, 0x4a, 0x7c, 0xe0, 0x46, 0xc4, 0x0f,
	0x08, 0xb5, 0xc3, 0x28, 0xe0, 0x81, 0xb1, 0x3e, 0x48, 0xfa, 0x74, 0x18, 0xdb, 0x7d, 0x2f, 0xe8,
	0xc7, 0x3c, 0x88, 0xa8, 0xed, 0x86, 0xcc, 0xce, 0xb5, 0xd6, 0x56, 0x47, 0xc1, 0x28, 0x40, 0xd5,
	0xa6, 0xf8, 0x92, 0x56, 0x6b, 0xef, 0x49, 0xab, 0x66, 0x6e, 0xd5, 0x1c, 0x04, 0xe3, 0x71, 0xe0,
	0x37, 0xd1, 0x90, 0xf9, 0xa3, 0x66, 0xe4, 0xfa, 0x23, 0x15, 0x63, 0xed, 0xdd, 0x0b, 0xda, 0x6e,
	0xc8, 0x9a, 0x03, 0x2f, 0x89, 0x39, 0x8d, 0xc6, 0xa3, 0x48, 0x5a, 0x29, 0xe5, 0xcd, 0xcb, 0x5c,
	0x4b, 0x10, 0x42, 0xac, 0x34, 0xef, 0x5c, 0xa6, 0x19, 0xb9, 0x43, 0x8e, 0xff, 0x48, 0x45, 0x6b,
	0x00, 0x7a, 0x87, 0xd3, 0xb1, 0xf1, 0x06, 0x14, 0x18, 0x69, 0x68, 0x1b, 0xda, 0x66, 0xad, 0x55,
	0x9e, 0xa4, 0x66, 0xa1, 0xd3, 0x76, 0x0a, 0x8c, 0x18, 0xbb, 0x50, 0x1e, 0x32, 0xea, 0x91, 0xb8,
	0x51, 0xd8, 0x28, 0x6e, 0x56, 0xb7, 0xde, 0xb6, 0x5f, 0x5c, 0x14, 0x7b, 0x4f, 0x68, 0xb7, 0xf4,
	0xe7, 0xa9, 0xf9, 0x9a, 0xa3, 0x4c, 0xad, 0x10, 0x4a, 0x28, 0x36, 0xbe, 0xce, 0xa3, 0xd4, 0x5b,
	0x3b, 0x32, 0xca, 0x49, 0x6a, 0x7e, 0x3c, 0x62, 0xfc, 0x20, 0xe9, 0xdb, 0x83, 0x60, 0xdc, 0x54,
	0xb8, 0x5f, 0x98, 0xa8, 0x8c, 0xa1, 0x00, 0xae, 0x42, 0xe9, 0xa9, 0xeb, 0x25, 0xb4, 0x51, 0x10,
	0xd8, 0x1d, 0x79, 0xb0, 0xfe, 0x2a, 0x42, 0xbd, 0x2b, 0x30, 0x7d, 0x15, 0x7e, 0x4e, 0x5d, 0x42,
	0x23, 0xc3, 0x85, 0x4a, 0x1c, 0xba, 0x03, 0xda, 0x53, 0x00, 0xf4, 0xd6, 0xde, 0x24, 0x35, 0x97,
	0xba, 0x42, 0x76, 0x3d, 0x14, 0xca, 0xd4, 0x59, 0x42, 0xbf, 0x1d, 0x62, 0x7c, 0x07, 0x4b, 0x84,
	0xc5, 0x87, 0x22, 0x42, 0x01, 0x53, 0x6c, 0x4f, 0x52, 0xb3, 0xdc, 0x66, 0xf1, 0x21, 0x06, 0xf8,
	0x68, 0xd6, 0x00, 0xd2, 0xd2, 0x29, 0x0b, 0xa7, 0x1d, 0x62, 0x3c, 0x02, 0x3d, 0x4e, 0x18, 0x69,
	0x14, 0xd1, 0xf7, 0xf6, 0x24, 0x35, 0xf5, 0x6e, 0xc2, 0xc8, 0x49, 0x6a, 0x7e, 0x38, 0x33, 0xf4,
	0x84, 0x11, 0x07, 0xbd, 0x19, 0x16, 0xd4, 0x10, 0xff, 0x13, 0x1a, 0xc5, 0x2c, 0xf0, 0x1b, 0xba,
	0xa8, 0x8d, 0x73, 0x46, 0x66, 0x50, 0xa8, 0x47, 0x41, 0xc2, 0x69, 0xef, 0xa9, 0x52, 0x2a, 0x61,
	0x01, 0xb7, 0x4f, 0x52, 0xf3, 0x93, 0x59, 0x43, 0x3b, 0xc2, 0x91, 0x72, 0xec, 0xd4, 0xa2, 0x53,
	0x27, 0xe3, 0x4d, 0x00, 0x9c, 0xa3, 0xde, 0x21, 0x3d, 0x8e, 0x1b, 0xe5, 0x8d, 0xe2, 0x66, 0xcd,
	0xb9, 0x85, 0x92, 0x7d, 0x7a, 0x1c, 0x5b, 0xbf, 0x6a, 0xb0, 0xdc, 0xf1, 0x63, 0x1a, 0x71, 0x31,
	0xb1, 0x3b, 0xd1, 0x28, 0x36, 0xf6, 0xa1, 0x7c, 0x80, 0xed, 0xc5, 0x96, 0x56, 0xb7, 0xde, 0xbf,
	0x6a, 0x3a, 0xcf, 0xcc, 0x44, 0x36, 0xa5, 0xd2, 0x85, 0xf1, 0x19, 0xe8, 0x8c, 0xd3, 0x31, 0xf6,
	0xae, 0xba, 0xf5, 0xd6, 0x55, 0xae, 0x04, 0x08, 0xe5, 0x01, 0xed, 0xac, 0x15, 0xa8, 0x4f, 0xe1,
	0x39, 0x94, 0x23, 0xe0, 0xc7, 0x21, 0x71, 0x39, 0xfd, 0xdf, 0x02, 0x9e, 0xc2, 0x13, 0x80, 0x13,
	0x58, 0x6e, 0x53, 0x8f, 0x2e, 0x0a, 0xaf, 0xe4, 0x98, 0xc2, 0x79, 0x8e, 0x11, 0x38, 0xa6, 0x61,
	0x05, 0x8e, 0x08, 0xaa, 0xf7, 0x29, 0xbf, 0x59, 0x10, 0x0f, 0x00, 0x54, 0x4c, 0x87, 0xf2, 0xbc,
	0xb4, 0xda, 0x35, 0x4b, 0xfb, 0x9b, 0x06, 0xb5, 0x07, 0x2c, 0x5e, 0x58, 0x0e, 0xe5, 0x30, 0xa2,
	0x43, 0x76, 0xa4, 0x48, 0x4f, 0x9d, 0x84, 0x7c, 0xec, 0x46, 0x87, 0x34, 0x42, 0x8e, 0xa8, 0x39,
	0xea, 0x24, 0x38, 0x72, 0x10, 0x24, 0x3e, 0x57, 0x97, 0x5b, 0x1e, 0xac, 0x00, 0xaa, 0x19, 0x44,
	0x91, 0xf2, 0x36, 0x94, 0x04, 0xf4, 0xb8, 0xa1, 0x21, 0xd1, 0xcf, 0x92, 0xb3, 0x34, 0x34, 0xd6,
	0x01, 0x7c, 0x7a, 0xc4, 0x1f, 0x4a, 0x08, 0x12, 0xda, 0x29, 0x89, 0xf5, 0x7b, 0x11, 0x6a, 0x3b,
	0x84, 0x60, 0x66, 0x58, 0x94, 0x53, 0x84, 0xa9, 0x2d, 0x90, 0x30, 0x0b, 0x92, 0xad, 0xe6, 0x44,
	0x98, 0xbb, 0x50, 0xc2, 0x05, 0x8e, 0x35, 0xae, 0x6e, 0xdd, 0xb9, 0x58, 0x27, 0x69, 0x69, 0x67,
	0xfb, 0xde, 0x76, 0x84, 0x7a, 0x56, 0x2a, 0xb4, 0x35, 0xf6, 0xa0, 0x94, 0xf8, 0x8c, 0xc7, 0x0d,
	0x1d, 0x8b, 0xfd, 0xce, 0xbf, 0x17, 0x7b, 0xfa, 0x0c, 0x90, 0xe3, 0xf0, 0xd8, 0x67, 0x3c, 0xf3,
	0x83, 0xe6, 0x37, 0xc4, 0xcc, 0x56, 0x1d, 0xaa, 0x59, 0xe3, 0xc4, 0xfd, 0xfc, 0xa5, 0x08, 0x2b,
	0x92, 0x39, 0x5e, 0xf1, 0x5e, 0xfe, 0xa0, 0xc1, 0x8a, 0xac, 0x2c, 0x66, 0xf3, 0xe8, 0x38, 0xa4,
	0x6a, 0xbd, 0x3e, 0x99, 0xa4, 0xe6, 0xf9, 0x9f, 0x4e, 0x52, 0xf3, 0xde, 0xcc, 0xc1, 0xce, 0xba,
	0x70, 0xce, 0xfb, 0x34, 0xda, 0xa0, 0x8b, 0x56, 0xe2, 0xd5, 0xbc, 0xce, 0x20, 0xa0, 0xb5, 0xf5,
	0x7a, 0xb6, 0x69, 0xf2, 0x1e, 0xfd, 0xa1, 0x41, 0xed, 0x3e, 0xe5, 0xaf, 0x76, 0x83, 0xac, 0x6f,
	0x70, 0x13, 0x64, 0x49, 0x19, 0x5f, 0x40, 0x09, 0x6f, 0x95, 0x22, 0x51, 0xfb, 0xe5, 0xab, 0xd5,
	0xf1, 0x87, 0x41, 0x76, 0x75, 0xd0, 0x85, 0xf5, 0x73, 0x01, 0x96, 0x77, 0x23, 0xea, 0x72, 0xda,
	0xf2, 0x82, 0xfe, 0xfc, 0x49, 0xda, 0x00, 0xdd, 0x77, 0xc7, 0xd9, 0xbb, 0x14, 0xbf, 0x8d, 0x11,
	0x54, 0x06, 0x01, 0xa1, 0xe3, 0x80, 0x64, 0x73, 0xb6, 0x3f, 0x49, 0xcd, 0xca, 0x6e, 0x40, 0xe8,
	0xc3, 0x80, 0x88, 0x01, 0xbb, 0xfb, 0xf2, 0xc5, 0xca, 0x3c, 0xd9, 0x99, 0xb9, 0x93, 0x3b, 0x17,
	0xc1, 0x63, 0xf6, 0x8c, 0x2a, 0xc2, 0xc7, 0x6f, 0x7c, 0x5e, 0x79, 0x6c, 0x40, 0x7b, 0xf8, 0x8b,
	0x20, 0x8a, 0xba, 0x73, 0x0b, 0x25, 0x5d, 0xf6, 0x8c, 0x5a, 0x5f, 0x42, 0x7d, 0x5a, 0x0e, 0x51,
	0xec, 0x4f, 0x41, 0x17, 0x31, 0x55, 0x2d, 0x6e, 0x5f, 0xca, 0x73, 0xb2, 0x69, 0xc2, 0x2a, 0x1b,
	0x49, 0xa1, 0x62, 0xf9, 0xd8, 0xba, 0x1b, 0xab, 0xad, 0xb5, 0x8f, 0x0b, 0x7c, 0x4e, 0xe0, 0xb3,
	0xfd, 0xbd, 0x18, 0xf8, 0xf3, 0xd9, 0xdf, 0xbe, 0xdc, 0xdf, 0x59, 0xc6, 0xf7, 0xa0, 0x84, 0x58,
	0xd4, 0xfe, 0x9e, 0x21, 0x65, 0x69, 0x77, 0xe5, 0xfa, 0xfe, 0x3e, 0x7b, 0x1d, 0xde, 0x5c, 0x4f,
	0xf3, 0x97, 0xa1, 0x4a, 0xd2, 0xfa, 0x49, 0x83, 0x65, 0x87, 0x72, 0x97, 0xf9, 0x37, 0x77, 0x69,
	0x57, 0xa1, 0xe4, 0x51, 0x37, 0x96, 0x37, 0x56, 0x77, 0xe4, 0x41, 0x40, 0x9b, 0x02, 0x11, 0xd0,
	0x7e, 0xd4, 0xa0, 0xd6, 0xa5, 0xae, 0xb7, 0x30, 0x60, 0x78, 0x6d, 0x0b, 0xa7, 0x2e, 0x74, 0x06,
	0xb6, 0x78, 0xaa, 0x62, 0x75, 0xa8, 0x66, 0x20, 0x04, 0xa8, 0x93, 0x22, 0x00, 0xba, 0xed, 0x72,
	0x97, 0xc7, 0x39, 0x49, 0x6b, 0x73, 0xdd, 0xa2, 0xb7, 0xa1, 0xee, 0x86, 0xa1, 0xc7, 0x28, 0xe9,
	0x31, 0x9f, 0xd0, 0x23, 0x05, 0xb2, 0xa6, 0x84, 0x1d, 0x21, 0x13, 0xec, 0xe3, 0x61, 0x2a, 0x3d,
	0x46, 0x8e, 0x24, 0xf9, 0x39, 0xb7, 0xa4, 0xa4, 0x43, 0x8e, 0x2e, 0x3e, 0x64, 0xf4, 0x85, 0xfc,
	0x17, 0x33, 0x7f, 0xbc, 0x95, 0xe6, 0xf1, 0x78, 0x2b, 0xff, 0xb7, 0xc7, 0x5b, 0x03, 0x96, 0x3c,
	0xea, 0x46, 0x3e, 0x8d, 0x1a, 0x4b, 0x1b, 0xda, 0x66, 0xc5, 0xc9, 0x8e, 0x46, 0x1b, 0x2a, 0x91,
	0x3b, 0xe4, 0xa2, 0x69, 0x8d, 0x0a, 0x22, 0xb5, 0x2e, 0x45, 0x8a, 0x7f, 0xcc, 0x11, 0x9a, 0xca,
	0x79, 0x6e, 0xd9, 0x5a, 0x7b, 0x3e, 0x59, 0xd7, 0xfe, 0x9c, 0xac, 0x6b, 0x7f, 0x4f, 0xd6, 0xb5,
	0x6f, 0x6b, 0x76, 0xf3, 0x6e, 0x3e, 0x6b, 0xfd, 0x32, 0x96, 0xea, 0x83, 0x7f, 0x02, 0x00, 0x00,
	0xff, 0xff, 0x02, 0xaf, 0x38, 0x34, 0xf5, 0x12, 0x00, 0x00,
}

func (m *Item) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Item) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Item) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Fields[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintShardnode(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintShardnode(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Field) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Field) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Field) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintShardnode(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if m.ID != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ShardOpHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardOpHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShardOpHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ShardKeys) > 0 {
		for iNdEx := len(m.ShardKeys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ShardKeys[iNdEx])
			copy(dAtA[i:], m.ShardKeys[iNdEx])
			i = encodeVarintShardnode(dAtA, i, uint64(len(m.ShardKeys[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.RouteVersion != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.RouteVersion))
		i--
		dAtA[i] = 0x28
	}
	if m.SpaceVersion != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.SpaceVersion))
		i--
		dAtA[i] = 0x20
	}
	if m.Suid != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.Suid))
		i--
		dAtA[i] = 0x18
	}
	if m.DiskID != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.DiskID))
		i--
		dAtA[i] = 0x10
	}
	if m.SpaceID != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.SpaceID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *InsertItemArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InsertItemArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InsertItemArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *InsertItemRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InsertItemRet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InsertItemRet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *UpdateItemArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateItemArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateItemArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *UpdateItemRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateItemRet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateItemRet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *DeleteItemArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteItemArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteItemArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintShardnode(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DeleteItemRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteItemRet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteItemRet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *GetItemArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetItemArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetItemArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintShardnode(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *GetItemRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetItemRet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetItemRet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ListItemArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListItemArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListItemArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Count != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Marker) > 0 {
		i -= len(m.Marker)
		copy(dAtA[i:], m.Marker)
		i = encodeVarintShardnode(dAtA, i, uint64(len(m.Marker)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Prefix) > 0 {
		i -= len(m.Prefix)
		copy(dAtA[i:], m.Prefix)
		i = encodeVarintShardnode(dAtA, i, uint64(len(m.Prefix)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ListItemRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListItemRet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListItemRet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NextMarker) > 0 {
		i -= len(m.NextMarker)
		copy(dAtA[i:], m.NextMarker)
		i = encodeVarintShardnode(dAtA, i, uint64(len(m.NextMarker)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintShardnode(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AddShardArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddShardArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddShardArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RouteVersion != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.RouteVersion))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Units) > 0 {
		for iNdEx := len(m.Units) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Units[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintShardnode(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	{
		size, err := m.Range.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.Suid != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.Suid))
		i--
		dAtA[i] = 0x10
	}
	if m.DiskID != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.DiskID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AddShardRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddShardRet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddShardRet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *UpdateShardArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateShardArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateShardArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Unit.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.ShardUpdateType != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.ShardUpdateType))
		i--
		dAtA[i] = 0x18
	}
	if m.Suid != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.Suid))
		i--
		dAtA[i] = 0x10
	}
	if m.DiskID != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.DiskID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateShardRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateShardRet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateShardRet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *GetShardArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetShardArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetShardArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Suid != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.Suid))
		i--
		dAtA[i] = 0x10
	}
	if m.DiskID != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.DiskID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetShardRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetShardRet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetShardRet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Shard.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CreateBlobArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateBlobArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateBlobArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SliceSize != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.SliceSize))
		i--
		dAtA[i] = 0x28
	}
	if m.Size_ != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x20
	}
	if m.CodeMode != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.CodeMode))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintShardnode(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CreateBlobRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateBlobRet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateBlobRet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Blob.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *GetBlobArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetBlobArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetBlobArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintShardnode(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *GetBlobRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetBlobRet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetBlobRet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Blob.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ListBlobArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListBlobArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListBlobArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Count != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Marker) > 0 {
		i -= len(m.Marker)
		copy(dAtA[i:], m.Marker)
		i = encodeVarintShardnode(dAtA, i, uint64(len(m.Marker)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Prefix) > 0 {
		i -= len(m.Prefix)
		copy(dAtA[i:], m.Prefix)
		i = encodeVarintShardnode(dAtA, i, uint64(len(m.Prefix)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ListBlobRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListBlobRet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListBlobRet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NextMarker) > 0 {
		i -= len(m.NextMarker)
		copy(dAtA[i:], m.NextMarker)
		i = encodeVarintShardnode(dAtA, i, uint64(len(m.NextMarker)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Blobs) > 0 {
		for iNdEx := len(m.Blobs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Blobs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintShardnode(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DeleteBlobArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteBlobArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteBlobArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintShardnode(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DeleteBlobRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteBlobRet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteBlobRet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *RetainBlobArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RetainBlobArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RetainBlobArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Lease != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.Lease))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintShardnode(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RetainBlobRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RetainBlobRet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RetainBlobRet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *SealBlobArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SealBlobArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SealBlobArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintShardnode(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Size_ != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SealBlobRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SealBlobRet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SealBlobRet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ShardStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShardStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.RaftStat.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	if m.Learner {
		i--
		if m.Learner {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.Units) > 0 {
		for iNdEx := len(m.Units) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Units[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintShardnode(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	{
		size, err := m.Range.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShardnode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.RouteVersion != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.RouteVersion))
		i--
		dAtA[i] = 0x20
	}
	if m.LeaderIdx != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.LeaderIdx))
		i--
		dAtA[i] = 0x18
	}
	if m.AppliedIndex != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.AppliedIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.Suid != 0 {
		i = encodeVarintShardnode(dAtA, i, uint64(m.Suid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintShardnode(dAtA []byte, offset int, v uint64) int {
	offset -= sovShardnode(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Item) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovShardnode(uint64(l))
	}
	if len(m.Fields) > 0 {
		for _, e := range m.Fields {
			l = e.Size()
			n += 1 + l + sovShardnode(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Field) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovShardnode(uint64(m.ID))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovShardnode(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShardOpHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SpaceID != 0 {
		n += 1 + sovShardnode(uint64(m.SpaceID))
	}
	if m.DiskID != 0 {
		n += 1 + sovShardnode(uint64(m.DiskID))
	}
	if m.Suid != 0 {
		n += 1 + sovShardnode(uint64(m.Suid))
	}
	if m.SpaceVersion != 0 {
		n += 1 + sovShardnode(uint64(m.SpaceVersion))
	}
	if m.RouteVersion != 0 {
		n += 1 + sovShardnode(uint64(m.RouteVersion))
	}
	if len(m.ShardKeys) > 0 {
		for _, b := range m.ShardKeys {
			l = len(b)
			n += 1 + l + sovShardnode(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InsertItemArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovShardnode(uint64(l))
	l = m.Item.Size()
	n += 1 + l + sovShardnode(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InsertItemRet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateItemArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovShardnode(uint64(l))
	l = m.Item.Size()
	n += 1 + l + sovShardnode(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateItemRet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteItemArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovShardnode(uint64(l))
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovShardnode(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteItemRet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetItemArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovShardnode(uint64(l))
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovShardnode(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetItemRet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Item.Size()
	n += 1 + l + sovShardnode(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListItemArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovShardnode(uint64(l))
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovShardnode(uint64(l))
	}
	l = len(m.Marker)
	if l > 0 {
		n += 1 + l + sovShardnode(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovShardnode(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListItemRet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovShardnode(uint64(l))
		}
	}
	l = len(m.NextMarker)
	if l > 0 {
		n += 1 + l + sovShardnode(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddShardArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DiskID != 0 {
		n += 1 + sovShardnode(uint64(m.DiskID))
	}
	if m.Suid != 0 {
		n += 1 + sovShardnode(uint64(m.Suid))
	}
	l = m.Range.Size()
	n += 1 + l + sovShardnode(uint64(l))
	if len(m.Units) > 0 {
		for _, e := range m.Units {
			l = e.Size()
			n += 1 + l + sovShardnode(uint64(l))
		}
	}
	if m.RouteVersion != 0 {
		n += 1 + sovShardnode(uint64(m.RouteVersion))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddShardRet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateShardArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DiskID != 0 {
		n += 1 + sovShardnode(uint64(m.DiskID))
	}
	if m.Suid != 0 {
		n += 1 + sovShardnode(uint64(m.Suid))
	}
	if m.ShardUpdateType != 0 {
		n += 1 + sovShardnode(uint64(m.ShardUpdateType))
	}
	l = m.Unit.Size()
	n += 1 + l + sovShardnode(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateShardRet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetShardArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DiskID != 0 {
		n += 1 + sovShardnode(uint64(m.DiskID))
	}
	if m.Suid != 0 {
		n += 1 + sovShardnode(uint64(m.Suid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetShardRet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Shard.Size()
	n += 1 + l + sovShardnode(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateBlobArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovShardnode(uint64(l))
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovShardnode(uint64(l))
	}
	if m.CodeMode != 0 {
		n += 1 + sovShardnode(uint64(m.CodeMode))
	}
	if m.Size_ != 0 {
		n += 1 + sovShardnode(uint64(m.Size_))
	}
	if m.SliceSize != 0 {
		n += 1 + sovShardnode(uint64(m.SliceSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateBlobRet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Blob.Size()
	n += 1 + l + sovShardnode(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetBlobArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovShardnode(uint64(l))
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovShardnode(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetBlobRet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Blob.Size()
	n += 1 + l + sovShardnode(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListBlobArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovShardnode(uint64(l))
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovShardnode(uint64(l))
	}
	l = len(m.Marker)
	if l > 0 {
		n += 1 + l + sovShardnode(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovShardnode(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListBlobRet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Blobs) > 0 {
		for _, e := range m.Blobs {
			l = e.Size()
			n += 1 + l + sovShardnode(uint64(l))
		}
	}
	l = len(m.NextMarker)
	if l > 0 {
		n += 1 + l + sovShardnode(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteBlobArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovShardnode(uint64(l))
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovShardnode(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteBlobRet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RetainBlobArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovShardnode(uint64(l))
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovShardnode(uint64(l))
	}
	if m.Lease != 0 {
		n += 1 + sovShardnode(uint64(m.Lease))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RetainBlobRet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SealBlobArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovShardnode(uint64(l))
	if m.Size_ != 0 {
		n += 1 + sovShardnode(uint64(m.Size_))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovShardnode(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SealBlobRet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShardStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Suid != 0 {
		n += 1 + sovShardnode(uint64(m.Suid))
	}
	if m.AppliedIndex != 0 {
		n += 1 + sovShardnode(uint64(m.AppliedIndex))
	}
	if m.LeaderIdx != 0 {
		n += 1 + sovShardnode(uint64(m.LeaderIdx))
	}
	if m.RouteVersion != 0 {
		n += 1 + sovShardnode(uint64(m.RouteVersion))
	}
	l = m.Range.Size()
	n += 1 + l + sovShardnode(uint64(l))
	if len(m.Units) > 0 {
		for _, e := range m.Units {
			l = e.Size()
			n += 1 + l + sovShardnode(uint64(l))
		}
	}
	if m.Learner {
		n += 2
	}
	l = m.RaftStat.Size()
	n += 1 + l + sovShardnode(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovShardnode(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozShardnode(x uint64) (n int) {
	return sovShardnode(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Item) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Item: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Item: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = append(m.ID[:0], dAtA[iNdEx:postIndex]...)
			if m.ID == nil {
				m.ID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, Field{})
			if err := m.Fields[len(m.Fields)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Field) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Field: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Field: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= github_com_cubefs_cubefs_blobstore_common_proto.FieldID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardOpHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardOpHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardOpHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceID", wireType)
			}
			m.SpaceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpaceID |= github_com_cubefs_cubefs_blobstore_common_proto.SpaceID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskID", wireType)
			}
			m.DiskID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskID |= github_com_cubefs_cubefs_blobstore_common_proto.DiskID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Suid", wireType)
			}
			m.Suid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Suid |= github_com_cubefs_cubefs_blobstore_common_proto.Suid(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceVersion", wireType)
			}
			m.SpaceVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpaceVersion |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteVersion", wireType)
			}
			m.RouteVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouteVersion |= github_com_cubefs_cubefs_blobstore_common_proto.RouteVersion(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardKeys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShardKeys = append(m.ShardKeys, make([]byte, postIndex-iNdEx))
			copy(m.ShardKeys[len(m.ShardKeys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InsertItemArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InsertItemArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InsertItemArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InsertItemRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InsertItemRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InsertItemRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateItemArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateItemArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateItemArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateItemRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateItemRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateItemRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteItemArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteItemArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteItemArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = append(m.ID[:0], dAtA[iNdEx:postIndex]...)
			if m.ID == nil {
				m.ID = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteItemRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteItemRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteItemRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetItemArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetItemArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetItemArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = append(m.ID[:0], dAtA[iNdEx:postIndex]...)
			if m.ID == nil {
				m.ID = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetItemRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetItemRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetItemRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListItemArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListItemArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListItemArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = append(m.Prefix[:0], dAtA[iNdEx:postIndex]...)
			if m.Prefix == nil {
				m.Prefix = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Marker", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Marker = append(m.Marker[:0], dAtA[iNdEx:postIndex]...)
			if m.Marker == nil {
				m.Marker = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListItemRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListItemRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListItemRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, Item{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextMarker", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextMarker = append(m.NextMarker[:0], dAtA[iNdEx:postIndex]...)
			if m.NextMarker == nil {
				m.NextMarker = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddShardArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddShardArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddShardArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskID", wireType)
			}
			m.DiskID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskID |= github_com_cubefs_cubefs_blobstore_common_proto.DiskID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Suid", wireType)
			}
			m.Suid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Suid |= github_com_cubefs_cubefs_blobstore_common_proto.Suid(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Units", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Units = append(m.Units, clustermgr.ShardUnit{})
			if err := m.Units[len(m.Units)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteVersion", wireType)
			}
			m.RouteVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouteVersion |= github_com_cubefs_cubefs_blobstore_common_proto.RouteVersion(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddShardRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddShardRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddShardRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateShardArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateShardArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateShardArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskID", wireType)
			}
			m.DiskID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskID |= github_com_cubefs_cubefs_blobstore_common_proto.DiskID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Suid", wireType)
			}
			m.Suid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Suid |= github_com_cubefs_cubefs_blobstore_common_proto.Suid(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardUpdateType", wireType)
			}
			m.ShardUpdateType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardUpdateType |= github_com_cubefs_cubefs_blobstore_common_proto.ShardUpdateType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Unit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateShardRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateShardRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateShardRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetShardArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetShardArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetShardArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskID", wireType)
			}
			m.DiskID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskID |= github_com_cubefs_cubefs_blobstore_common_proto.DiskID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Suid", wireType)
			}
			m.Suid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Suid |= github_com_cubefs_cubefs_blobstore_common_proto.Suid(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetShardRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetShardRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetShardRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Shard.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateBlobArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateBlobArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateBlobArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = append(m.Name[:0], dAtA[iNdEx:postIndex]...)
			if m.Name == nil {
				m.Name = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CodeMode", wireType)
			}
			m.CodeMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CodeMode |= github_com_cubefs_cubefs_blobstore_common_codemode.CodeMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SliceSize", wireType)
			}
			m.SliceSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SliceSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateBlobRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateBlobRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateBlobRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blob", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Blob.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetBlobArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetBlobArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetBlobArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = append(m.Name[:0], dAtA[iNdEx:postIndex]...)
			if m.Name == nil {
				m.Name = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetBlobRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetBlobRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetBlobRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blob", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Blob.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListBlobArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListBlobArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListBlobArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = append(m.Prefix[:0], dAtA[iNdEx:postIndex]...)
			if m.Prefix == nil {
				m.Prefix = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Marker", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Marker = append(m.Marker[:0], dAtA[iNdEx:postIndex]...)
			if m.Marker == nil {
				m.Marker = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListBlobRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListBlobRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListBlobRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blobs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Blobs = append(m.Blobs, proto1.Blob{})
			if err := m.Blobs[len(m.Blobs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextMarker", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextMarker = append(m.NextMarker[:0], dAtA[iNdEx:postIndex]...)
			if m.NextMarker == nil {
				m.NextMarker = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteBlobArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteBlobArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteBlobArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = append(m.Name[:0], dAtA[iNdEx:postIndex]...)
			if m.Name == nil {
				m.Name = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteBlobRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteBlobRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteBlobRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RetainBlobArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RetainBlobArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RetainBlobArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = append(m.Name[:0], dAtA[iNdEx:postIndex]...)
			if m.Name == nil {
				m.Name = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lease", wireType)
			}
			m.Lease = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lease |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RetainBlobRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RetainBlobRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RetainBlobRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SealBlobArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SealBlobArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SealBlobArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = append(m.Name[:0], dAtA[iNdEx:postIndex]...)
			if m.Name == nil {
				m.Name = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SealBlobRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SealBlobRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SealBlobRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Suid", wireType)
			}
			m.Suid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Suid |= github_com_cubefs_cubefs_blobstore_common_proto.Suid(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppliedIndex", wireType)
			}
			m.AppliedIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppliedIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderIdx", wireType)
			}
			m.LeaderIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeaderIdx |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteVersion", wireType)
			}
			m.RouteVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouteVersion |= github_com_cubefs_cubefs_blobstore_common_proto.RouteVersion(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Units", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Units = append(m.Units, clustermgr.ShardUnit{})
			if err := m.Units[len(m.Units)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Learner", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Learner = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShardnode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShardnode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RaftStat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShardnode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShardnode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipShardnode(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowShardnode
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowShardnode
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthShardnode
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupShardnode
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthShardnode
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthShardnode        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowShardnode          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupShardnode = fmt.Errorf("proto: unexpected end of group")
)
